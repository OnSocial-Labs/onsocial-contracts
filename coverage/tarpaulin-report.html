<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>html, body {
  margin: 0;
  padding: 0;
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: #ddd;
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: #ccf;
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: #fcc;
}
.files-list__file_medium {
  background: #ffc;
}
.files-list__file_high {
  background: #cfc;
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: sticky;
  top: 0;
  background: white;
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: #338;
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
  counter-reset: line;
  display: flex;
  flex-direction: column;
}

.code-line::before {
    content: counter(line);
    margin-right: 10px;
}
.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
  counter-increment: line;
}
.code-line_covered {
  background: #cfc;
}
.code-line_uncovered {
  background: #fcc;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["/","code","contracts","auth-onsocial","src","errors.rs"],"content":"use near_sdk::borsh::{BorshDeserialize, BorshSerialize};\nuse near_sdk::{env, FunctionError};\nuse near_sdk_macros::NearSchema;\n\n#[derive(Debug, PartialEq, NearSchema, BorshSerialize, BorshDeserialize)]\n#[abi(borsh)]\npub enum AuthError {\n    Unauthorized,\n    KeyNotFound,\n    KeyAlreadyExists,\n    AccountStillActive,\n    MissingInput,\n}\n\nimpl FunctionError for AuthError {\n    fn panic(\u0026self) -\u003e ! {\n        env::panic_str(match self {\n            AuthError::Unauthorized =\u003e \"Unauthorized access\",\n            AuthError::KeyNotFound =\u003e \"Key not found\",\n            AuthError::KeyAlreadyExists =\u003e \"Key already exists\",\n            AuthError::AccountStillActive =\u003e \"Account is still active\",\n            AuthError::MissingInput =\u003e \"No input provided\",\n        })\n    }\n}\n","traces":[{"line":16,"address":[1293472],"length":1,"stats":{"Line":0}},{"line":17,"address":[1293481,1293625],"length":1,"stats":{"Line":0}},{"line":18,"address":[1293512],"length":1,"stats":{"Line":0}},{"line":19,"address":[1293535],"length":1,"stats":{"Line":0}},{"line":20,"address":[1293558],"length":1,"stats":{"Line":0}},{"line":21,"address":[1293581],"length":1,"stats":{"Line":0}},{"line":22,"address":[1293604],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":7},{"path":["/","code","contracts","auth-onsocial","src","events.rs"],"content":"use near_sdk::{near, AccountId};\n\n#[near(event_json(standard = \"nep297\"))]\npub enum AuthEvent {\n    #[event_version(\"1.0.0\")]\n    KeyRegistered {\n        account_id: AccountId,\n        public_key: String,\n    },\n    #[event_version(\"1.0.0\")]\n    KeyRemoved {\n        account_id: AccountId,\n        public_key: String,\n    },\n    #[event_version(\"1.0.0\")]\n    KeyRotated {\n        account_id: AccountId,\n        old_public_key: String,\n        new_public_key: String,\n    },\n    #[event_version(\"1.0.0\")]\n    ContractUpgraded { manager: AccountId, timestamp: u64 },\n    #[event_version(\"1.0.0\")]\n    ManagerChanged {\n        old_manager: AccountId,\n        new_manager: AccountId,\n        timestamp: u64,\n    },\n    #[event_version(\"1.0.0\")]\n    StateMigrated {\n        old_version: String,\n        new_version: String,\n    },\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","code","contracts","auth-onsocial","src","lib.rs"],"content":"use crate::errors::AuthError;\nuse crate::events::AuthEvent;\nuse crate::state::AuthContractState;\nuse crate::state_versions::{StateV010, StateV011};\nuse crate::types::{KeyInfo, RotateKeyArgs};\nuse near_sdk::{env, near, AccountId, PanicOnDefault, Promise, PublicKey};\n\npub mod errors;\nmod events;\npub mod state;\npub mod state_versions;\n#[cfg(test)]\nmod tests;\npub mod types;\n\n#[near(contract_state)]\n#[derive(PanicOnDefault)]\npub struct AuthContract {\n    state: AuthContractState,\n}\n\n#[near]\nimpl AuthContract {\n    #[init]\n    pub fn new() -\u003e Self {\n        Self {\n            state: AuthContractState::new(),\n        }\n    }\n\n    pub fn is_authorized(\n        \u0026mut self,\n        account_id: AccountId,\n        public_key: PublicKey,\n        signatures: Option\u003cVec\u003cVec\u003cu8\u003e\u003e\u003e,\n    ) -\u003e bool {\n        self.state\n            .is_authorized(\u0026account_id, \u0026public_key, signatures)\n    }\n\n    #[handle_result]\n    pub fn register_key(\n        \u0026mut self,\n        account_id: AccountId,\n        public_key: PublicKey,\n        expiration_days: Option\u003cu32\u003e,\n        is_multi_sig: bool,\n        multi_sig_threshold: Option\u003cu32\u003e,\n    ) -\u003e Result\u003c(), AuthError\u003e {\n        self.state.register_key(\n            \u0026env::predecessor_account_id(),\n            \u0026account_id,\n            public_key,\n            expiration_days,\n            is_multi_sig,\n            multi_sig_threshold,\n        )\n    }\n\n    #[handle_result]\n    pub fn remove_key(\n        \u0026mut self,\n        account_id: AccountId,\n        public_key: PublicKey,\n    ) -\u003e Result\u003c(), AuthError\u003e {\n        self.state\n            .remove_key(\u0026env::predecessor_account_id(), \u0026account_id, public_key)\n    }\n\n    #[handle_result]\n    pub fn rotate_key(\u0026mut self, args: RotateKeyArgs) -\u003e Result\u003c(), AuthError\u003e {\n        self.state.rotate_key(\u0026env::predecessor_account_id(), args)\n    }\n\n    #[handle_result]\n    pub fn remove_expired_keys(\u0026mut self, account_id: AccountId) -\u003e Result\u003c(), AuthError\u003e {\n        self.state.remove_expired_keys(\u0026account_id)\n    }\n\n    #[handle_result]\n    pub fn remove_inactive_accounts(\u0026mut self, account_id: AccountId) -\u003e Result\u003c(), AuthError\u003e {\n        self.state.remove_inactive_accounts(account_id)\n    }\n\n    pub fn get_inactive_accounts(\u0026self, limit: u32, offset: u32) -\u003e Vec\u003cAccountId\u003e {\n        self.state.get_inactive_accounts(limit, offset)\n    }\n\n    pub fn get_key_info(\u0026self, account_id: AccountId, public_key: PublicKey) -\u003e Option\u003cKeyInfo\u003e {\n        self.state.get_key_info(\u0026account_id, \u0026public_key)\n    }\n\n    pub fn get_keys(\u0026self, account_id: AccountId, limit: u32, offset: u32) -\u003e Vec\u003cKeyInfo\u003e {\n        self.state.get_keys(\u0026account_id, limit, offset)\n    }\n\n    #[handle_result]\n    pub fn update_contract(\u0026mut self) -\u003e Result\u003cPromise, AuthError\u003e {\n        self.state.update_contract()\n    }\n\n    #[handle_result]\n    pub fn set_manager(\u0026mut self, new_manager: AccountId) -\u003e Result\u003c(), AuthError\u003e {\n        self.state\n            .set_manager(\u0026env::predecessor_account_id(), new_manager)\n    }\n\n    #[private]\n    #[init(ignore_state)]\n    pub fn migrate() -\u003e Self {\n        const CURRENT_VERSION: \u0026str = \"0.1.1\";\n\n        let state_bytes: Vec\u003cu8\u003e = env::state_read().unwrap_or_default();\n\n        // Try current version (0.1.1)\n        if let Ok(state) = near_sdk::borsh::from_slice::\u003cAuthContractState\u003e(\u0026state_bytes) {\n            if state.version == CURRENT_VERSION {\n                env::log_str(\"State is already at latest version\");\n                return Self { state };\n            }\n        }\n\n        // Try version 0.1.1\n        if let Ok(old_state) = near_sdk::borsh::from_slice::\u003cStateV011\u003e(\u0026state_bytes) {\n            if old_state.version == \"0.1.1\" {\n                env::log_str(\"Migrating from state version 0.1.1\");\n                let new_state = AuthContractState {\n                    version: CURRENT_VERSION.to_string(),\n                    keys: old_state.keys,\n                    last_active_timestamps: old_state.last_active_timestamps,\n                    registered_accounts: old_state.registered_accounts,\n                    manager: old_state.manager,\n                    max_keys_per_account: old_state.max_keys_per_account,\n                };\n                AuthEvent::StateMigrated {\n                    old_version: \"0.1.1\".to_string(),\n                    new_version: CURRENT_VERSION.to_string(),\n                }\n                .emit();\n                return Self { state: new_state };\n            }\n        }\n\n        // Try version 0.1.0\n        if let Ok(old_state) = near_sdk::borsh::from_slice::\u003cStateV010\u003e(\u0026state_bytes) {\n            if old_state.version == \"0.1.0\" {\n                env::log_str(\"Migrating from state version 0.1.0\");\n                let new_state = AuthContractState {\n                    version: CURRENT_VERSION.to_string(),\n                    keys: old_state.keys,\n                    last_active_timestamps: old_state.last_active_timestamps,\n                    registered_accounts: old_state.registered_accounts,\n                    manager: old_state.manager,\n                    max_keys_per_account: 100, // Default value\n                };\n                AuthEvent::StateMigrated {\n                    old_version: \"0.1.0\".to_string(),\n                    new_version: CURRENT_VERSION.to_string(),\n                }\n                .emit();\n                return Self { state: new_state };\n            }\n        }\n\n        env::log_str(\"No valid prior state found, initializing new state\");\n        Self {\n            state: AuthContractState::new(),\n        }\n    }\n}\n","traces":[{"line":25,"address":[1668544],"length":1,"stats":{"Line":0}},{"line":27,"address":[1668560],"length":1,"stats":{"Line":0}},{"line":31,"address":[1668774,1668608],"length":1,"stats":{"Line":0}},{"line":37,"address":[1668661],"length":1,"stats":{"Line":0}},{"line":42,"address":[1669259,1669218,1668800],"length":1,"stats":{"Line":0}},{"line":50,"address":[1668931,1669092],"length":1,"stats":{"Line":0}},{"line":51,"address":[1668947,1669051],"length":1,"stats":{"Line":0}},{"line":53,"address":[1669061],"length":1,"stats":{"Line":0}},{"line":61,"address":[1669533,1669280,1669574],"length":1,"stats":{"Line":0}},{"line":66,"address":[1669312,1669445],"length":1,"stats":{"Line":0}},{"line":67,"address":[1669398,1669322],"length":1,"stats":{"Line":0}},{"line":71,"address":[1669584,1669874],"length":1,"stats":{"Line":0}},{"line":72,"address":[1669707,1669609],"length":1,"stats":{"Line":0}},{"line":76,"address":[1670007,1669920],"length":1,"stats":{"Line":0}},{"line":77,"address":[1669944],"length":1,"stats":{"Line":0}},{"line":81,"address":[1670032],"length":1,"stats":{"Line":0}},{"line":82,"address":[1670050],"length":1,"stats":{"Line":0}},{"line":85,"address":[1670064],"length":1,"stats":{"Line":0}},{"line":86,"address":[1670088],"length":1,"stats":{"Line":0}},{"line":89,"address":[1670261,1670112],"length":1,"stats":{"Line":0}},{"line":90,"address":[1670155],"length":1,"stats":{"Line":0}},{"line":93,"address":[1670413,1670288],"length":1,"stats":{"Line":0}},{"line":94,"address":[1670353],"length":1,"stats":{"Line":0}},{"line":98,"address":[1670432],"length":1,"stats":{"Line":0}},{"line":99,"address":[1670449],"length":1,"stats":{"Line":0}},{"line":103,"address":[1670464,1670664],"length":1,"stats":{"Line":0}},{"line":104,"address":[1670596,1670488],"length":1,"stats":{"Line":0}},{"line":105,"address":[1670566,1670498],"length":1,"stats":{"Line":0}},{"line":110,"address":[1674705,1671416,1670704],"length":1,"stats":{"Line":2}},{"line":113,"address":[1670727],"length":1,"stats":{"Line":2}},{"line":116,"address":[1670873,1670968],"length":1,"stats":{"Line":4}},{"line":117,"address":[1671066,1671175],"length":1,"stats":{"Line":2}},{"line":118,"address":[1671196],"length":1,"stats":{"Line":1}},{"line":119,"address":[1671285],"length":1,"stats":{"Line":1}},{"line":124,"address":[1671922,1671540,1671478],"length":1,"stats":{"Line":3}},{"line":125,"address":[1671670,1671780],"length":1,"stats":{"Line":0}},{"line":126,"address":[1671801],"length":1,"stats":{"Line":0}},{"line":128,"address":[1671927],"length":1,"stats":{"Line":0}},{"line":129,"address":[1671958],"length":1,"stats":{"Line":0}},{"line":130,"address":[1672014],"length":1,"stats":{"Line":0}},{"line":131,"address":[1672070],"length":1,"stats":{"Line":0}},{"line":132,"address":[1672142],"length":1,"stats":{"Line":0}},{"line":133,"address":[1672166],"length":1,"stats":{"Line":0}},{"line":136,"address":[1672388],"length":1,"stats":{"Line":0}},{"line":137,"address":[1672459],"length":1,"stats":{"Line":0}},{"line":140,"address":[1672726],"length":1,"stats":{"Line":0}},{"line":145,"address":[1673036,1673480,1673098],"length":1,"stats":{"Line":3}},{"line":146,"address":[1673338,1673228],"length":1,"stats":{"Line":2}},{"line":147,"address":[1673359],"length":1,"stats":{"Line":1}},{"line":149,"address":[1673485],"length":1,"stats":{"Line":1}},{"line":150,"address":[1673516],"length":1,"stats":{"Line":1}},{"line":151,"address":[1673572],"length":1,"stats":{"Line":1}},{"line":152,"address":[1673628],"length":1,"stats":{"Line":1}},{"line":153,"address":[1673700],"length":1,"stats":{"Line":1}},{"line":157,"address":[1673943],"length":1,"stats":{"Line":1}},{"line":158,"address":[1674014],"length":1,"stats":{"Line":1}},{"line":161,"address":[1674281],"length":1,"stats":{"Line":1}},{"line":165,"address":[1674607],"length":1,"stats":{"Line":1}},{"line":167,"address":[1674653],"length":1,"stats":{"Line":1}}],"covered":20,"coverable":59},{"path":["/","code","contracts","auth-onsocial","src","state.rs"],"content":"use crate::errors::AuthError;\nuse crate::events::AuthEvent;\nuse crate::types::{KeyInfo, RotateKeyArgs};\nuse near_sdk::borsh::{BorshDeserialize, BorshSerialize};\nuse near_sdk::store::{IterableSet, LookupMap, Vector};\nuse near_sdk::{env, log, AccountId, BorshStorageKey, Gas, NearToken, Promise, PublicKey};\n\nconst CALL_GAS: Gas = Gas::from_tgas(200);\nconst NO_ARGS: Vec\u003cu8\u003e = vec![];\n\n#[derive(BorshSerialize, BorshDeserialize, BorshStorageKey)]\n#[borsh(crate = \"near_sdk::borsh\")]\npub enum StorageKey {\n    Keys,\n    KeySet { account_id: AccountId },\n    LastActive,\n    Accounts,\n}\n\n#[derive(BorshSerialize, BorshDeserialize, near_sdk_macros::NearSchema)]\n#[borsh(crate = \"near_sdk::borsh\")]\n#[abi(borsh)]\npub struct AuthContractState {\n    pub version: String,\n    pub keys: LookupMap\u003cAccountId, IterableSet\u003cKeyInfo\u003e\u003e,\n    pub last_active_timestamps: LookupMap\u003cAccountId, u64\u003e,\n    pub registered_accounts: Vector\u003cAccountId\u003e,\n    pub manager: AccountId,\n    pub max_keys_per_account: u32,\n}\n\nimpl AuthContractState {\n    pub fn new() -\u003e Self {\n        Self {\n            version: \"0.1.1\".to_string(),\n            keys: LookupMap::new(StorageKey::Keys),\n            last_active_timestamps: LookupMap::new(StorageKey::LastActive),\n            registered_accounts: Vector::new(StorageKey::Accounts),\n            manager: env::predecessor_account_id(),\n            max_keys_per_account: 100,\n        }\n    }\n\n    pub fn is_authorized(\n        \u0026mut self,\n        account_id: \u0026AccountId,\n        public_key: \u0026PublicKey,\n        signatures: Option\u003cVec\u003cVec\u003cu8\u003e\u003e\u003e,\n    ) -\u003e bool {\n        let key_set = match self.keys.get(account_id) {\n            Some(set) =\u003e set,\n            None =\u003e return false,\n        };\n\n        let key_info = match key_set.iter().find(|k| k.public_key == *public_key) {\n            Some(info) =\u003e info,\n            None =\u003e return false,\n        };\n\n        if let Some(expiration) = key_info.expiration_timestamp {\n            if env::block_timestamp_ms() \u003e expiration {\n                return false;\n            }\n        }\n\n        let authorized = if key_info.is_multi_sig {\n            let threshold = key_info.multi_sig_threshold.unwrap_or(1);\n            let signatures = signatures.unwrap_or_default();\n            signatures.len() as u32 \u003e= threshold\n        } else {\n            true\n        };\n\n        if authorized {\n            self.last_active_timestamps\n                .insert(account_id.clone(), env::block_timestamp_ms());\n        }\n\n        authorized\n    }\n\n    pub fn register_key(\n        \u0026mut self,\n        caller: \u0026AccountId,\n        account_id: \u0026AccountId,\n        public_key: PublicKey,\n        expiration_days: Option\u003cu32\u003e,\n        is_multi_sig: bool,\n        multi_sig_threshold: Option\u003cu32\u003e,\n    ) -\u003e Result\u003c(), AuthError\u003e {\n        log!(\"Registering key for account: {}\", account_id);\n        if caller != account_id {\n            return Err(AuthError::Unauthorized);\n        }\n\n        let expiration_timestamp = expiration_days\n            .map(|days| env::block_timestamp_ms() + (days as u64 * 24 * 60 * 60 * 1000));\n\n        let key_info = KeyInfo {\n            public_key: public_key.clone(),\n            expiration_timestamp,\n            is_multi_sig,\n            multi_sig_threshold,\n        };\n\n        if self.keys.get(account_id).is_none() {\n            log!(\"Creating new key set for account: {}\", account_id);\n            self.keys.insert(\n                account_id.clone(),\n                IterableSet::new(StorageKey::KeySet {\n                    account_id: account_id.clone(),\n                }),\n            );\n            self.registered_accounts.push(account_id.clone());\n        }\n\n        let key_set = self.keys.get_mut(account_id).expect(\"Key set should exist\");\n        if key_set.contains(\u0026key_info) {\n            return Err(AuthError::KeyAlreadyExists);\n        }\n        if key_set.len() \u003e= self.max_keys_per_account {\n            return Err(AuthError::KeyAlreadyExists); // Reuse error for max keys limit\n        }\n        key_set.insert(key_info);\n\n        self.last_active_timestamps\n            .insert(account_id.clone(), env::block_timestamp_ms());\n\n        AuthEvent::KeyRegistered {\n            account_id: account_id.clone(),\n            public_key: format!(\"{:?}\", public_key),\n        }\n        .emit();\n\n        Ok(())\n    }\n\n    pub fn remove_key(\n        \u0026mut self,\n        caller: \u0026AccountId,\n        account_id: \u0026AccountId,\n        public_key: PublicKey,\n    ) -\u003e Result\u003c(), AuthError\u003e {\n        if caller != account_id {\n            return Err(AuthError::Unauthorized);\n        }\n\n        let key_set = self\n            .keys\n            .get_mut(account_id)\n            .ok_or(AuthError::KeyNotFound)?;\n        let key_info = KeyInfo {\n            public_key: public_key.clone(),\n            expiration_timestamp: None,\n            is_multi_sig: false,\n            multi_sig_threshold: None,\n        };\n        if !key_set.remove(\u0026key_info) {\n            return Err(AuthError::KeyNotFound);\n        }\n\n        if key_set.is_empty() {\n            self.keys.remove(account_id);\n            self.last_active_timestamps.remove(account_id);\n            if let Some(index) = self\n                .registered_accounts\n                .iter()\n                .position(|id| id == account_id)\n            {\n                self.registered_accounts.swap_remove(index as u32);\n            }\n        }\n\n        AuthEvent::KeyRemoved {\n            account_id: account_id.clone(),\n            public_key: format!(\"{:?}\", public_key),\n        }\n        .emit();\n\n        Ok(())\n    }\n\n    pub fn rotate_key(\u0026mut self, caller: \u0026AccountId, args: RotateKeyArgs) -\u003e Result\u003c(), AuthError\u003e {\n        if caller != \u0026args.account_id {\n            return Err(AuthError::Unauthorized);\n        }\n\n        let key_set = self\n            .keys\n            .get_mut(\u0026args.account_id)\n            .ok_or(AuthError::KeyNotFound)?;\n        let old_key_info = KeyInfo {\n            public_key: args.old_public_key.clone(),\n            expiration_timestamp: None,\n            is_multi_sig: false,\n            multi_sig_threshold: None,\n        };\n        if !key_set.contains(\u0026old_key_info) {\n            return Err(AuthError::KeyNotFound);\n        }\n\n        let new_key_info = KeyInfo {\n            public_key: args.new_public_key.clone(),\n            expiration_timestamp: args\n                .expiration_days\n                .map(|days| env::block_timestamp_ms() + (days as u64 * 24 * 60 * 60 * 1000)),\n            is_multi_sig: args.is_multi_sig,\n            multi_sig_threshold: args.multi_sig_threshold,\n        };\n        if key_set.contains(\u0026new_key_info) {\n            return Err(AuthError::KeyAlreadyExists);\n        }\n\n        key_set.remove(\u0026old_key_info);\n        key_set.insert(new_key_info);\n        self.last_active_timestamps\n            .insert(args.account_id.clone(), env::block_timestamp_ms());\n\n        AuthEvent::KeyRotated {\n            account_id: args.account_id.clone(),\n            old_public_key: format!(\"{:?}\", args.old_public_key),\n            new_public_key: format!(\"{:?}\", args.new_public_key),\n        }\n        .emit();\n\n        Ok(())\n    }\n\n    pub fn remove_expired_keys(\u0026mut self, account_id: \u0026AccountId) -\u003e Result\u003c(), AuthError\u003e {\n        let key_set = self\n            .keys\n            .get_mut(account_id)\n            .ok_or(AuthError::KeyNotFound)?;\n        let current_timestamp = env::block_timestamp_ms();\n        let mut to_remove = Vec::new();\n\n        for key_info in key_set.iter() {\n            if key_info\n                .expiration_timestamp\n                .is_some_and(|exp| current_timestamp \u003e exp)\n            {\n                to_remove.push(key_info.clone());\n            }\n        }\n\n        for key_info in to_remove {\n            key_set.remove(\u0026key_info);\n            AuthEvent::KeyRemoved {\n                account_id: account_id.clone(),\n                public_key: format!(\"{:?}\", key_info.public_key),\n            }\n            .emit();\n        }\n\n        if key_set.is_empty() {\n            self.keys.remove(account_id);\n            self.last_active_timestamps.remove(account_id);\n            if let Some(index) = self\n                .registered_accounts\n                .iter()\n                .position(|id| id == account_id)\n            {\n                self.registered_accounts.swap_remove(index as u32);\n            }\n        }\n\n        Ok(())\n    }\n\n    pub fn remove_inactive_accounts(\u0026mut self, account_id: AccountId) -\u003e Result\u003c(), AuthError\u003e {\n        let last_active = self\n            .last_active_timestamps\n            .get(\u0026account_id)\n            .ok_or(AuthError::KeyNotFound)?;\n        let current_timestamp = env::block_timestamp_ms();\n        const ONE_YEAR_MS: u64 = 31_536_000_000;\n\n        if current_timestamp \u003c= last_active + ONE_YEAR_MS {\n            return Err(AuthError::AccountStillActive);\n        }\n\n        let key_set = self\n            .keys\n            .get_mut(\u0026account_id)\n            .ok_or(AuthError::KeyNotFound)?;\n        let to_remove: Vec\u003c_\u003e = key_set.iter().cloned().collect();\n        for key_info in to_remove {\n            key_set.remove(\u0026key_info);\n            AuthEvent::KeyRemoved {\n                account_id: account_id.clone(),\n                public_key: format!(\"{:?}\", key_info.public_key),\n            }\n            .emit();\n        }\n\n        self.keys.remove(\u0026account_id);\n        self.last_active_timestamps.remove(\u0026account_id);\n        if let Some(index) = self\n            .registered_accounts\n            .iter()\n            .position(|id| id == \u0026account_id)\n        {\n            self.registered_accounts.swap_remove(index as u32);\n        }\n\n        Ok(())\n    }\n\n    pub fn get_inactive_accounts(\u0026self, limit: u32, offset: u32) -\u003e Vec\u003cAccountId\u003e {\n        assert!(limit \u003c= 100, \"Limit exceeds maximum allowed value\");\n        let current_timestamp = env::block_timestamp_ms();\n        const ONE_YEAR_MS: u64 = 31_536_000_000;\n        let mut inactive_accounts = Vec::new();\n        let start = offset as usize;\n        let end = (offset + limit) as usize;\n\n        for account_id in self\n            .registered_accounts\n            .iter()\n            .skip(start)\n            .take(end - start)\n        {\n            if let Some(timestamp) = self.last_active_timestamps.get(account_id) {\n                if current_timestamp \u003e timestamp + ONE_YEAR_MS {\n                    inactive_accounts.push(account_id.clone());\n                }\n            }\n        }\n        inactive_accounts\n    }\n\n    pub fn get_key_info(\u0026self, account_id: \u0026AccountId, public_key: \u0026PublicKey) -\u003e Option\u003cKeyInfo\u003e {\n        self.keys\n            .get(account_id)\n            .and_then(|set| set.iter().find(|k| k.public_key == *public_key).cloned())\n    }\n\n    pub fn get_keys(\u0026self, account_id: \u0026AccountId, limit: u32, offset: u32) -\u003e Vec\u003cKeyInfo\u003e {\n        assert!(limit \u003c= 100, \"Limit exceeds maximum allowed value\");\n        let key_set = match self.keys.get(account_id) {\n            Some(set) =\u003e set,\n            None =\u003e return Vec::new(),\n        };\n        let start = offset as usize;\n        let end = (offset + limit) as usize;\n        key_set\n            .iter()\n            .skip(start)\n            .take(end - start)\n            .cloned()\n            .collect()\n    }\n\n    pub fn update_contract(\u0026mut self) -\u003e Result\u003cPromise, AuthError\u003e {\n        if env::predecessor_account_id() != self.manager {\n            return Err(AuthError::Unauthorized);\n        }\n        let code = env::input()\n            .filter(|input| !input.is_empty())\n            .ok_or(AuthError::MissingInput)?\n            .to_vec();\n        log!(\"Upgrading contract by manager: {}\", self.manager);\n        AuthEvent::ContractUpgraded {\n            manager: self.manager.clone(),\n            timestamp: env::block_timestamp_ms(),\n        }\n        .emit();\n        Ok(Promise::new(env::current_account_id())\n            .deploy_contract(code)\n            .function_call(\n                \"migrate\".to_string(),\n                NO_ARGS,\n                NearToken::from_near(0),\n                CALL_GAS,\n            ))\n    }\n\n    pub fn set_manager(\n        \u0026mut self,\n        caller: \u0026AccountId,\n        new_manager: AccountId,\n    ) -\u003e Result\u003c(), AuthError\u003e {\n        if caller != \u0026self.manager {\n            return Err(AuthError::Unauthorized);\n        }\n        log!(\"Changing manager from {} to {}\", caller, new_manager);\n        self.manager = new_manager.clone();\n        AuthEvent::ManagerChanged {\n            old_manager: caller.clone(),\n            new_manager,\n            timestamp: env::block_timestamp_ms(),\n        }\n        .emit();\n        Ok(())\n    }\n}\n\nimpl Default for AuthContractState {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n","traces":[{"line":33,"address":[1444943,1444480],"length":1,"stats":{"Line":1}},{"line":35,"address":[1444497],"length":1,"stats":{"Line":1}},{"line":36,"address":[1444523],"length":1,"stats":{"Line":1}},{"line":37,"address":[1444590],"length":1,"stats":{"Line":1}},{"line":38,"address":[1444659],"length":1,"stats":{"Line":1}},{"line":39,"address":[1444731],"length":1,"stats":{"Line":1}},{"line":44,"address":[1445879,1444976],"length":1,"stats":{"Line":0}},{"line":50,"address":[1445027,1445113],"length":1,"stats":{"Line":0}},{"line":51,"address":[1445157],"length":1,"stats":{"Line":0}},{"line":52,"address":[1445150],"length":1,"stats":{"Line":0}},{"line":55,"address":[1429617,1429600],"length":1,"stats":{"Line":0}},{"line":56,"address":[1445278],"length":1,"stats":{"Line":0}},{"line":57,"address":[1445271],"length":1,"stats":{"Line":0}},{"line":60,"address":[1445299],"length":1,"stats":{"Line":0}},{"line":61,"address":[1445366,1445327],"length":1,"stats":{"Line":0}},{"line":62,"address":[1445371],"length":1,"stats":{"Line":0}},{"line":66,"address":[1445403,1445348],"length":1,"stats":{"Line":0}},{"line":67,"address":[1445464,1445410],"length":1,"stats":{"Line":0}},{"line":68,"address":[1445471],"length":1,"stats":{"Line":0}},{"line":69,"address":[1445602,1445525],"length":1,"stats":{"Line":0}},{"line":71,"address":[1445395],"length":1,"stats":{"Line":0}},{"line":74,"address":[1445436,1445836],"length":1,"stats":{"Line":0}},{"line":75,"address":[1445676,1445797],"length":1,"stats":{"Line":0}},{"line":76,"address":[1445857,1445828,1445685],"length":1,"stats":{"Line":0}},{"line":79,"address":[1445634],"length":1,"stats":{"Line":0}},{"line":82,"address":[1445920,1448327,1448437],"length":1,"stats":{"Line":2}},{"line":91,"address":[1446084,1446179],"length":1,"stats":{"Line":3}},{"line":92,"address":[1446416],"length":1,"stats":{"Line":1}},{"line":93,"address":[1446480],"length":1,"stats":{"Line":0}},{"line":96,"address":[1446457,1446531],"length":1,"stats":{"Line":4}},{"line":97,"address":[1429660,1429648],"length":1,"stats":{"Line":2}},{"line":100,"address":[1446577],"length":1,"stats":{"Line":2}},{"line":106,"address":[1446785,1446709],"length":1,"stats":{"Line":3}},{"line":107,"address":[1446866],"length":1,"stats":{"Line":1}},{"line":108,"address":[1447122,1447328],"length":1,"stats":{"Line":4}},{"line":109,"address":[1447131],"length":1,"stats":{"Line":1}},{"line":110,"address":[1447272],"length":1,"stats":{"Line":1}},{"line":111,"address":[1447196],"length":1,"stats":{"Line":2}},{"line":114,"address":[1447406],"length":1,"stats":{"Line":1}},{"line":117,"address":[1446836,1447475],"length":1,"stats":{"Line":3}},{"line":118,"address":[1447527],"length":1,"stats":{"Line":2}},{"line":119,"address":[1447564],"length":1,"stats":{"Line":0}},{"line":121,"address":[1447553,1447603],"length":1,"stats":{"Line":3}},{"line":122,"address":[1447703],"length":1,"stats":{"Line":0}},{"line":124,"address":[1447616],"length":1,"stats":{"Line":1}},{"line":126,"address":[1447738,1447873],"length":1,"stats":{"Line":4}},{"line":127,"address":[1447747,1447904,1448336],"length":1,"stats":{"Line":2}},{"line":130,"address":[1447912],"length":1,"stats":{"Line":2}},{"line":131,"address":[1447979,1448030],"length":1,"stats":{"Line":3}},{"line":135,"address":[1448290],"length":1,"stats":{"Line":1}},{"line":138,"address":[1449729,1448464,1449707],"length":1,"stats":{"Line":0}},{"line":144,"address":[1448509,1448565],"length":1,"stats":{"Line":0}},{"line":145,"address":[1448597],"length":1,"stats":{"Line":0}},{"line":148,"address":[1449720,1448576,1448751,1448628,1448733],"length":1,"stats":{"Line":0}},{"line":151,"address":[1448741,1448620],"length":1,"stats":{"Line":0}},{"line":153,"address":[1448726],"length":1,"stats":{"Line":0}},{"line":158,"address":[1448908,1448963],"length":1,"stats":{"Line":0}},{"line":159,"address":[1448969],"length":1,"stats":{"Line":0}},{"line":162,"address":[1449039,1449008],"length":1,"stats":{"Line":0}},{"line":163,"address":[1449075],"length":1,"stats":{"Line":0}},{"line":164,"address":[1449119],"length":1,"stats":{"Line":0}},{"line":165,"address":[1449140],"length":1,"stats":{"Line":0}},{"line":168,"address":[1429902,1429888],"length":1,"stats":{"Line":0}},{"line":170,"address":[1449251],"length":1,"stats":{"Line":0}},{"line":175,"address":[1449337,1449045],"length":1,"stats":{"Line":0}},{"line":176,"address":[1449361,1449412],"length":1,"stats":{"Line":0}},{"line":180,"address":[1449664],"length":1,"stats":{"Line":0}},{"line":183,"address":[1451632,1451545,1449744],"length":1,"stats":{"Line":1}},{"line":184,"address":[1449873,1449777],"length":1,"stats":{"Line":2}},{"line":185,"address":[1449909],"length":1,"stats":{"Line":1}},{"line":188,"address":[1449889,1450072,1450054,1451623,1449949,1449897],"length":1,"stats":{"Line":6}},{"line":190,"address":[1449893],"length":1,"stats":{"Line":1}},{"line":191,"address":[1450062,1449941],"length":1,"stats":{"Line":2}},{"line":193,"address":[1450047],"length":1,"stats":{"Line":1}},{"line":198,"address":[1450229,1450284],"length":1,"stats":{"Line":2}},{"line":199,"address":[1450290],"length":1,"stats":{"Line":0}},{"line":203,"address":[1450319],"length":1,"stats":{"Line":1}},{"line":204,"address":[1450361],"length":1,"stats":{"Line":1}},{"line":207,"address":[1450448],"length":1,"stats":{"Line":1}},{"line":208,"address":[1450451],"length":1,"stats":{"Line":1}},{"line":210,"address":[1450601,1450545],"length":1,"stats":{"Line":2}},{"line":211,"address":[1450627],"length":1,"stats":{"Line":0}},{"line":214,"address":[1450620],"length":1,"stats":{"Line":1}},{"line":215,"address":[1450672],"length":1,"stats":{"Line":1}},{"line":216,"address":[1450769,1450900],"length":1,"stats":{"Line":2}},{"line":217,"address":[1450936,1450778,1451554],"length":1,"stats":{"Line":2}},{"line":220,"address":[1450944],"length":1,"stats":{"Line":1}},{"line":221,"address":[1451004,1451055],"length":1,"stats":{"Line":2}},{"line":222,"address":[1451160,1451223],"length":1,"stats":{"Line":2}},{"line":226,"address":[1451489],"length":1,"stats":{"Line":1}},{"line":229,"address":[1453210,1451648,1453133],"length":1,"stats":{"Line":0}},{"line":230,"address":[1451706,1451850,1451673],"length":1,"stats":{"Line":0}},{"line":233,"address":[1451839,1451698],"length":1,"stats":{"Line":0}},{"line":234,"address":[1451781],"length":1,"stats":{"Line":0}},{"line":235,"address":[1451798],"length":1,"stats":{"Line":0}},{"line":237,"address":[1451832,1452095,1451931],"length":1,"stats":{"Line":0}},{"line":238,"address":[1452116,1453146],"length":1,"stats":{"Line":0}},{"line":240,"address":[1430176,1430186],"length":1,"stats":{"Line":0}},{"line":242,"address":[1453168],"length":1,"stats":{"Line":0}},{"line":246,"address":[1452032,1452318,1452145,1452272],"length":1,"stats":{"Line":0}},{"line":247,"address":[1452390],"length":1,"stats":{"Line":0}},{"line":249,"address":[1452748],"length":1,"stats":{"Line":0}},{"line":250,"address":[1452863,1452796],"length":1,"stats":{"Line":0}},{"line":255,"address":[1452405],"length":1,"stats":{"Line":0}},{"line":256,"address":[1452449],"length":1,"stats":{"Line":0}},{"line":257,"address":[1452493],"length":1,"stats":{"Line":0}},{"line":258,"address":[1452514],"length":1,"stats":{"Line":0}},{"line":261,"address":[1430208,1430222],"length":1,"stats":{"Line":0}},{"line":263,"address":[1452625],"length":1,"stats":{"Line":0}},{"line":267,"address":[1452426],"length":1,"stats":{"Line":0}},{"line":270,"address":[1454837,1454788,1453248],"length":1,"stats":{"Line":0}},{"line":271,"address":[1453457,1453475,1453356,1454828,1453281],"length":1,"stats":{"Line":0}},{"line":274,"address":[1453348,1453465],"length":1,"stats":{"Line":0}},{"line":275,"address":[1453506,1453441],"length":1,"stats":{"Line":0}},{"line":278,"address":[1453514],"length":1,"stats":{"Line":0}},{"line":279,"address":[1453584],"length":1,"stats":{"Line":0}},{"line":282,"address":[1453624,1454801,1453563,1453724,1453742],"length":1,"stats":{"Line":0}},{"line":285,"address":[1453616,1453732],"length":1,"stats":{"Line":0}},{"line":286,"address":[1453717,1453779],"length":1,"stats":{"Line":0}},{"line":287,"address":[1454005,1453959,1453825],"length":1,"stats":{"Line":0}},{"line":288,"address":[1454077],"length":1,"stats":{"Line":0}},{"line":290,"address":[1454413],"length":1,"stats":{"Line":0}},{"line":291,"address":[1454518,1454454],"length":1,"stats":{"Line":0}},{"line":296,"address":[1454092],"length":1,"stats":{"Line":0}},{"line":297,"address":[1454136],"length":1,"stats":{"Line":0}},{"line":298,"address":[1454157],"length":1,"stats":{"Line":0}},{"line":301,"address":[1430269,1430256],"length":1,"stats":{"Line":0}},{"line":303,"address":[1454318,1454264],"length":1,"stats":{"Line":0}},{"line":306,"address":[1454287],"length":1,"stats":{"Line":0}},{"line":309,"address":[1454864,1455660],"length":1,"stats":{"Line":0}},{"line":310,"address":[1454916],"length":1,"stats":{"Line":0}},{"line":311,"address":[1454971],"length":1,"stats":{"Line":0}},{"line":313,"address":[1454990],"length":1,"stats":{"Line":0}},{"line":314,"address":[1455012],"length":1,"stats":{"Line":0}},{"line":315,"address":[1455027,1455081],"length":1,"stats":{"Line":0}},{"line":317,"address":[1455452,1455062,1455261,1455220,1455166],"length":1,"stats":{"Line":0}},{"line":321,"address":[1455183,1455227],"length":1,"stats":{"Line":0}},{"line":323,"address":[1455473],"length":1,"stats":{"Line":0}},{"line":324,"address":[1455551],"length":1,"stats":{"Line":0}},{"line":325,"address":[1455604],"length":1,"stats":{"Line":0}},{"line":329,"address":[1455404],"length":1,"stats":{"Line":0}},{"line":332,"address":[1455696],"length":1,"stats":{"Line":1}},{"line":333,"address":[1455756],"length":1,"stats":{"Line":1}},{"line":335,"address":[1430339,1430417,1430304,1430400],"length":1,"stats":{"Line":4}},{"line":338,"address":[1455808],"length":1,"stats":{"Line":1}},{"line":339,"address":[1455875],"length":1,"stats":{"Line":1}},{"line":340,"address":[1455937],"length":1,"stats":{"Line":1}},{"line":341,"address":[1456003],"length":1,"stats":{"Line":1}},{"line":342,"address":[1455988],"length":1,"stats":{"Line":0}},{"line":344,"address":[1456024],"length":1,"stats":{"Line":1}},{"line":345,"address":[1456154,1456039,1456074],"length":1,"stats":{"Line":2}},{"line":346,"address":[1456175,1456088],"length":1,"stats":{"Line":2}},{"line":349,"address":[1456136,1456240],"length":1,"stats":{"Line":1}},{"line":354,"address":[1456256,1457995,1457942],"length":1,"stats":{"Line":1}},{"line":355,"address":[1456286,1456583],"length":1,"stats":{"Line":2}},{"line":356,"address":[1456602],"length":1,"stats":{"Line":1}},{"line":358,"address":[1456493,1456632,1456450,1456744,1456826],"length":1,"stats":{"Line":5}},{"line":359,"address":[1430457,1430448],"length":1,"stats":{"Line":2}},{"line":360,"address":[1456485,1456730],"length":1,"stats":{"Line":2}},{"line":362,"address":[1456918],"length":1,"stats":{"Line":1}},{"line":364,"address":[1457158],"length":1,"stats":{"Line":1}},{"line":365,"address":[1457208],"length":1,"stats":{"Line":1}},{"line":368,"address":[1457728,1457491,1457840,1457401],"length":1,"stats":{"Line":4}},{"line":369,"address":[1457451,1457526],"length":1,"stats":{"Line":2}},{"line":371,"address":[1457534,1457606],"length":1,"stats":{"Line":2}},{"line":372,"address":[1457614],"length":1,"stats":{"Line":1}},{"line":373,"address":[1457649],"length":1,"stats":{"Line":1}},{"line":378,"address":[1458955,1458986,1458032],"length":1,"stats":{"Line":2}},{"line":383,"address":[1458067,1458167],"length":1,"stats":{"Line":2}},{"line":384,"address":[1458197],"length":1,"stats":{"Line":1}},{"line":386,"address":[1458173,1458232],"length":1,"stats":{"Line":2}},{"line":387,"address":[1458486],"length":1,"stats":{"Line":1}},{"line":389,"address":[1458631],"length":1,"stats":{"Line":1}},{"line":391,"address":[1458713],"length":1,"stats":{"Line":1}},{"line":394,"address":[1458938],"length":1,"stats":{"Line":1}},{"line":399,"address":[1459024],"length":1,"stats":{"Line":0}},{"line":400,"address":[1459032],"length":1,"stats":{"Line":0}}],"covered":82,"coverable":177},{"path":["/","code","contracts","auth-onsocial","src","state_versions.rs"],"content":"use crate::types::KeyInfo;\nuse near_sdk::borsh::{BorshDeserialize, BorshSerialize};\nuse near_sdk::store::{IterableSet, LookupMap, Vector};\nuse near_sdk::AccountId;\n\n#[derive(BorshSerialize, BorshDeserialize)]\n#[borsh(crate = \"near_sdk::borsh\")]\npub struct StateV010 {\n    pub version: String,\n    pub keys: LookupMap\u003cAccountId, IterableSet\u003cKeyInfo\u003e\u003e,\n    pub last_active_timestamps: LookupMap\u003cAccountId, u64\u003e,\n    pub registered_accounts: Vector\u003cAccountId\u003e,\n    pub manager: AccountId,\n}\n\n#[derive(BorshSerialize, BorshDeserialize)]\n#[borsh(crate = \"near_sdk::borsh\")]\npub struct StateV011 {\n    pub version: String,\n    pub keys: LookupMap\u003cAccountId, IterableSet\u003cKeyInfo\u003e\u003e,\n    pub last_active_timestamps: LookupMap\u003cAccountId, u64\u003e,\n    pub registered_accounts: Vector\u003cAccountId\u003e,\n    pub manager: AccountId,\n    pub max_keys_per_account: u32,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","code","contracts","auth-onsocial","src","tests.rs"],"content":"#[cfg(test)]\nmod tests {\n    use crate::{\n        errors::AuthError,\n        state::AuthContractState,\n        state_versions::{StateV010, StateV011},\n        types::{KeyInfo, RotateKeyArgs},\n        AuthContract,\n    };\n    use near_sdk::borsh;\n    use near_sdk::store::{IterableSet, LookupMap, Vector};\n    use near_sdk::test_utils::{accounts, get_logs, VMContextBuilder};\n    use near_sdk::{env, testing_env, AccountId, PublicKey};\n\n    fn setup_context(predecessor: \u0026AccountId) -\u003e VMContextBuilder {\n        let mut context = VMContextBuilder::new();\n        context\n            .predecessor_account_id(predecessor.clone())\n            .current_account_id(\"auth.testnet\".parse().unwrap())\n            .block_timestamp(1_000_000_000_000);\n        context\n    }\n\n    fn setup_contract() -\u003e AuthContractState {\n        let context = setup_context(\u0026accounts(0));\n        testing_env!(context.build());\n        AuthContractState::new()\n    }\n\n    #[test]\n    fn test_register_and_get_keys() {\n        let mut state = setup_contract();\n        let account_id = accounts(0);\n        let pk1: PublicKey = \"ed25519:6E8sCci9badyRkbrr2TV5CC3oKTo7Znny8mG5k415kZU\"\n            .parse()\n            .unwrap();\n        let pk2: PublicKey = \"ed25519:4jS5V2kAWg7fW7V5F8mD8Z5Y3mJ5gG5kAW7fW7V5F8mD\"\n            .parse()\n            .unwrap();\n\n        state\n            .register_key(\u0026account_id, \u0026account_id, pk1.clone(), None, false, None)\n            .unwrap();\n        state\n            .register_key(\u0026account_id, \u0026account_id, pk2.clone(), None, false, None)\n            .unwrap();\n\n        let keys = state.get_keys(\u0026account_id, 1, 0);\n        assert_eq!(keys.len(), 1, \"Should return 1 key\");\n\n        let keys = state.get_keys(\u0026account_id, 2, 1);\n        assert_eq!(keys.len(), 1, \"Should return 1 key\");\n\n        let keys = state.get_keys(\u0026account_id, 10, 0);\n        assert_eq!(keys.len(), 2, \"Should return all 2 keys\");\n\n        let key_info = state.get_key_info(\u0026account_id, \u0026pk1).unwrap();\n        assert_eq!(key_info.public_key, pk1, \"Key info should match\");\n    }\n\n    #[test]\n    fn test_rotate_key() {\n        let mut state = setup_contract();\n        let account_id = accounts(0);\n        let old_pk: PublicKey = \"ed25519:6E8sCci9badyRkbrr2TV5CC3oKTo7Znny8mG5k415kZU\"\n            .parse()\n            .unwrap();\n        let new_pk: PublicKey = \"ed25519:4jS5V2kAWg7fW7V5F8mD8Z5Y3mJ5gG5kAW7fW7V5F8mD\"\n            .parse()\n            .unwrap();\n\n        state\n            .register_key(\n                \u0026account_id,\n                \u0026account_id,\n                old_pk.clone(),\n                Some(30),\n                true,\n                Some(2),\n            )\n            .unwrap();\n\n        state\n            .rotate_key(\n                \u0026account_id,\n                RotateKeyArgs {\n                    account_id: account_id.clone(),\n                    old_public_key: old_pk.clone(),\n                    new_public_key: new_pk.clone(),\n                    expiration_days: Some(60),\n                    is_multi_sig: false,\n                    multi_sig_threshold: None,\n                },\n            )\n            .unwrap();\n\n        assert!(\n            state.get_key_info(\u0026account_id, \u0026old_pk).is_none(),\n            \"Old key should be removed\"\n        );\n        let new_key_info = state.get_key_info(\u0026account_id, \u0026new_pk).unwrap();\n        assert_eq!(new_key_info.public_key, new_pk, \"New key should match\");\n        assert!(\n            new_key_info.expiration_timestamp.is_some(),\n            \"Expiration should be set\"\n        );\n        assert_eq!(\n            new_key_info.is_multi_sig, false,\n            \"Multi-sig should be false\"\n        );\n        assert_eq!(\n            new_key_info.multi_sig_threshold, None,\n            \"Threshold should be None\"\n        );\n    }\n\n    #[test]\n    fn test_rotate_key_unauthorized() {\n        let mut state = setup_contract();\n        let account_id = accounts(0);\n        let caller = accounts(1);\n        let old_pk: PublicKey = \"ed25519:6E8sCci9badyRkbrr2TV5CC3oKTo7Znny8mG5k415kZU\"\n            .parse()\n            .unwrap();\n        let new_pk: PublicKey = \"ed25519:4jS5V2kAWg7fW7V5F8mD8Z5Y3mJ5gG5kAW7fW7V5F8mD\"\n            .parse()\n            .unwrap();\n\n        state\n            .register_key(\u0026account_id, \u0026account_id, old_pk.clone(), None, false, None)\n            .unwrap();\n\n        let result = state.rotate_key(\n            \u0026caller,\n            RotateKeyArgs {\n                account_id: account_id.clone(),\n                old_public_key: old_pk,\n                new_public_key: new_pk,\n                expiration_days: None,\n                is_multi_sig: false,\n                multi_sig_threshold: None,\n            },\n        );\n        assert_eq!(result, Err(AuthError::Unauthorized));\n    }\n\n    #[test]\n    fn test_rotate_key_not_found() {\n        let mut state = setup_contract();\n        let account_id = accounts(0);\n        let old_pk: PublicKey = \"ed25519:6E8sCci9badyRkbrr2TV5CC3oKTo7Znny8mG5k415kZU\"\n            .parse()\n            .unwrap();\n        let new_pk: PublicKey = \"ed25519:4jS5V2kAWg7fW7V5F8mD8Z5Y3mJ5gG5kAW7fW7V5F8mD\"\n            .parse()\n            .unwrap();\n\n        let result = state.rotate_key(\n            \u0026account_id,\n            RotateKeyArgs {\n                account_id: account_id.clone(),\n                old_public_key: old_pk,\n                new_public_key: new_pk,\n                expiration_days: None,\n                is_multi_sig: false,\n                multi_sig_threshold: None,\n            },\n        );\n        assert_eq!(result, Err(AuthError::KeyNotFound));\n    }\n\n    #[test]\n    fn test_update_contract_no_input() {\n        let mut state = setup_contract();\n        let manager = accounts(0);\n        let context = setup_context(\u0026manager);\n        testing_env!(context.build());\n        let result = state.update_contract();\n        match result {\n            Err(AuthError::MissingInput) =\u003e (), // Expected error\n            Err(_e) =\u003e panic!(\"Expected MissingInput error, got different error\"),\n            Ok(_) =\u003e panic!(\"Expected MissingInput error, got Ok\"),\n        }\n    }\n\n    #[test]\n    fn test_update_contract_unauthorized() {\n        let mut state = setup_contract();\n        let non_manager = accounts(1);\n        let context = setup_context(\u0026non_manager);\n        let mut vm_context = context.build();\n        vm_context.input = vec![1, 2, 3];\n        testing_env!(vm_context);\n        let result = state.update_contract();\n        match result {\n            Err(AuthError::Unauthorized) =\u003e (), // Expected error\n            Err(_e) =\u003e panic!(\"Expected Unauthorized error, got different error\"),\n            Ok(_) =\u003e panic!(\"Expected Unauthorized error, got Ok\"),\n        }\n    }\n\n    #[test]\n    fn test_update_contract_authorized() {\n        let mut state = setup_contract();\n        let manager = accounts(0);\n        let context = setup_context(\u0026manager);\n        let mut vm_context = context.build();\n        vm_context.input = vec![1, 2, 3];\n        testing_env!(vm_context);\n        let result = state.update_contract();\n        assert!(result.is_ok(), \"Expected successful contract update\");\n    }\n\n    #[test]\n    fn test_set_manager_authorized() {\n        let mut state = setup_contract();\n        let manager = accounts(0);\n        let new_manager = accounts(1);\n        let context = setup_context(\u0026manager);\n        testing_env!(context.build());\n        let result = state.set_manager(\u0026manager, new_manager.clone());\n        assert!(result.is_ok());\n        assert_eq!(state.manager, new_manager);\n    }\n\n    #[test]\n    fn test_set_manager_unauthorized() {\n        let mut state = setup_contract();\n        let non_manager = accounts(1);\n        let new_manager = accounts(2);\n        let context = setup_context(\u0026non_manager);\n        testing_env!(context.build());\n        let result = state.set_manager(\u0026non_manager, new_manager);\n        assert_eq!(result, Err(AuthError::Unauthorized));\n    }\n\n    #[test]\n    fn test_migration_from_010_to_011() {\n        let manager = accounts(0);\n        let account_id = accounts(1);\n        let pk: PublicKey = \"ed25519:6E8sCci9badyRkbrr2TV5CC3oKTo7Znny8mG5k415kZU\"\n            .parse()\n            .unwrap();\n        let context = setup_context(\u0026manager);\n        testing_env!(context.build());\n\n        let mut state_v010 = StateV010 {\n            version: \"0.1.0\".to_string(),\n            keys: LookupMap::new(b\"k\".to_vec()),\n            last_active_timestamps: LookupMap::new(b\"t\".to_vec()),\n            registered_accounts: Vector::new(b\"a\".to_vec()),\n            manager: manager.clone(),\n        };\n        let mut key_set = IterableSet::new(b\"s\".to_vec());\n        key_set.insert(KeyInfo {\n            public_key: pk.clone(),\n            expiration_timestamp: None,\n            is_multi_sig: false,\n            multi_sig_threshold: None,\n        });\n        key_set.flush();\n        state_v010.keys.insert(account_id.clone(), key_set);\n        state_v010.keys.flush();\n        state_v010.registered_accounts.push(account_id.clone());\n        state_v010.registered_accounts.flush();\n        state_v010\n            .last_active_timestamps\n            .insert(account_id.clone(), 0);\n        let state_bytes = borsh::to_vec(\u0026state_v010).expect(\"Failed to serialize state\");\n        env::state_write(\u0026state_bytes);\n\n        let new_contract = AuthContract::migrate();\n\n        assert_eq!(\n            new_contract.state.version, \"0.1.1\",\n            \"Version should be 0.1.1\"\n        );\n        assert_eq!(\n            new_contract.state.manager, manager,\n            \"Manager should be preserved\"\n        );\n        assert_eq!(\n            new_contract.state.registered_accounts.len(),\n            1,\n            \"Accounts should be preserved\"\n        );\n        assert_eq!(\n            new_contract.state.max_keys_per_account, 100,\n            \"Max keys should be initialized\"\n        );\n        let keys = new_contract.state.get_keys(\u0026account_id, 10, 0);\n        assert_eq!(keys.len(), 1, \"Should have one key\");\n        assert_eq!(keys[0].public_key, pk, \"Key should match\");\n\n        let logs = get_logs();\n        assert!(\n            logs.contains(\u0026\"Migrating from state version 0.1.0\".to_string()),\n            \"Expected migration log\"\n        );\n        assert!(logs.contains(\u0026\"EVENT_JSON:{\\\"standard\\\":\\\"nep297\\\",\\\"version\\\":\\\"1.0.0\\\",\\\"event\\\":\\\"state_migrated\\\",\\\"data\\\":{\\\"old_version\\\":\\\"0.1.0\\\",\\\"new_version\\\":\\\"0.1.1\\\"}}\".to_string()), \"Expected state_migrated event\");\n    }\n\n    #[test]\n    fn test_migration_from_011_to_011() {\n        let manager = accounts(0);\n        let account_id = accounts(1);\n        let pk: PublicKey = \"ed25519:6E8sCci9badyRkbrr2TV5CC3oKTo7Znny8mG5k415kZU\"\n            .parse()\n            .unwrap();\n        let context = setup_context(\u0026manager);\n        testing_env!(context.build());\n\n        let mut state_v011 = StateV011 {\n            version: \"0.1.1\".to_string(),\n            keys: LookupMap::new(b\"k\".to_vec()),\n            last_active_timestamps: LookupMap::new(b\"t\".to_vec()),\n            registered_accounts: Vector::new(b\"a\".to_vec()),\n            manager: manager.clone(),\n            max_keys_per_account: 50,\n        };\n        let mut key_set = IterableSet::new(b\"s\".to_vec());\n        key_set.insert(KeyInfo {\n            public_key: pk.clone(),\n            expiration_timestamp: None,\n            is_multi_sig: false,\n            multi_sig_threshold: None,\n        });\n        key_set.flush();\n        state_v011.keys.insert(account_id.clone(), key_set);\n        state_v011.keys.flush();\n        state_v011.registered_accounts.push(account_id.clone());\n        state_v011.registered_accounts.flush();\n        state_v011\n            .last_active_timestamps\n            .insert(account_id.clone(), 0);\n        let state_bytes = borsh::to_vec(\u0026state_v011).expect(\"Failed to serialize state\");\n        env::state_write(\u0026state_bytes);\n\n        let new_contract = AuthContract::migrate();\n\n        assert_eq!(\n            new_contract.state.version, \"0.1.1\",\n            \"Version should be 0.1.1\"\n        );\n        assert_eq!(\n            new_contract.state.manager, manager,\n            \"Manager should be preserved\"\n        );\n        assert_eq!(\n            new_contract.state.registered_accounts.len(),\n            1,\n            \"Accounts should be preserved\"\n        );\n        assert_eq!(\n            new_contract.state.max_keys_per_account, 50,\n            \"Max keys should be preserved\"\n        );\n        let keys = new_contract.state.get_keys(\u0026account_id, 10, 0);\n        assert_eq!(keys.len(), 1, \"Should have one key\");\n        assert_eq!(keys[0].public_key, pk, \"Key should match\");\n\n        let logs = get_logs();\n        assert!(\n            logs.contains(\u0026\"State is already at latest version\".to_string()),\n            \"Expected latest version log\"\n        );\n    }\n\n    #[test]\n    fn test_migration_no_prior_state() {\n        let manager = accounts(0);\n        let context = setup_context(\u0026manager);\n        testing_env!(context.build());\n\n        let new_contract = AuthContract::migrate();\n\n        assert_eq!(\n            new_contract.state.version, \"0.1.1\",\n            \"Version should be 0.1.1\"\n        );\n        assert_eq!(\n            new_contract.state.manager, manager,\n            \"Manager should be current account\"\n        );\n        assert_eq!(\n            new_contract.state.registered_accounts.len(),\n            0,\n            \"No accounts should exist\"\n        );\n        assert_eq!(\n            new_contract.state.max_keys_per_account, 100,\n            \"Max keys should be initialized\"\n        );\n\n        let logs = get_logs();\n        assert!(\n            logs.contains(\u0026\"No valid prior state found, initializing new state\".to_string()),\n            \"Expected no prior state log\"\n        );\n    }\n\n    #[test]\n    fn test_migration_corrupted_state() {\n        let manager = accounts(0);\n        let context = setup_context(\u0026manager);\n        testing_env!(context.build());\n\n        env::state_write(\u0026vec![0u8; 10]);\n\n        let new_contract = AuthContract::migrate();\n\n        assert_eq!(\n            new_contract.state.version, \"0.1.1\",\n            \"Version should be 0.1.1\"\n        );\n        assert_eq!(\n            new_contract.state.manager, manager,\n            \"Manager should be current account\"\n        );\n        assert_eq!(\n            new_contract.state.registered_accounts.len(),\n            0,\n            \"No accounts should exist\"\n        );\n        assert_eq!(\n            new_contract.state.max_keys_per_account, 100,\n            \"Max keys should be initialized\"\n        );\n\n        let logs = get_logs();\n        assert!(\n            logs.contains(\u0026\"No valid prior state found, initializing new state\".to_string()),\n            \"Expected no prior state log\"\n        );\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","code","contracts","auth-onsocial","src","types.rs"],"content":"use near_sdk::borsh::{BorshDeserialize, BorshSerialize};\nuse near_sdk::serde::{Deserialize, Serialize};\nuse near_sdk::AccountId;\nuse near_sdk::PublicKey;\nuse near_sdk_macros::NearSchema;\nuse std::cmp::Ordering;\n\n#[derive(Clone, Serialize, Deserialize, BorshSerialize, BorshDeserialize, NearSchema)]\n#[serde(crate = \"near_sdk::serde\")]\n#[borsh(crate = \"near_sdk::borsh\")]\n#[abi(json, borsh)]\npub struct KeyInfo {\n    pub public_key: PublicKey,\n    pub expiration_timestamp: Option\u003cu64\u003e,\n    pub is_multi_sig: bool,\n    pub multi_sig_threshold: Option\u003cu32\u003e,\n}\n\n#[derive(Clone, Serialize, Deserialize, BorshSerialize, BorshDeserialize, NearSchema)]\n#[serde(crate = \"near_sdk::serde\")]\n#[borsh(crate = \"near_sdk::borsh\")]\n#[abi(json, borsh)]\npub struct RotateKeyArgs {\n    pub account_id: AccountId,\n    pub old_public_key: PublicKey,\n    pub new_public_key: PublicKey,\n    pub expiration_days: Option\u003cu32\u003e,\n    pub is_multi_sig: bool,\n    pub multi_sig_threshold: Option\u003cu32\u003e,\n}\n\nimpl PartialEq for KeyInfo {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        self.public_key == other.public_key\n    }\n}\n\nimpl Eq for KeyInfo {}\n\nimpl std::hash::Hash for KeyInfo {\n    fn hash\u003cH: std::hash::Hasher\u003e(\u0026self, state: \u0026mut H) {\n        self.public_key.hash(state);\n    }\n}\n\nimpl PartialOrd for KeyInfo {\n    fn partial_cmp(\u0026self, other: \u0026Self) -\u003e Option\u003cOrdering\u003e {\n        Some(self.public_key.cmp(\u0026other.public_key))\n    }\n}\n\nimpl Ord for KeyInfo {\n    fn cmp(\u0026self, other: \u0026Self) -\u003e Ordering {\n        self.public_key.cmp(\u0026other.public_key)\n    }\n}\n","traces":[{"line":33,"address":[1473040],"length":1,"stats":{"Line":0}},{"line":34,"address":[1473054],"length":1,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[1473088],"length":1,"stats":{"Line":0}},{"line":48,"address":[1473102],"length":1,"stats":{"Line":0}},{"line":53,"address":[1473136],"length":1,"stats":{"Line":2}},{"line":54,"address":[1473150],"length":1,"stats":{"Line":1}}],"covered":2,"coverable":8},{"path":["/","code","contracts","ft-wrapper-onsocial","src","admin.rs"],"content":"use crate::errors::FtWrapperError;\nuse crate::events::FtWrapperEvent;\nuse crate::state::FtWrapperContractState;\nuse near_sdk::json_types::U128;\nuse near_sdk::{env, AccountId};\n\npub fn add_supported_token(\n    state: \u0026mut FtWrapperContractState,\n    token: AccountId,\n) -\u003e Result\u003c(), FtWrapperError\u003e {\n    let caller = env::predecessor_account_id();\n    if !state.is_manager(\u0026caller) {\n        return Err(FtWrapperError::Unauthorized);\n    }\n    if state.supported_tokens.contains(\u0026token) {\n        return Err(FtWrapperError::TokenNotSupported); // Token already exists\n    }\n    state.supported_tokens.push(token.clone());\n    FtWrapperEvent::TokenAdded { token }.emit();\n    Ok(())\n}\n\npub fn remove_supported_token(\n    state: \u0026mut FtWrapperContractState,\n    token: AccountId,\n) -\u003e Result\u003c(), FtWrapperError\u003e {\n    let caller = env::predecessor_account_id();\n    if !state.is_manager(\u0026caller) {\n        return Err(FtWrapperError::Unauthorized);\n    }\n    if let Some(index) = state.supported_tokens.iter().position(|t| t == \u0026token) {\n        state.supported_tokens.remove(index);\n        FtWrapperEvent::TokenRemoved { token }.emit();\n        Ok(())\n    } else {\n        Err(FtWrapperError::TokenNotSupported)\n    }\n}\n\npub fn set_cross_contract_gas(\n    state: \u0026mut FtWrapperContractState,\n    gas_tgas: u64,\n) -\u003e Result\u003c(), FtWrapperError\u003e {\n    let caller = env::predecessor_account_id();\n    if !state.is_manager(\u0026caller) {\n        return Err(FtWrapperError::Unauthorized);\n    }\n    state.cross_contract_gas = gas_tgas * 1_000_000_000_000; // Convert TGas to Gas\n    FtWrapperEvent::GasUpdated { gas_tgas }.emit();\n    Ok(())\n}\n\npub fn set_storage_deposit(\n    state: \u0026mut FtWrapperContractState,\n    storage_deposit: U128,\n) -\u003e Result\u003c(), FtWrapperError\u003e {\n    let caller = env::predecessor_account_id();\n    if !state.is_manager(\u0026caller) {\n        return Err(FtWrapperError::Unauthorized);\n    }\n    if storage_deposit.0 \u003c 1_250_000_000_000_000_000_000 {\n        // Minimum 0.00125 NEAR\n        return Err(FtWrapperError::AmountTooLow);\n    }\n    state.storage_deposit = storage_deposit;\n    FtWrapperEvent::StorageDepositUpdated { storage_deposit }.emit();\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","code","contracts","ft-wrapper-onsocial","src","errors.rs"],"content":"use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};\nuse near_sdk::FunctionError;\nuse near_sdk_macros::NearSchema;\n\n#[derive(Debug, NearSchema, BorshSerialize, BorshDeserialize)]\n#[abi(borsh)]\npub enum FtWrapperError {\n    TokenNotSupported,\n    AmountTooLow,\n    InvalidDeposit,\n    AccountNotRegistered,\n    InsufficientStorageBalance,\n    NonZeroBalance,\n    Unauthorized,\n    LowBalance,\n}\n\nimpl FunctionError for FtWrapperError {\n    fn panic(\u0026self) -\u003e ! {\n        panic!(\n            \"{}\",\n            match self {\n                FtWrapperError::TokenNotSupported =\u003e \"Token not supported\",\n                FtWrapperError::AmountTooLow =\u003e \"Amount too low\",\n                FtWrapperError::InvalidDeposit =\u003e \"Invalid deposit amount\",\n                FtWrapperError::AccountNotRegistered =\u003e \"Account not registered\",\n                FtWrapperError::InsufficientStorageBalance =\u003e \"Insufficient storage balance\",\n                FtWrapperError::NonZeroBalance =\u003e \"Non-zero token balance\",\n                FtWrapperError::Unauthorized =\u003e \"Unauthorized access\",\n                FtWrapperError::LowBalance =\u003e \"Contract balance too low\",\n            }\n        )\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","code","contracts","ft-wrapper-onsocial","src","events.rs"],"content":"use near_sdk::json_types::U128;\nuse near_sdk::{near, AccountId};\n\n#[near(event_json(standard = \"nep297\"))]\npub enum FtWrapperEvent {\n    #[event_version(\"1.0.0\")]\n    TokenAdded { token: AccountId },\n    #[event_version(\"1.0.0\")]\n    TokenRemoved { token: AccountId },\n    #[event_version(\"1.0.0\")]\n    FtTransfer {\n        token: AccountId,\n        sender: AccountId,\n        receiver: AccountId,\n        amount: U128,\n    },\n    #[event_version(\"1.0.0\")]\n    StorageDeposited {\n        token: AccountId,\n        account_id: AccountId,\n        amount: U128,\n    },\n    #[event_version(\"1.0.0\")]\n    StorageWithdrawn {\n        token: AccountId,\n        account_id: AccountId,\n        amount: U128,\n    },\n    #[event_version(\"1.0.0\")]\n    StorageUnregistered {\n        token: AccountId,\n        account_id: AccountId,\n    },\n    #[event_version(\"1.0.0\")]\n    GasUpdated { gas_tgas: u64 },\n    #[event_version(\"1.0.0\")]\n    LowBalance { balance: u128 },\n    #[event_version(\"1.0.0\")]\n    StorageDepositUpdated { storage_deposit: U128 },\n    #[event_version(\"1.0.0\")]\n    ContractUpgraded { manager: AccountId, timestamp: u64 },\n    #[event_version(\"1.0.0\")]\n    ManagerUpdated { new_manager: AccountId },\n    #[event_version(\"1.0.0\")]\n    StateMigrated {\n        old_version: String,\n        new_version: String,\n    },\n    #[event_version(\"1.0.0\")]\n    TransferFinalized {\n        token: AccountId,\n        recipient: AccountId,\n        amount: U128,\n        fee: U128,\n        source_chain: String,\n    },\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","code","contracts","ft-wrapper-onsocial","src","ft.rs"],"content":"use crate::errors::FtWrapperError;\nuse crate::events::FtWrapperEvent;\nuse crate::state::FtWrapperContractState;\nuse crate::types::{\n    BridgeTransferArgs, FinalizeTransferArgs, FtTransferArgs, RequestChainSignatureArgs,\n    StorageBalance,\n};\nuse crate::{ext_ft, ext_self};\nuse near_sdk::json_types::U128;\nuse near_sdk::{env, AccountId, Gas, NearToken, Promise};\n\npub fn ft_transfer(\n    state: \u0026mut FtWrapperContractState,\n    args: FtTransferArgs,\n) -\u003e Result\u003cPromise, FtWrapperError\u003e {\n    state.assert_balance()?;\n    if !state.supported_tokens.contains(\u0026args.token) {\n        return Err(FtWrapperError::TokenNotSupported);\n    }\n    if args.amount.0 == 0 {\n        return Err(FtWrapperError::AmountTooLow);\n    }\n\n    let sender_id = env::predecessor_account_id();\n\n    let sender_promise = ensure_registered(state, args.token.clone(), sender_id.clone())?;\n    let receiver_promise = ensure_registered(state, args.token.clone(), args.receiver_id.clone())?;\n\n    let transfer_promise = ext_ft::ext(args.token.clone())\n        .with_static_gas(Gas::from_tgas(state.cross_contract_gas))\n        .ft_transfer(args.receiver_id.clone(), args.amount, args.memo.clone());\n\n    FtWrapperEvent::FtTransfer {\n        token: args.token,\n        sender: sender_id,\n        receiver: args.receiver_id,\n        amount: args.amount,\n    }\n    .emit();\n\n    Ok(sender_promise.and(receiver_promise).then(transfer_promise))\n}\n\npub fn ensure_registered(\n    state: \u0026mut FtWrapperContractState,\n    token: AccountId,\n    account_id: AccountId,\n) -\u003e Result\u003cPromise, FtWrapperError\u003e {\n    state.assert_balance()?;\n    if !state.supported_tokens.contains(\u0026token) {\n        return Err(FtWrapperError::TokenNotSupported);\n    }\n\n    let storage_balance = state\n        .storage_balances\n        .get(\u0026(token.clone(), account_id.clone()));\n\n    if storage_balance.is_some() {\n        Ok(Promise::new(env::current_account_id()))\n    } else {\n        let deposit_amount = state.storage_deposit.0;\n        let contract_balance = env::account_balance().as_yoctonear();\n        if contract_balance \u003c deposit_amount {\n            FtWrapperEvent::LowBalance {\n                balance: contract_balance,\n            }\n            .emit();\n            return Err(FtWrapperError::LowBalance);\n        }\n        let deposit_promise = ext_ft::ext(token.clone())\n            .with_static_gas(Gas::from_tgas(state.cross_contract_gas))\n            .with_attached_deposit(NearToken::from_yoctonear(deposit_amount))\n            .storage_deposit(Some(account_id.clone()), Some(true))\n            .then(\n                ext_self::ext(env::current_account_id())\n                    .with_static_gas(Gas::from_tgas(state.cross_contract_gas))\n                    .handle_storage_deposit(token.clone(), account_id.clone()),\n            );\n\n        FtWrapperEvent::StorageDeposited {\n            token: token.clone(),\n            account_id: account_id.clone(),\n            amount: U128(deposit_amount),\n        }\n        .emit();\n\n        Ok(deposit_promise)\n    }\n}\n\npub fn ft_balance_of(\n    state: \u0026FtWrapperContractState,\n    token: AccountId,\n    account_id: AccountId,\n) -\u003e Promise {\n    if !state.supported_tokens.contains(\u0026token) {\n        env::panic_str(\"Token not supported\");\n    }\n    ext_ft::ext(token)\n        .with_static_gas(Gas::from_tgas(state.cross_contract_gas))\n        .ft_balance_of(account_id)\n}\n\npub fn storage_deposit(\n    state: \u0026mut FtWrapperContractState,\n    token: AccountId,\n    account_id: Option\u003cAccountId\u003e,\n    registration_only: Option\u003cbool\u003e,\n) -\u003e Result\u003cStorageBalance, FtWrapperError\u003e {\n    state.assert_balance()?;\n    if !state.supported_tokens.contains(\u0026token) {\n        return Err(FtWrapperError::TokenNotSupported);\n    }\n\n    let account_id = account_id.unwrap_or_else(|| env::predecessor_account_id());\n    let registration_only = registration_only.unwrap_or(false);\n\n    let storage_balance = state\n        .storage_balances\n        .get(\u0026(token.clone(), account_id.clone()));\n\n    if let Some(balance) = storage_balance {\n        return Ok(balance.clone());\n    }\n\n    let deposit_amount = state.storage_deposit.0;\n    let contract_balance = env::account_balance().as_yoctonear();\n    if contract_balance \u003c deposit_amount {\n        FtWrapperEvent::LowBalance {\n            balance: contract_balance,\n        }\n        .emit();\n        return Err(FtWrapperError::LowBalance);\n    }\n\n    let deposit_promise = ext_ft::ext(token.clone())\n        .with_static_gas(Gas::from_tgas(state.cross_contract_gas))\n        .with_attached_deposit(NearToken::from_yoctonear(deposit_amount))\n        .storage_deposit(Some(account_id.clone()), Some(registration_only))\n        .then(\n            ext_self::ext(env::current_account_id())\n                .with_static_gas(Gas::from_tgas(state.cross_contract_gas))\n                .handle_storage_deposit(token.clone(), account_id.clone()),\n        );\n\n    state.storage_balances.insert(\n        (token.clone(), account_id.clone()),\n        StorageBalance {\n            total: U128(deposit_amount),\n            available: U128(0),\n        },\n    );\n\n    FtWrapperEvent::StorageDeposited {\n        token,\n        account_id,\n        amount: U128(deposit_amount),\n    }\n    .emit();\n\n    deposit_promise.then(Promise::new(env::current_account_id()));\n\n    Ok(StorageBalance {\n        total: U128(deposit_amount),\n        available: U128(0),\n    })\n}\n\npub fn storage_withdraw(\n    state: \u0026mut FtWrapperContractState,\n    token: AccountId,\n    amount: Option\u003cU128\u003e,\n) -\u003e Result\u003cStorageBalance, FtWrapperError\u003e {\n    if !state.supported_tokens.contains(\u0026token) {\n        return Err(FtWrapperError::TokenNotSupported);\n    }\n\n    let account_id = env::predecessor_account_id();\n\n    let storage_balance = state\n        .storage_balances\n        .get(\u0026(token.clone(), account_id.clone()))\n        .ok_or(FtWrapperError::AccountNotRegistered)?;\n\n    let available = storage_balance.available.0;\n    let withdraw_amount = amount.map(|a| a.0).unwrap_or(available);\n\n    if withdraw_amount \u003e available {\n        return Err(FtWrapperError::InsufficientStorageBalance);\n    }\n\n    let new_balance = StorageBalance {\n        total: storage_balance.total,\n        available: U128(available - withdraw_amount),\n    };\n    state\n        .storage_balances\n        .insert((token.clone(), account_id.clone()), new_balance.clone());\n\n    if withdraw_amount \u003e 0 {\n        Promise::new(account_id.clone()).transfer(NearToken::from_yoctonear(withdraw_amount));\n    }\n\n    FtWrapperEvent::StorageWithdrawn {\n        token,\n        account_id,\n        amount: U128(withdraw_amount),\n    }\n    .emit();\n\n    Ok(new_balance)\n}\n\npub fn storage_balance_of(\n    state: \u0026FtWrapperContractState,\n    token: AccountId,\n    account_id: AccountId,\n) -\u003e Promise {\n    if !state.supported_tokens.contains(\u0026token) {\n        env::panic_str(\"Token not supported\");\n    }\n    ext_ft::ext(token)\n        .with_static_gas(Gas::from_tgas(state.cross_contract_gas))\n        .storage_balance_of(account_id)\n}\n\npub fn storage_balance_bounds(state: \u0026FtWrapperContractState, token: AccountId) -\u003e Promise {\n    if !state.supported_tokens.contains(\u0026token) {\n        env::panic_str(\"Token not supported\");\n    }\n    ext_ft::ext(token)\n        .with_static_gas(Gas::from_tgas(state.cross_contract_gas))\n        .storage_balance_bounds()\n}\n\npub fn storage_unregister(\n    state: \u0026mut FtWrapperContractState,\n    token: AccountId,\n    force: Option\u003cbool\u003e,\n) -\u003e Result\u003cbool, FtWrapperError\u003e {\n    if !state.supported_tokens.contains(\u0026token) {\n        return Err(FtWrapperError::TokenNotSupported);\n    }\n\n    let account_id = env::predecessor_account_id();\n\n    let storage_balance = state\n        .storage_balances\n        .get(\u0026(token.clone(), account_id.clone()));\n\n    if storage_balance.is_none() {\n        return Ok(false);\n    }\n\n    let force = force.unwrap_or(false);\n    let balance = storage_balance.unwrap();\n\n    if !force {\n        ext_ft::ext(token.clone())\n            .with_static_gas(Gas::from_tgas(state.cross_contract_gas))\n            .ft_balance_of(account_id.clone())\n            .then(\n                ext_self::ext(env::current_account_id())\n                    .with_static_gas(Gas::from_tgas(state.cross_contract_gas))\n                    .handle_balance_check(token.clone(), account_id.clone()),\n            );\n        return Ok(false);\n    }\n\n    if balance.total.0 \u003e 0 {\n        Promise::new(account_id.clone()).transfer(NearToken::from_yoctonear(balance.total.0));\n    }\n\n    state\n        .storage_balances\n        .remove(\u0026(token.clone(), account_id.clone()));\n\n    FtWrapperEvent::StorageUnregistered { token, account_id }.emit();\n\n    Ok(true)\n}\n\npub fn handle_balance_check(\n    state: \u0026mut FtWrapperContractState,\n    token: AccountId,\n    account_id: AccountId,\n    balance: U128,\n) -\u003e bool {\n    if balance.0 != 0 {\n        env::log_str(\"Non-zero balance detected, unregistration aborted\");\n        return false;\n    }\n\n    let storage_balance = state\n        .storage_balances\n        .get(\u0026(token.clone(), account_id.clone()));\n    if let Some(balance) = storage_balance {\n        if balance.total.0 \u003e 0 {\n            Promise::new(account_id.clone()).transfer(NearToken::from_yoctonear(balance.total.0));\n        }\n        state\n            .storage_balances\n            .remove(\u0026(token.clone(), account_id.clone()));\n        FtWrapperEvent::StorageUnregistered { token, account_id }.emit();\n        return true;\n    }\n\n    false\n}\n\npub fn handle_registration(\n    state: \u0026mut FtWrapperContractState,\n    token: AccountId,\n    account_id: AccountId,\n) -\u003e Promise {\n    let storage_balance = state\n        .storage_balances\n        .get(\u0026(token.clone(), account_id.clone()));\n    if storage_balance.is_none() {\n        let bounds_promise = ext_ft::ext(token.clone())\n            .with_static_gas(Gas::from_tgas(state.cross_contract_gas))\n            .storage_balance_bounds()\n            .then(\n                ext_self::ext(env::current_account_id())\n                    .with_static_gas(Gas::from_tgas(state.cross_contract_gas))\n                    .handle_storage_deposit(token.clone(), account_id.clone()),\n            );\n        bounds_promise\n    } else {\n        Promise::new(env::current_account_id())\n    }\n}\n\npub fn handle_storage_deposit(\n    state: \u0026mut FtWrapperContractState,\n    token: AccountId,\n    account_id: AccountId,\n) -\u003e Promise {\n    state\n        .assert_balance()\n        .unwrap_or_else(|_| env::panic_str(\"Low balance\"));\n    let deposit_amount = state.storage_deposit.0;\n    let deposit_promise = ext_ft::ext(token.clone())\n        .with_static_gas(Gas::from_tgas(state.cross_contract_gas))\n        .with_attached_deposit(NearToken::from_yoctonear(deposit_amount))\n        .storage_deposit(Some(account_id.clone()), Some(true));\n\n    FtWrapperEvent::StorageDeposited {\n        token,\n        account_id,\n        amount: U128(deposit_amount),\n    }\n    .emit();\n\n    deposit_promise\n}\n\npub fn request_chain_signature(\n    state: \u0026mut FtWrapperContractState,\n    args: RequestChainSignatureArgs,\n) -\u003e Result\u003cPromise, FtWrapperError\u003e {\n    state.assert_balance()?;\n    if !state.supported_tokens.contains(\u0026args.token) {\n        return Err(FtWrapperError::TokenNotSupported);\n    }\n    let sender_id = env::predecessor_account_id();\n    let promise = ensure_registered(state, args.token.clone(), sender_id)?;\n    Ok(\n        promise.then(Promise::new(state.relayer_contract.clone()).function_call(\n            \"relay_meta_transaction\".to_string(),\n            vec![],\n            NearToken::from_yoctonear(0),\n            Gas::from_tgas(state.cross_contract_gas),\n        )),\n    )\n}\n\npub fn bridge_transfer(\n    state: \u0026mut FtWrapperContractState,\n    args: BridgeTransferArgs,\n) -\u003e Result\u003cPromise, FtWrapperError\u003e {\n    state.assert_balance()?;\n    if !state.supported_tokens.contains(\u0026args.token) {\n        return Err(FtWrapperError::TokenNotSupported);\n    }\n    if args.amount.0 == 0 {\n        return Err(FtWrapperError::AmountTooLow);\n    }\n    let sender_id = env::predecessor_account_id();\n    let promise = ensure_registered(state, args.token.clone(), sender_id)?;\n    Ok(\n        promise.then(Promise::new(state.relayer_contract.clone()).function_call(\n            \"relay_meta_transaction\".to_string(),\n            vec![],\n            NearToken::from_yoctonear(0),\n            Gas::from_tgas(state.cross_contract_gas),\n        )),\n    )\n}\n\npub fn finalize_transfer(\n    state: \u0026mut FtWrapperContractState,\n    args: FinalizeTransferArgs,\n) -\u003e Result\u003cPromise, FtWrapperError\u003e {\n    state.assert_balance()?;\n    if !state.supported_tokens.contains(\u0026args.token) {\n        return Err(FtWrapperError::TokenNotSupported);\n    }\n    if args.amount.0 == 0 {\n        return Err(FtWrapperError::AmountTooLow);\n    }\n\n    // Verify MPC signature (simplified; in practice, integrate with NEAR MPC or light client)\n    if !verify_mpc_signature(\u0026args.signature, \u0026args.message_payload) {\n        return Err(FtWrapperError::Unauthorized);\n    }\n\n    // Calculate fees (based on fee_percentage or fixed amount)\n    let fee = (args.amount.0 as u128 * state.fee_percentage as u128) / 10000; // fee_percentage is in basis points\n    let net_amount = args\n        .amount\n        .0\n        .checked_sub(fee)\n        .ok_or(FtWrapperError::AmountTooLow)?;\n\n    // Ensure recipient is registered\n    let recipient_promise = ensure_registered(state, args.token.clone(), args.recipient.clone())?;\n\n    // Handle token type: mint for bridged, release for native\n    let transfer_promise = if args.is_native {\n        // Release native tokens from lock\n        ext_ft::ext(args.token.clone())\n            .with_static_gas(Gas::from_tgas(state.cross_contract_gas))\n            .ft_transfer(\n                args.recipient.clone(),\n                U128(net_amount),\n                Some(\"Incoming bridge transfer\".to_string()),\n            )\n    } else {\n        // Mint bridged tokens\n        ext_ft::ext(args.token.clone())\n            .with_static_gas(Gas::from_tgas(state.cross_contract_gas))\n            .ft_transfer(\n                args.recipient.clone(),\n                U128(net_amount),\n                Some(\"Mint bridged tokens\".to_string()),\n            )\n    };\n\n    // Transfer fees to relayer if applicable\n    let fee_promise = if fee \u003e 0 {\n        Promise::new(state.relayer_contract.clone()).transfer(NearToken::from_yoctonear(fee))\n    } else {\n        Promise::new(env::current_account_id())\n    };\n\n    // Emit event for finalization\n    FtWrapperEvent::TransferFinalized {\n        token: args.token.clone(),\n        recipient: args.recipient.clone(),\n        amount: U128(net_amount),\n        fee: U128(fee),\n        source_chain: args.source_chain.clone(),\n    }\n    .emit();\n\n    Ok(recipient_promise.and(fee_promise).then(transfer_promise))\n}\n\n// Placeholder for MPC signature verification (to be implemented with NEAR MPC or light client)\nfn verify_mpc_signature(_signature: \u0026[u8], _payload: \u0026[u8]) -\u003e bool {\n    // TODO: Integrate NEAR MPC verification or light client proof validation\n    // For now, return true for demonstration (replace with actual logic)\n    true\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","code","contracts","ft-wrapper-onsocial","src","lib.rs"],"content":"use crate::errors::FtWrapperError;\nuse crate::events::FtWrapperEvent;\nuse crate::state::FtWrapperContractState;\nuse crate::types::{\n    BridgeTransferArgs, FinalizeTransferArgs, FtTransferArgs, RequestChainSignatureArgs,\n    StorageBalance, StorageBalanceBounds,\n}; // Added FinalizeTransferArgs\nuse near_sdk::json_types::U128;\nuse near_sdk::{env, ext_contract, near, AccountId, Gas, NearToken, PanicOnDefault, Promise};\n\nmod admin;\nmod errors;\nmod events;\nmod ft;\nmod state;\nmod state_versions;\nmod types;\n\n#[ext_contract(ext_ft)]\npub trait FungibleToken {\n    fn ft_transfer(\u0026mut self, receiver_id: AccountId, amount: U128, memo: Option\u003cString\u003e);\n    fn storage_deposit(\n        \u0026mut self,\n        account_id: Option\u003cAccountId\u003e,\n        registration_only: Option\u003cbool\u003e,\n    ) -\u003e StorageBalance;\n    fn ft_balance_of(\u0026self, account_id: AccountId) -\u003e U128;\n    fn storage_balance_of(\u0026self, account_id: AccountId) -\u003e Option\u003cStorageBalance\u003e;\n    fn storage_balance_bounds(\u0026self) -\u003e StorageBalanceBounds;\n}\n\n#[ext_contract(ext_self)]\npub trait SelfCallback {\n    fn handle_registration(\u0026mut self, token: AccountId, account_id: AccountId) -\u003e Promise;\n    fn handle_storage_deposit(\u0026mut self, token: AccountId, account_id: AccountId) -\u003e Promise;\n    fn handle_balance_check(\u0026mut self, token: AccountId, account_id: AccountId) -\u003e bool;\n}\n\n#[near(contract_state)]\n#[derive(PanicOnDefault)]\npub struct FtWrapperContract {\n    state: FtWrapperContractState,\n}\n\n#[near]\nimpl FtWrapperContract {\n    #[init]\n    pub fn new(manager: AccountId, relayer_contract: AccountId, storage_deposit: U128) -\u003e Self {\n        Self {\n            state: FtWrapperContractState::new(manager, relayer_contract, storage_deposit),\n        }\n    }\n\n    #[private]\n    #[init(ignore_state)]\n    pub fn migrate() -\u003e Self {\n        use near_sdk::borsh;\n        use state_versions::{StateV010, StateV011};\n\n        const CURRENT_VERSION: \u0026str = \"0.1.1\";\n\n        // Read raw state bytes, default to empty if none\n        let state_bytes: Vec\u003cu8\u003e = env::state_read().unwrap_or_default();\n\n        // Try current version (0.1.1)\n        if let Ok(state) = borsh::from_slice::\u003cFtWrapperContractState\u003e(\u0026state_bytes) {\n            if state.version == CURRENT_VERSION {\n                env::log_str(\"State is already at latest version\");\n                return Self { state };\n            }\n        }\n\n        // Try version 0.1.1\n        if let Ok(old_state) = borsh::from_slice::\u003cStateV011\u003e(\u0026state_bytes) {\n            if old_state.version == \"0.1.1\" {\n                env::log_str(\"Migrating from state version 0.1.1\");\n                let new_state = FtWrapperContractState {\n                    version: CURRENT_VERSION.to_string(),\n                    manager: old_state.manager,\n                    relayer_contract: old_state.relayer_contract,\n                    supported_tokens: old_state.supported_tokens,\n                    storage_deposit: old_state.storage_deposit,\n                    cross_contract_gas: old_state.cross_contract_gas,\n                    storage_balances: old_state.storage_balances,\n                    min_balance: old_state.min_balance,\n                    max_balance: old_state.max_balance,\n                    fee_percentage: old_state.fee_percentage,\n                };\n                FtWrapperEvent::StateMigrated {\n                    old_version: \"0.1.1\".to_string(),\n                    new_version: CURRENT_VERSION.to_string(),\n                }\n                .emit();\n                return Self { state: new_state };\n            }\n        }\n\n        // Try version 0.1.0\n        if let Ok(old_state) = borsh::from_slice::\u003cStateV010\u003e(\u0026state_bytes) {\n            if old_state.version == \"0.1.0\" {\n                env::log_str(\"Migrating from state version 0.1.0\");\n                let new_state = FtWrapperContractState {\n                    version: CURRENT_VERSION.to_string(),\n                    manager: old_state.manager,\n                    relayer_contract: old_state.relayer_contract,\n                    supported_tokens: old_state.supported_tokens,\n                    storage_deposit: old_state.storage_deposit,\n                    cross_contract_gas: old_state.cross_contract_gas,\n                    storage_balances: old_state.storage_balances,\n                    min_balance: old_state.min_balance,\n                    max_balance: old_state.max_balance,\n                    fee_percentage: 0,\n                };\n                FtWrapperEvent::StateMigrated {\n                    old_version: \"0.1.0\".to_string(),\n                    new_version: CURRENT_VERSION.to_string(),\n                }\n                .emit();\n                return Self { state: new_state };\n            }\n        }\n\n        env::log_str(\"No valid prior state found, initializing new state\");\n        Self {\n            state: FtWrapperContractState::new(\n                env::current_account_id(),\n                env::current_account_id(),\n                U128(1_250_000_000_000_000_000_000),\n            ),\n        }\n    }\n\n    #[payable]\n    #[handle_result]\n    pub fn deposit(\u0026mut self) -\u003e Result\u003c(), FtWrapperError\u003e {\n        let caller = env::predecessor_account_id();\n        if !self.state.is_manager(\u0026caller) {\n            return Err(FtWrapperError::Unauthorized);\n        }\n        let deposit = env::attached_deposit().as_yoctonear();\n        let balance = env::account_balance().as_yoctonear() + deposit;\n        if balance \u003e self.state.max_balance {\n            let excess = balance - self.state.max_balance;\n            Promise::new(caller).transfer(NearToken::from_yoctonear(excess));\n        }\n        Ok(())\n    }\n\n    pub fn ft_transfer(\u0026mut self, args: FtTransferArgs) -\u003e Promise {\n        self.ft_transfer_internal(args).expect(\"FT transfer failed\")\n    }\n\n    pub fn request_chain_signature(\u0026mut self, args: RequestChainSignatureArgs) -\u003e Promise {\n        self.request_chain_signature_internal(args)\n            .expect(\"Chain signature request failed\")\n    }\n\n    pub fn bridge_transfer(\u0026mut self, args: BridgeTransferArgs) -\u003e Promise {\n        self.bridge_transfer_internal(args)\n            .expect(\"Bridge transfer failed\")\n    }\n\n    pub fn finalize_transfer(\u0026mut self, args: FinalizeTransferArgs) -\u003e Promise {\n        self.finalize_transfer_internal(args)\n            .expect(\"Finalize transfer failed\")\n    }\n\n    pub fn storage_deposit(\n        \u0026mut self,\n        token: AccountId,\n        account_id: Option\u003cAccountId\u003e,\n        registration_only: Option\u003cbool\u003e,\n    ) -\u003e StorageBalance {\n        self.storage_deposit_internal(token, account_id, registration_only)\n            .expect(\"Storage deposit failed\")\n    }\n\n    #[payable]\n    pub fn storage_withdraw(\u0026mut self, token: AccountId, amount: Option\u003cU128\u003e) -\u003e StorageBalance {\n        self.storage_withdraw_internal(token, amount)\n            .expect(\"Storage withdraw failed\")\n    }\n\n    pub fn storage_balance_of(\u0026self, token: AccountId, account_id: AccountId) -\u003e Promise {\n        self.storage_balance_of_internal(token, account_id)\n    }\n\n    pub fn storage_balance_bounds(\u0026self, token: AccountId) -\u003e Promise {\n        self.storage_balance_bounds_internal(token)\n    }\n\n    #[payable]\n    pub fn storage_unregister(\u0026mut self, token: AccountId, force: Option\u003cbool\u003e) -\u003e bool {\n        self.storage_unregister_internal(token, force)\n            .expect(\"Storage unregister failed\")\n    }\n\n    #[handle_result]\n    pub fn add_supported_token(\u0026mut self, token: AccountId) -\u003e Result\u003c(), FtWrapperError\u003e {\n        self.add_supported_token_internal(token)\n    }\n\n    #[handle_result]\n    pub fn remove_supported_token(\u0026mut self, token: AccountId) -\u003e Result\u003c(), FtWrapperError\u003e {\n        self.remove_supported_token_internal(token)\n    }\n\n    #[handle_result]\n    pub fn set_cross_contract_gas(\u0026mut self, gas_tgas: u64) -\u003e Result\u003c(), FtWrapperError\u003e {\n        self.set_cross_contract_gas_internal(gas_tgas)\n    }\n\n    #[handle_result]\n    pub fn set_storage_deposit(\u0026mut self, storage_deposit: U128) -\u003e Result\u003c(), FtWrapperError\u003e {\n        self.set_storage_deposit_internal(storage_deposit)\n    }\n\n    #[handle_result]\n    pub fn set_manager(\u0026mut self, new_manager: AccountId) -\u003e Result\u003c(), FtWrapperError\u003e {\n        self.state.set_manager(new_manager.clone())?;\n        FtWrapperEvent::ManagerUpdated { new_manager }.emit();\n        Ok(())\n    }\n\n    pub fn get_supported_tokens(\u0026self) -\u003e Vec\u003cAccountId\u003e {\n        self.state\n            .supported_tokens\n            .iter()\n            .map(|token| token.clone())\n            .collect()\n    }\n\n    pub fn ft_balance_of(\u0026mut self, token: AccountId, account_id: AccountId) -\u003e Promise {\n        self.ft_balance_of_internal(token, account_id)\n    }\n\n    #[handle_result]\n    pub fn update_contract(\u0026mut self) -\u003e Result\u003cPromise, FtWrapperError\u003e {\n        let caller = env::predecessor_account_id();\n        if !self.state.is_manager(\u0026caller) {\n            return Err(FtWrapperError::Unauthorized);\n        }\n        let code = env::input().ok_or(FtWrapperError::Unauthorized)?.to_vec();\n        FtWrapperEvent::ContractUpgraded {\n            manager: caller.clone(),\n            timestamp: env::block_timestamp_ms(),\n        }\n        .emit();\n        Ok(Promise::new(env::current_account_id())\n            .deploy_contract(code)\n            .function_call(\n                \"migrate\".to_string(),\n                vec![],\n                NearToken::from_yoctonear(0),\n                Gas::from_tgas(250),\n            ))\n    }\n\n    #[private]\n    pub fn handle_registration(\u0026mut self, token: AccountId, account_id: AccountId) -\u003e Promise {\n        self.handle_registration_internal(token, account_id)\n    }\n\n    #[private]\n    pub fn handle_storage_deposit(\u0026mut self, token: AccountId, account_id: AccountId) -\u003e Promise {\n        self.handle_storage_deposit_internal(token, account_id)\n    }\n\n    #[private]\n    pub fn handle_balance_check(\n        \u0026mut self,\n        token: AccountId,\n        account_id: AccountId,\n        balance: U128,\n    ) -\u003e bool {\n        crate::ft::handle_balance_check(\u0026mut self.state, token, account_id, balance)\n    }\n\n    fn ft_transfer_internal(\u0026mut self, args: FtTransferArgs) -\u003e Result\u003cPromise, FtWrapperError\u003e {\n        crate::ft::ft_transfer(\u0026mut self.state, args)\n    }\n\n    fn request_chain_signature_internal(\n        \u0026mut self,\n        args: RequestChainSignatureArgs,\n    ) -\u003e Result\u003cPromise, FtWrapperError\u003e {\n        crate::ft::request_chain_signature(\u0026mut self.state, args)\n    }\n\n    fn bridge_transfer_internal(\n        \u0026mut self,\n        args: BridgeTransferArgs,\n    ) -\u003e Result\u003cPromise, FtWrapperError\u003e {\n        crate::ft::bridge_transfer(\u0026mut self.state, args)\n    }\n\n    fn finalize_transfer_internal(\n        \u0026mut self,\n        args: FinalizeTransferArgs,\n    ) -\u003e Result\u003cPromise, FtWrapperError\u003e {\n        crate::ft::finalize_transfer(\u0026mut self.state, args)\n    }\n\n    fn storage_deposit_internal(\n        \u0026mut self,\n        token: AccountId,\n        account_id: Option\u003cAccountId\u003e,\n        registration_only: Option\u003cbool\u003e,\n    ) -\u003e Result\u003cStorageBalance, FtWrapperError\u003e {\n        crate::ft::storage_deposit(\u0026mut self.state, token, account_id, registration_only)\n    }\n\n    fn storage_withdraw_internal(\n        \u0026mut self,\n        token: AccountId,\n        amount: Option\u003cU128\u003e,\n    ) -\u003e Result\u003cStorageBalance, FtWrapperError\u003e {\n        crate::ft::storage_withdraw(\u0026mut self.state, token, amount)\n    }\n\n    fn storage_balance_of_internal(\u0026self, token: AccountId, account_id: AccountId) -\u003e Promise {\n        crate::ft::storage_balance_of(\u0026self.state, token, account_id)\n    }\n\n    fn storage_balance_bounds_internal(\u0026self, token: AccountId) -\u003e Promise {\n        crate::ft::storage_balance_bounds(\u0026self.state, token)\n    }\n\n    fn storage_unregister_internal(\n        \u0026mut self,\n        token: AccountId,\n        force: Option\u003cbool\u003e,\n    ) -\u003e Result\u003cbool, FtWrapperError\u003e {\n        crate::ft::storage_unregister(\u0026mut self.state, token, force)\n    }\n\n    fn add_supported_token_internal(\u0026mut self, token: AccountId) -\u003e Result\u003c(), FtWrapperError\u003e {\n        crate::admin::add_supported_token(\u0026mut self.state, token)\n    }\n\n    fn remove_supported_token_internal(\u0026mut self, token: AccountId) -\u003e Result\u003c(), FtWrapperError\u003e {\n        crate::admin::remove_supported_token(\u0026mut self.state, token)\n    }\n\n    fn set_cross_contract_gas_internal(\u0026mut self, gas_tgas: u64) -\u003e Result\u003c(), FtWrapperError\u003e {\n        crate::admin::set_cross_contract_gas(\u0026mut self.state, gas_tgas)\n    }\n\n    fn set_storage_deposit_internal(\n        \u0026mut self,\n        storage_deposit: U128,\n    ) -\u003e Result\u003c(), FtWrapperError\u003e {\n        crate::admin::set_storage_deposit(\u0026mut self.state, storage_deposit)\n    }\n\n    fn ft_balance_of_internal(\u0026mut self, token: AccountId, account_id: AccountId) -\u003e Promise {\n        crate::ft::ft_balance_of(\u0026mut self.state, token, account_id)\n    }\n\n    fn handle_registration_internal(\u0026mut self, token: AccountId, account_id: AccountId) -\u003e Promise {\n        crate::ft::handle_registration(\u0026mut self.state, token, account_id)\n    }\n\n    fn handle_storage_deposit_internal(\n        \u0026mut self,\n        token: AccountId,\n        account_id: AccountId,\n    ) -\u003e Promise {\n        crate::ft::handle_storage_deposit(\u0026mut self.state, token, account_id)\n    }\n}\n\n#[cfg(test)]\nmod tests;\n","traces":[],"covered":0,"coverable":0},{"path":["/","code","contracts","ft-wrapper-onsocial","src","state.rs"],"content":"use crate::errors::FtWrapperError;\nuse crate::types::StorageBalance;\nuse near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};\nuse near_sdk::json_types::U128;\nuse near_sdk::store::LookupMap;\nuse near_sdk::{env, AccountId};\nuse near_sdk_macros::NearSchema;\n\n#[derive(BorshSerialize, BorshDeserialize, NearSchema)]\n#[abi(borsh)]\npub struct FtWrapperContractState {\n    pub version: String,\n    pub manager: AccountId,\n    pub relayer_contract: AccountId,\n    pub supported_tokens: Vec\u003cAccountId\u003e,\n    pub storage_deposit: U128,\n    pub cross_contract_gas: u64,\n    pub storage_balances: LookupMap\u003c(AccountId, AccountId), StorageBalance\u003e,\n    pub min_balance: u128,\n    pub max_balance: u128,\n    pub fee_percentage: u64, // Added for 0.1.1\n}\n\nimpl FtWrapperContractState {\n    pub fn new(manager: AccountId, relayer_contract: AccountId, storage_deposit: U128) -\u003e Self {\n        Self {\n            version: \"0.1.1\".to_string(), // Updated to 0.1.1\n            manager,\n            relayer_contract,\n            supported_tokens: Vec::new(),\n            storage_deposit,\n            cross_contract_gas: 100_000_000_000_000,\n            storage_balances: LookupMap::new(b\"s\".to_vec()),\n            min_balance: 10_000_000_000_000_000_000_000_000,\n            max_balance: 1_000_000_000_000_000_000_000_000_000,\n            fee_percentage: 0, // Default value\n        }\n    }\n\n    pub fn is_manager(\u0026self, account_id: \u0026AccountId) -\u003e bool {\n        \u0026self.manager == account_id\n    }\n\n    pub fn assert_balance(\u0026self) -\u003e Result\u003c(), FtWrapperError\u003e {\n        let balance = env::account_balance().as_yoctonear();\n        if balance \u003c self.min_balance {\n            return Err(FtWrapperError::LowBalance);\n        }\n        Ok(())\n    }\n\n    pub fn set_manager(\u0026mut self, new_manager: AccountId) -\u003e Result\u003c(), FtWrapperError\u003e {\n        let caller = env::predecessor_account_id();\n        if !self.is_manager(\u0026caller) {\n            return Err(FtWrapperError::Unauthorized);\n        }\n        self.manager = new_manager.clone();\n        Ok(())\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","code","contracts","ft-wrapper-onsocial","src","state_versions.rs"],"content":"use crate::types::StorageBalance;\nuse near_sdk::borsh::{BorshDeserialize, BorshSerialize};\nuse near_sdk::json_types::U128;\nuse near_sdk::store::LookupMap;\nuse near_sdk::AccountId;\n\n/// State for version 0.1.0\n#[derive(BorshSerialize, BorshDeserialize)]\npub struct StateV010 {\n    pub version: String,\n    pub manager: AccountId,\n    pub relayer_contract: AccountId,\n    pub supported_tokens: Vec\u003cAccountId\u003e,\n    pub storage_deposit: U128,\n    pub cross_contract_gas: u64,\n    pub storage_balances: LookupMap\u003c(AccountId, AccountId), StorageBalance\u003e,\n    pub min_balance: u128,\n    pub max_balance: u128,\n}\n\n/// State for version 0.1.1 (adds fee_percentage)\n#[derive(BorshSerialize, BorshDeserialize)]\npub struct StateV011 {\n    pub version: String,\n    pub manager: AccountId,\n    pub relayer_contract: AccountId,\n    pub supported_tokens: Vec\u003cAccountId\u003e,\n    pub storage_deposit: U128,\n    pub cross_contract_gas: u64,\n    pub storage_balances: LookupMap\u003c(AccountId, AccountId), StorageBalance\u003e,\n    pub min_balance: u128,\n    pub max_balance: u128,\n    pub fee_percentage: u64,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","code","contracts","ft-wrapper-onsocial","src","tests.rs"],"content":"#[cfg(test)]\nmod tests {\n    use crate::{\n        state_versions::{StateV010, StateV011},\n        FtWrapperContract,\n    };\n    use near_sdk::borsh;\n    use near_sdk::json_types::U128;\n    use near_sdk::store::LookupMap;\n    use near_sdk::{\n        env,\n        test_utils::{get_logs, VMContextBuilder},\n        testing_env, AccountId, NearToken,\n    };\n\n    fn setup_context(predecessor: AccountId) -\u003e VMContextBuilder {\n        let mut context = VMContextBuilder::new();\n        context\n            .predecessor_account_id(predecessor)\n            .current_account_id(\"ft-wrapper.testnet\".parse::\u003cAccountId\u003e().unwrap())\n            .block_timestamp(1_000_000_000_000)\n            .attached_deposit(NearToken::from_yoctonear(0));\n        context\n    }\n\n    #[test]\n    fn test_add_supported_token() {\n        let manager: AccountId = \"manager.testnet\".parse().unwrap();\n        let context = setup_context(manager.clone());\n        testing_env!(context.build());\n\n        let mut contract = FtWrapperContract::new(\n            manager.clone(),\n            \"relayer.testnet\".parse().unwrap(),\n            U128(1_250_000_000_000_000_000_000),\n        );\n        let token: AccountId = \"token.testnet\".parse().unwrap();\n\n        contract\n            .add_supported_token(token.clone())\n            .expect(\"Failed to add token\");\n        assert!(\n            contract.state.supported_tokens.contains(\u0026token),\n            \"Token should be supported\"\n        );\n\n        let logs = get_logs();\n        assert!(\n            logs.contains(\u0026\"EVENT_JSON:{\\\"standard\\\":\\\"nep297\\\",\\\"version\\\":\\\"1.0.0\\\",\\\"event\\\":\\\"token_added\\\",\\\"data\\\":{\\\"token\\\":\\\"token.testnet\\\"}}\".to_string()),\n            \"Expected token_added event, got: {:?}\", logs\n        );\n    }\n\n    #[test]\n    fn test_migration_from_010_to_011() {\n        let manager: AccountId = \"manager.testnet\".parse().unwrap();\n        let context = setup_context(manager.clone());\n        testing_env!(context.build());\n\n        let token: AccountId = \"token.testnet\".parse().unwrap();\n        let state_v010 = StateV010 {\n            version: \"0.1.0\".to_string(),\n            manager: manager.clone(),\n            relayer_contract: \"relayer.testnet\".parse().unwrap(),\n            supported_tokens: vec![token.clone()],\n            storage_deposit: U128(1_250_000_000_000_000_000_000),\n            cross_contract_gas: 100_000_000_000_000,\n            storage_balances: LookupMap::new(b\"s\".to_vec()),\n            min_balance: 10_000_000_000_000_000_000_000_000,\n            max_balance: 1_000_000_000_000_000_000_000_000_000,\n        };\n        // Serialize state to Borsh\n        let state_bytes = borsh::to_vec(\u0026state_v010).expect(\"Failed to serialize state\");\n        env::state_write(\u0026state_bytes);\n\n        let new_contract = FtWrapperContract::migrate();\n\n        assert_eq!(\n            new_contract.state.version, \"0.1.1\",\n            \"Version should be 0.1.1\"\n        );\n        assert_eq!(\n            new_contract.state.manager, manager,\n            \"Manager should be preserved\"\n        );\n        assert_eq!(\n            new_contract.state.relayer_contract,\n            \"relayer.testnet\".parse::\u003cAccountId\u003e().unwrap(),\n            \"Relayer contract should be preserved\"\n        );\n        assert!(\n            new_contract.state.supported_tokens.contains(\u0026token),\n            \"Supported tokens should be preserved\"\n        );\n        assert_eq!(\n            new_contract.state.fee_percentage, 0,\n            \"Fee percentage should be initialized\"\n        );\n\n        let logs = get_logs();\n        assert!(\n            logs.contains(\u0026\"Migrating from state version 0.1.0\".to_string()),\n            \"Expected migration log, got: {:?}\",\n            logs\n        );\n        assert!(\n            logs.contains(\u0026\"EVENT_JSON:{\\\"standard\\\":\\\"nep297\\\",\\\"version\\\":\\\"1.0.0\\\",\\\"event\\\":\\\"state_migrated\\\",\\\"data\\\":{\\\"old_version\\\":\\\"0.1.0\\\",\\\"new_version\\\":\\\"0.1.1\\\"}}\".to_string()),\n            \"Expected state_migrated event, got: {:?}\", logs\n        );\n    }\n\n    #[test]\n    fn test_migration_from_011_to_011() {\n        let manager: AccountId = \"manager.testnet\".parse().unwrap();\n        let context = setup_context(manager.clone());\n        testing_env!(context.build());\n\n        let token: AccountId = \"token.testnet\".parse().unwrap();\n        let state_v011 = StateV011 {\n            version: \"0.1.1\".to_string(),\n            manager: manager.clone(),\n            relayer_contract: \"relayer.testnet\".parse().unwrap(),\n            supported_tokens: vec![token.clone()],\n            storage_deposit: U128(1_250_000_000_000_000_000_000),\n            cross_contract_gas: 100_000_000_000_000,\n            storage_balances: LookupMap::new(b\"s\".to_vec()),\n            min_balance: 10_000_000_000_000_000_000_000_000,\n            max_balance: 1_000_000_000_000_000_000_000_000_000,\n            fee_percentage: 10,\n        };\n        // Serialize state to Borsh\n        let state_bytes = borsh::to_vec(\u0026state_v011).expect(\"Failed to serialize state\");\n        env::state_write(\u0026state_bytes);\n\n        let new_contract = FtWrapperContract::migrate();\n\n        assert_eq!(\n            new_contract.state.version, \"0.1.1\",\n            \"Version should be 0.1.1\"\n        );\n        assert_eq!(\n            new_contract.state.manager, manager,\n            \"Manager should be preserved\"\n        );\n        assert_eq!(\n            new_contract.state.relayer_contract,\n            \"relayer.testnet\".parse::\u003cAccountId\u003e().unwrap(),\n            \"Relayer contract should be preserved\"\n        );\n        assert!(\n            new_contract.state.supported_tokens.contains(\u0026token),\n            \"Supported tokens should be preserved\"\n        );\n        assert_eq!(\n            new_contract.state.fee_percentage, 10,\n            \"Fee percentage should be preserved\"\n        );\n\n        let logs = get_logs();\n        assert!(\n            logs.contains(\u0026\"State is already at latest version\".to_string()),\n            \"Expected latest version log, got: {:?}\",\n            logs\n        );\n    }\n\n    #[test]\n    fn test_migration_no_prior_state() {\n        let manager: AccountId = \"manager.testnet\".parse().unwrap();\n        let context = setup_context(manager.clone());\n        testing_env!(context.build());\n\n        let new_contract = FtWrapperContract::migrate();\n\n        assert_eq!(\n            new_contract.state.version, \"0.1.1\",\n            \"Version should be 0.1.1\"\n        );\n        assert_eq!(\n            new_contract.state.manager,\n            env::current_account_id(),\n            \"Manager should be current account\"\n        );\n        assert_eq!(\n            new_contract.state.fee_percentage, 0,\n            \"Fee percentage should be initialized\"\n        );\n\n        let logs = get_logs();\n        assert!(\n            logs.contains(\u0026\"No valid prior state found, initializing new state\".to_string()),\n            \"Expected no prior state log, got: {:?}\",\n            logs\n        );\n    }\n\n    #[test]\n    fn test_migration_corrupted_state() {\n        let manager: AccountId = \"manager.testnet\".parse().unwrap();\n        let context = setup_context(manager.clone());\n        testing_env!(context.build());\n\n        // Simulate corrupted state\n        env::state_write(\u0026vec![0u8; 10]); // Invalid Borsh data\n\n        let new_contract = FtWrapperContract::migrate();\n\n        assert_eq!(\n            new_contract.state.version, \"0.1.1\",\n            \"Version should be 0.1.1\"\n        );\n        assert_eq!(\n            new_contract.state.manager,\n            env::current_account_id(),\n            \"Manager should be current account\"\n        );\n        assert_eq!(\n            new_contract.state.fee_percentage, 0,\n            \"Fee percentage should be initialized\"\n        );\n\n        let logs = get_logs();\n        assert!(\n            logs.contains(\u0026\"No valid prior state found, initializing new state\".to_string()),\n            \"Expected no prior state log, got: {:?}\",\n            logs\n        );\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","code","contracts","ft-wrapper-onsocial","src","types.rs"],"content":"use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};\nuse near_sdk::json_types::U128;\nuse near_sdk::serde::{Deserialize, Serialize};\nuse near_sdk::{AccountId, Gas, NearToken, PublicKey};\nuse near_sdk_macros::NearSchema;\n\n#[derive(NearSchema, Serialize, Deserialize, Clone, BorshSerialize, BorshDeserialize)]\n#[abi(borsh, json)]\n#[serde(crate = \"near_sdk::serde\")]\npub enum Action {\n    ChainSignatureRequest {\n        target_chain: String,\n        derivation_path: String,\n        payload: Vec\u003cu8\u003e,\n    },\n    FunctionCall {\n        method_name: String,\n        args: Vec\u003cu8\u003e,\n        gas: Gas,\n        deposit: NearToken,\n    },\n    Transfer {\n        deposit: NearToken,\n    },\n    AddKey {\n        public_key: PublicKey,\n        allowance: Option\u003cNearToken\u003e,\n        receiver_id: AccountId,\n        method_names: Vec\u003cString\u003e,\n    },\n    FtTransfer {\n        token: AccountId,\n        receiver_id: AccountId,\n        amount: U128,\n        memo: Option\u003cString\u003e,\n    },\n    BridgeTransfer {\n        token: AccountId,\n        amount: U128,\n        destination_chain: String,\n        recipient: String,\n    },\n}\n\n#[derive(NearSchema, Serialize, Deserialize, Clone, BorshSerialize, BorshDeserialize)]\n#[abi(borsh, json)]\n#[serde(crate = \"near_sdk::serde\")]\npub struct FtTransferArgs {\n    pub token: AccountId,\n    pub receiver_id: AccountId,\n    pub amount: U128,\n    pub memo: Option\u003cString\u003e,\n}\n\n#[derive(NearSchema, Serialize, Deserialize, Clone, BorshSerialize, BorshDeserialize)]\n#[abi(borsh, json)]\n#[serde(crate = \"near_sdk::serde\")]\npub struct RequestChainSignatureArgs {\n    pub token: AccountId,\n    pub target_chain: String,\n    pub derivation_path: String,\n    pub payload: Vec\u003cu8\u003e,\n}\n\n#[derive(NearSchema, Serialize, Deserialize, Clone, BorshSerialize, BorshDeserialize)]\n#[abi(borsh, json)]\n#[serde(crate = \"near_sdk::serde\")]\npub struct BridgeTransferArgs {\n    pub token: AccountId,\n    pub amount: U128,\n    pub destination_chain: String,\n    pub recipient: String,\n}\n\n#[derive(NearSchema, Serialize, Deserialize, Clone, BorshSerialize, BorshDeserialize)]\n#[abi(borsh, json)]\n#[serde(crate = \"near_sdk::serde\")]\npub struct FinalizeTransferArgs {\n    pub token: AccountId,\n    pub recipient: AccountId,\n    pub amount: U128,\n    pub source_chain: String,\n    pub is_native: bool,\n    pub signature: Vec\u003cu8\u003e,\n    pub message_payload: Vec\u003cu8\u003e,\n}\n\n#[derive(NearSchema, Serialize, Deserialize, Clone, BorshSerialize, BorshDeserialize)]\n#[abi(borsh, json)]\n#[serde(crate = \"near_sdk::serde\")]\npub struct StorageBalance {\n    pub total: U128,\n    pub available: U128,\n}\n\n#[derive(NearSchema, Serialize, Deserialize, Clone, BorshSerialize, BorshDeserialize)]\n#[abi(borsh, json)]\n#[serde(crate = \"near_sdk::serde\")]\npub struct StorageBalanceBounds {\n    pub min: U128,\n    pub max: Option\u003cU128\u003e,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","code","contracts","relayer-onsocial","src","admin.rs"],"content":"use crate::errors::RelayerError;\nuse crate::events::RelayerEvent;\nuse crate::{ext_auth, state::Relayer};\nuse near_sdk::{env, AccountId, Gas, PublicKey};\n\npub fn register_existing_account(\n    relayer: \u0026mut Relayer,\n    account_id: AccountId,\n    public_key: PublicKey,\n    expiration_days: Option\u003cu32\u003e,\n    is_multi_sig: bool,\n    multi_sig_threshold: Option\u003cu32\u003e,\n) -\u003e Result\u003c(), RelayerError\u003e {\n    let caller = env::predecessor_account_id();\n    if caller != account_id {\n        return Err(RelayerError::Unauthorized);\n    }\n    if public_key.as_bytes().len() != 33 || public_key.as_bytes()[0] != 0 {\n        return Err(RelayerError::InvalidSignature);\n    }\n    ext_auth::ext(relayer.auth_contract.clone())\n        .with_static_gas(Gas::from_tgas(relayer.cross_contract_gas))\n        .register_key(\n            account_id.clone(),\n            public_key.clone(),\n            expiration_days,\n            is_multi_sig,\n            multi_sig_threshold,\n        );\n    let key_hash = hex::encode(env::sha256(\u0026public_key.as_bytes()));\n    RelayerEvent::AuthAdded {\n        auth_account: account_id,\n        key_hash,\n    }\n    .emit();\n    Ok(())\n}\n\npub fn remove_key(\n    relayer: \u0026mut Relayer,\n    account_id: AccountId,\n    public_key: PublicKey,\n) -\u003e Result\u003c(), RelayerError\u003e {\n    let caller = env::predecessor_account_id();\n    if caller != account_id {\n        return Err(RelayerError::Unauthorized);\n    }\n    ext_auth::ext(relayer.auth_contract.clone())\n        .with_static_gas(Gas::from_tgas(relayer.cross_contract_gas))\n        .remove_key(account_id.clone(), public_key.clone());\n    let key_hash = hex::encode(env::sha256(\u0026public_key.as_bytes()));\n    RelayerEvent::AuthRemoved {\n        auth_account: account_id,\n        key_hash,\n    }\n    .emit();\n    Ok(())\n}\n\npub fn set_cross_contract_gas(relayer: \u0026mut Relayer, new_gas: u64) -\u003e Result\u003c(), RelayerError\u003e {\n    let caller = env::predecessor_account_id();\n    if !relayer.is_manager(\u0026caller) {\n        return Err(RelayerError::Unauthorized);\n    }\n    if new_gas \u003c 15_000_000_000_000 || new_gas \u003e 100_000_000_000_000 {\n        return Err(RelayerError::AmountTooLow);\n    }\n    relayer.cross_contract_gas = new_gas;\n    RelayerEvent::CrossContractGasUpdated { new_gas }.emit();\n    let remaining_gas = env::prepaid_gas()\n        .as_tgas()\n        .saturating_sub(env::used_gas().as_tgas());\n    env::log_str(\u0026format!(\n        \"set_cross_contract_gas: prepaid={} TGas, used={} TGas, remaining={} TGas\",\n        env::prepaid_gas().as_tgas(),\n        env::used_gas().as_tgas(),\n        remaining_gas\n    ));\n    Ok(())\n}\n\npub fn set_migration_gas(relayer: \u0026mut Relayer, new_gas: u64) -\u003e Result\u003c(), RelayerError\u003e {\n    let caller = env::predecessor_account_id();\n    if !relayer.is_manager(\u0026caller) {\n        return Err(RelayerError::Unauthorized);\n    }\n    if new_gas \u003c 15_000_000_000_000 || new_gas \u003e 200_000_000_000_000 {\n        return Err(RelayerError::AmountTooLow);\n    }\n    relayer.migration_gas = new_gas;\n    RelayerEvent::MigrationGasUpdated { new_gas }.emit();\n    let remaining_gas = env::prepaid_gas()\n        .as_tgas()\n        .saturating_sub(env::used_gas().as_tgas());\n    env::log_str(\u0026format!(\n        \"set_migration_gas: prepaid={} TGas, used={} TGas, remaining={} TGas\",\n        env::prepaid_gas().as_tgas(),\n        env::used_gas().as_tgas(),\n        remaining_gas\n    ));\n    Ok(())\n}\n\npub fn set_omni_locker_contract(\n    relayer: \u0026mut Relayer,\n    new_locker_contract: AccountId,\n) -\u003e Result\u003c(), RelayerError\u003e {\n    let caller = env::predecessor_account_id();\n    if !relayer.is_manager(\u0026caller) {\n        return Err(RelayerError::Unauthorized);\n    }\n    relayer\n        .omni_locker_contract\n        .set(Some(new_locker_contract.clone()));\n    RelayerEvent::OmniLockerContractUpdated {\n        new_locker_contract,\n    }\n    .emit();\n    Ok(())\n}\n\npub fn set_offload_recipient(\n    relayer: \u0026mut Relayer,\n    new_recipient: AccountId,\n) -\u003e Result\u003c(), RelayerError\u003e {\n    let caller = env::predecessor_account_id();\n    if !relayer.is_manager(\u0026caller) {\n        return Err(RelayerError::Unauthorized);\n    }\n    relayer.offload_recipient = new_recipient.clone();\n    RelayerEvent::OffloadRecipientUpdated { new_recipient }.emit();\n    Ok(())\n}\n\npub fn set_manager(relayer: \u0026mut Relayer, new_manager: AccountId) -\u003e Result\u003c(), RelayerError\u003e {\n    let caller = env::predecessor_account_id();\n    if !relayer.is_manager(\u0026caller) {\n        return Err(RelayerError::Unauthorized);\n    }\n    relayer.manager = new_manager.clone();\n    RelayerEvent::ManagerChanged {\n        old_manager: caller,\n        new_manager,\n        timestamp: env::block_timestamp_ms(),\n    }\n    .emit();\n    Ok(())\n}\n\npub fn set_sponsor_amount(relayer: \u0026mut Relayer, new_amount: u128) -\u003e Result\u003c(), RelayerError\u003e {\n    let caller = env::predecessor_account_id();\n    if !relayer.is_manager(\u0026caller) {\n        return Err(RelayerError::Unauthorized);\n    }\n    if new_amount \u003c 10_000_000_000_000_000_000_000 {\n        return Err(RelayerError::AmountTooLow);\n    }\n    relayer.sponsor_amount = new_amount;\n    RelayerEvent::SponsorAmountUpdated { new_amount }.emit();\n    Ok(())\n}\n\npub fn set_sponsor_gas(relayer: \u0026mut Relayer, new_gas: u64) -\u003e Result\u003c(), RelayerError\u003e {\n    let caller = env::predecessor_account_id();\n    if !relayer.is_manager(\u0026caller) {\n        return Err(RelayerError::Unauthorized);\n    }\n    if new_gas \u003c 50_000_000_000_000 || new_gas \u003e 300_000_000_000_000 {\n        return Err(RelayerError::AmountTooLow);\n    }\n    relayer.sponsor_gas = new_gas;\n    RelayerEvent::SponsorGasUpdated { new_gas }.emit();\n    Ok(())\n}\n\npub fn set_chunk_size(relayer: \u0026mut Relayer, new_size: usize) -\u003e Result\u003c(), RelayerError\u003e {\n    let caller = env::predecessor_account_id();\n    if !relayer.is_manager(\u0026caller) {\n        return Err(RelayerError::Unauthorized);\n    }\n    if new_size \u003c 1 || new_size \u003e 5 {\n        return Err(RelayerError::AmountTooLow);\n    }\n    relayer.chunk_size = new_size;\n    RelayerEvent::ChunkSizeUpdated { new_size }.emit();\n    let remaining_gas = env::prepaid_gas()\n        .as_tgas()\n        .saturating_sub(env::used_gas().as_tgas());\n    env::log_str(\u0026format!(\n        \"set_chunk_size: prepaid={} TGas, used={} TGas, remaining={} TGas\",\n        env::prepaid_gas().as_tgas(),\n        env::used_gas().as_tgas(),\n        remaining_gas\n    ));\n    Ok(())\n}\n\npub fn add_chain_mpc_mapping(\n    relayer: \u0026mut Relayer,\n    chain: String,\n    mpc_contract: AccountId,\n) -\u003e Result\u003c(), RelayerError\u003e {\n    let caller = env::predecessor_account_id();\n    if !relayer.is_manager(\u0026caller) {\n        return Err(RelayerError::Unauthorized);\n    }\n    relayer\n        .chain_mpc_mapping\n        .insert(chain.clone(), mpc_contract.clone());\n    RelayerEvent::ChainMpcMappingAdded {\n        chain,\n        mpc_contract,\n    }\n    .emit();\n    Ok(())\n}\n\npub fn remove_chain_mpc_mapping(relayer: \u0026mut Relayer, chain: String) -\u003e Result\u003c(), RelayerError\u003e {\n    let caller = env::predecessor_account_id();\n    if !relayer.is_manager(\u0026caller) {\n        return Err(RelayerError::Unauthorized);\n    }\n    relayer.chain_mpc_mapping.remove(\u0026chain);\n    RelayerEvent::ChainMpcMappingRemoved { chain }.emit();\n    Ok(())\n}\n\npub fn set_auth_contract(\n    relayer: \u0026mut Relayer,\n    new_auth_contract: AccountId,\n) -\u003e Result\u003c(), RelayerError\u003e {\n    let caller = env::predecessor_account_id();\n    if !relayer.is_manager(\u0026caller) {\n        return Err(RelayerError::Unauthorized);\n    }\n    relayer.auth_contract = new_auth_contract.clone();\n    RelayerEvent::AuthContractUpdated { new_auth_contract }.emit();\n    Ok(())\n}\n\npub fn set_ft_wrapper_contract(\n    relayer: \u0026mut Relayer,\n    new_ft_wrapper_contract: AccountId,\n) -\u003e Result\u003c(), RelayerError\u003e {\n    let caller = env::predecessor_account_id();\n    if !relayer.is_manager(\u0026caller) {\n        return Err(RelayerError::Unauthorized);\n    }\n    relayer.ft_wrapper_contract = new_ft_wrapper_contract.clone();\n    RelayerEvent::FtWrapperContractUpdated {\n        new_ft_wrapper_contract,\n    }\n    .emit();\n    Ok(())\n}\n\npub fn set_base_fee(\n    relayer: \u0026mut Relayer,\n    new_fee: u128,\n    signatures: Option\u003cVec\u003cVec\u003cu8\u003e\u003e\u003e,\n) -\u003e Result\u003c(), RelayerError\u003e {\n    let caller = env::predecessor_account_id();\n    if !relayer.is_manager(\u0026caller) {\n        return Err(RelayerError::Unauthorized);\n    }\n    // Allow zero fee without signatures for flexibility\n    if new_fee \u003e 0 {\n        if let Some(sigs) = signatures {\n            if sigs.len() \u003c 2 {\n                return Err(RelayerError::InsufficientSignatures);\n            }\n        } else {\n            return Err(RelayerError::InsufficientSignatures);\n        }\n        let min_fee = 100_000_000_000_000_000_000; // 0.0001 NEAR\n        if new_fee \u003c min_fee {\n            return Err(RelayerError::FeeTooLow);\n        }\n    }\n    relayer.base_fee = new_fee;\n    RelayerEvent::BaseFeeUpdated { new_fee }.emit();\n    Ok(())\n}\n\npub fn set_min_balance(relayer: \u0026mut Relayer, new_min: u128) -\u003e Result\u003c(), RelayerError\u003e {\n    let caller = env::predecessor_account_id();\n    if !relayer.is_manager(\u0026caller) {\n        return Err(RelayerError::Unauthorized);\n    }\n    if new_min \u003e relayer.max_balance {\n        return Err(RelayerError::AmountTooLow);\n    }\n    relayer.min_balance = new_min;\n    RelayerEvent::MinBalanceUpdated { new_min }.emit();\n    Ok(())\n}\n\npub fn set_max_balance(relayer: \u0026mut Relayer, new_max: u128) -\u003e Result\u003c(), RelayerError\u003e {\n    let caller = env::predecessor_account_id();\n    if !relayer.is_manager(\u0026caller) {\n        return Err(RelayerError::Unauthorized);\n    }\n    if new_max \u003c relayer.min_balance {\n        return Err(RelayerError::AmountTooLow);\n    }\n    relayer.max_balance = new_max;\n    RelayerEvent::MaxBalanceUpdated { new_max }.emit();\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","code","contracts","relayer-onsocial","src","balance.rs"],"content":"use crate::errors::RelayerError;\nuse crate::state::Relayer;\nuse near_sdk::{env, NearToken, Promise};\n\npub fn deposit(relayer: \u0026mut Relayer) -\u003e Result\u003c(), RelayerError\u003e {\n    let deposit = env::attached_deposit().as_yoctonear();\n    let balance = env::account_balance().as_yoctonear() + deposit;\n    if balance \u003e relayer.max_balance {\n        let excess = balance - relayer.max_balance;\n        Promise::new(relayer.offload_recipient.clone()).transfer(NearToken::from_yoctonear(excess));\n    }\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","code","contracts","relayer-onsocial","src","errors.rs"],"content":"use near_sdk::borsh::{BorshDeserialize, BorshSerialize};\nuse near_sdk::{env, FunctionError};\n\n#[derive(Debug, PartialEq, BorshSerialize, BorshDeserialize)]\npub enum RelayerError {\n    Unauthorized,\n    InsufficientBalance,\n    InvalidNonce,\n    InvalidAccountId,\n    AmountTooLow,\n    InvalidSignature,\n    InsufficientDeposit,\n    FeeTooLow,\n    InsufficientSignatures,\n    MissingInput,\n}\n\nimpl FunctionError for RelayerError {\n    fn panic(\u0026self) -\u003e ! {\n        env::panic_str(\u0026format!(\"RelayerError: {:?}\", self))\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","code","contracts","relayer-onsocial","src","events.rs"],"content":"use near_sdk::json_types::U128;\nuse near_sdk::{near, AccountId};\n\n#[near(event_json(standard = \"nep297\"))]\npub enum RelayerEvent {\n    #[event_version(\"1.0.0\")]\n    LowBalance { balance: u128 },\n    #[event_version(\"1.0.0\")]\n    LowGas { remaining_gas: u64 },\n    #[event_version(\"1.0.0\")]\n    AccountSponsored { account_id: AccountId },\n    #[event_version(\"1.0.0\")]\n    AuthAdded {\n        auth_account: AccountId,\n        key_hash: String,\n    },\n    #[event_version(\"1.0.0\")]\n    AuthRemoved {\n        auth_account: AccountId,\n        key_hash: String,\n    },\n    #[event_version(\"1.0.0\")]\n    CrossChainSignatureResult {\n        chain: String,\n        request_id: u64,\n        result: Vec\u003cu8\u003e,\n    },\n    #[event_version(\"1.0.0\")]\n    BridgeResult {\n        sender_id: AccountId,\n        action_type: String,\n        result: Vec\u003cu8\u003e,\n    },\n    #[event_version(\"1.0.0\")]\n    BridgeTransferInitiated {\n        token: String,\n        amount: U128,\n        destination_chain: String,\n        recipient: String,\n        sender: AccountId,\n        nonce: u64,\n    },\n    #[event_version(\"1.0.0\")]\n    BridgeTransferCompleted {\n        token: String,\n        amount: U128,\n        destination_chain: String,\n        recipient: String,\n        sender: AccountId,\n        signature: Vec\u003cu8\u003e,\n    },\n    #[event_version(\"1.0.0\")]\n    BridgeTransferFailed {\n        token: String,\n        amount: U128,\n        destination_chain: String,\n        recipient: String,\n        sender: AccountId,\n        nonce: u64,\n    },\n    #[event_version(\"1.0.0\")]\n    OffloadRecipientUpdated { new_recipient: AccountId },\n    #[event_version(\"1.0.0\")]\n    SponsorAmountUpdated { new_amount: u128 },\n    #[event_version(\"1.0.0\")]\n    SponsorGasUpdated { new_gas: u64 },\n    #[event_version(\"1.0.0\")]\n    CrossContractGasUpdated { new_gas: u64 },\n    #[event_version(\"1.0.0\")]\n    MigrationGasUpdated { new_gas: u64 },\n    #[event_version(\"1.0.0\")]\n    OmniLockerContractUpdated { new_locker_contract: AccountId },\n    #[event_version(\"1.0.0\")]\n    ChainMpcMappingAdded {\n        chain: String,\n        mpc_contract: AccountId,\n    },\n    #[event_version(\"1.0.0\")]\n    ChainMpcMappingRemoved { chain: String },\n    #[event_version(\"1.0.0\")]\n    ChunkSizeUpdated { new_size: usize },\n    #[event_version(\"1.0.0\")]\n    AuthContractUpdated { new_auth_contract: AccountId },\n    #[event_version(\"1.0.0\")]\n    FtWrapperContractUpdated { new_ft_wrapper_contract: AccountId },\n    #[event_version(\"1.0.0\")]\n    MinBalanceUpdated { new_min: u128 },\n    #[event_version(\"1.0.0\")]\n    MaxBalanceUpdated { new_max: u128 },\n    #[event_version(\"1.0.0\")]\n    BaseFeeUpdated { new_fee: u128 },\n    #[event_version(\"1.0.0\")]\n    FeeCharged {\n        action: String,\n        fee: u128,\n        sender: AccountId,\n    },\n    #[event_version(\"1.0.0\")]\n    ManagerChanged {\n        old_manager: AccountId,\n        new_manager: AccountId,\n        timestamp: u64,\n    },\n    #[event_version(\"1.0.0\")]\n    ContractUpgraded { manager: AccountId, timestamp: u64 },\n    #[event_version(\"1.0.0\")]\n    StateMigrated {\n        old_version: String,\n        new_version: String,\n    },\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","code","contracts","relayer-onsocial","src","lib.rs"],"content":"use crate::errors::RelayerError;\nuse crate::events::RelayerEvent;\nuse crate::state::Relayer;\nuse crate::types::{Action, SignedDelegateAction};\nuse near_sdk::json_types::U128;\nuse near_sdk::{borsh, PanicOnDefault};\nuse near_sdk::{\n    env, ext_contract, near, AccountId, Gas, NearToken, Promise, PromiseError, PublicKey,\n};\n\nmod admin;\nmod balance;\nmod errors;\nmod events;\nmod relay;\nmod sponsor;\nmod state;\nmod state_versions;\nmod types;\n\n#[ext_contract(ext_self)]\npub trait SelfCallback {\n    fn handle_mpc_signature(\n        \u0026mut self,\n        chain: String,\n        request_id: u64,\n        result: Vec\u003cu8\u003e,\n        #[callback_result] call_result: Result\u003c(), PromiseError\u003e,\n    );\n    fn handle_bridge_result(\n        \u0026mut self,\n        sender_id: AccountId,\n        action_type: String,\n        result: Vec\u003cu8\u003e,\n        #[callback_result] call_result: Result\u003c(), PromiseError\u003e,\n    );\n    fn handle_bridge_transfer_result(\n        \u0026mut self,\n        sender_id: AccountId,\n        token: String,\n        amount: U128,\n        destination_chain: String,\n        recipient: String,\n        signature: Vec\u003cu8\u003e,\n        #[callback_result] call_result: Result\u003c(), PromiseError\u003e,\n    );\n    #[handle_result]\n    fn handle_auth_result(\n        \u0026mut self,\n        sender_id: AccountId,\n        signed_delegate: SignedDelegateAction,\n        is_authorized: bool,\n    ) -\u003e Result\u003cPromise, RelayerError\u003e;\n    fn handle_registration(\n        \u0026mut self,\n        account_id: AccountId,\n        token: String,\n        is_sender: bool,\n        is_registered: bool,\n    ) -\u003e Promise;\n}\n\n#[ext_contract(ext_auth)]\npub trait AuthContract {\n    fn is_authorized(\n        \u0026self,\n        account_id: AccountId,\n        public_key: PublicKey,\n        signatures: Option\u003cVec\u003cVec\u003cu8\u003e\u003e\u003e,\n    ) -\u003e bool;\n    fn register_key(\n        \u0026mut self,\n        account_id: AccountId,\n        public_key: PublicKey,\n        expiration_days: Option\u003cu32\u003e,\n        is_multi_sig: bool,\n        multi_sig_threshold: Option\u003cu32\u003e,\n    );\n    fn remove_key(\u0026mut self, account_id: AccountId, public_key: PublicKey);\n}\n\n#[ext_contract(ext_ft_wrapper)]\npub trait FtWrapperContract {\n    fn storage_deposit(\u0026mut self, token: String, account_id: AccountId, deposit: U128);\n    fn ft_transfer(\n        \u0026mut self,\n        token: String,\n        receiver_id: AccountId,\n        amount: U128,\n        memo: Option\u003cString\u003e,\n    );\n    fn ft_balance_of(\u0026self, token: String, account_id: AccountId) -\u003e U128;\n    fn is_registered(\u0026self, token: String, account_id: AccountId) -\u003e bool;\n}\n\n#[ext_contract(ext_omi_locker)]\npub trait OmniLocker {\n    fn lock(\u0026mut self, token: String, amount: U128, destination_chain: String, recipient: String);\n}\n\n#[ext_contract(ext_mpc)]\npub trait MpcContract {\n    fn get_nonce(\u0026self, account_id: AccountId, tx_hash: String) -\u003e u64;\n}\n\n#[near(contract_state)]\n#[derive(PanicOnDefault)]\npub struct OnSocialRelayer {\n    relayer: Relayer,\n}\n\n#[near]\nimpl OnSocialRelayer {\n    #[init]\n    pub fn new(\n        offload_recipient: AccountId,\n        auth_contract: AccountId,\n        ft_wrapper_contract: AccountId,\n    ) -\u003e Self {\n        Self {\n            relayer: Relayer::new(\n                env::predecessor_account_id(),\n                offload_recipient,\n                auth_contract,\n                ft_wrapper_contract,\n            ),\n        }\n    }\n\n    #[payable]\n    pub fn deposit(\u0026mut self) {\n        balance::deposit(\u0026mut self.relayer).expect(\"Deposit failed\");\n    }\n\n    #[handle_result]\n    pub fn relay_meta_transaction(\n        \u0026mut self,\n        #[serializer(borsh)] signed_delegate: SignedDelegateAction,\n    ) -\u003e Result\u003cPromise, RelayerError\u003e {\n        relay::relay_meta_transaction(\u0026mut self.relayer, signed_delegate)\n    }\n\n    #[handle_result]\n    pub fn relay_meta_transactions(\n        \u0026mut self,\n        #[serializer(borsh)] signed_delegates: Vec\u003cSignedDelegateAction\u003e,\n    ) -\u003e Result\u003cVec\u003cPromise\u003e, RelayerError\u003e {\n        relay::relay_meta_transactions(\u0026mut self.relayer, signed_delegates)\n    }\n\n    #[handle_result]\n    pub fn relay_chunked_meta_transactions(\n        \u0026mut self,\n        #[serializer(borsh)] signed_delegates: Vec\u003cSignedDelegateAction\u003e,\n    ) -\u003e Result\u003cVec\u003cPromise\u003e, RelayerError\u003e {\n        relay::relay_chunked_meta_transactions(\u0026mut self.relayer, signed_delegates)\n    }\n\n    #[handle_result]\n    pub fn sponsor_account(\n        \u0026mut self,\n        #[serializer(borsh)] args: Vec\u003cu8\u003e,\n    ) -\u003e Result\u003cPromise, RelayerError\u003e {\n        env::log_str(\u0026format!(\"Raw args: {:?}\", args));\n        let (new_account_id, public_key, is_multi_sig, multi_sig_threshold): (\n            AccountId,\n            PublicKey,\n            bool,\n            Option\u003cu32\u003e,\n        ) = borsh::from_slice(\u0026args).map_err(|e| {\n            env::log_str(\u0026format!(\"Deserialization failed: {:?}\", e));\n            RelayerError::InvalidNonce\n        })?;\n        env::log_str(\u0026format!(\n            \"Deserialized: {} {:?}\",\n            new_account_id, public_key\n        ));\n        sponsor::sponsor_account_with_registrar(\n            \u0026mut self.relayer,\n            new_account_id,\n            public_key,\n            is_multi_sig,\n            multi_sig_threshold,\n        )\n    }\n\n    #[handle_result]\n    pub fn sponsor_account_signed(\n        \u0026mut self,\n        #[serializer(borsh)] signed_delegate: SignedDelegateAction,\n    ) -\u003e Result\u003cPromise, RelayerError\u003e {\n        sponsor::sponsor_account_signed(\u0026mut self.relayer, signed_delegate)\n    }\n\n    #[handle_result]\n    pub fn register_existing_account(\n        \u0026mut self,\n        account_id: AccountId,\n        public_key: PublicKey,\n        expiration_days: Option\u003cu32\u003e,\n        is_multi_sig: bool,\n        multi_sig_threshold: Option\u003cu32\u003e,\n    ) -\u003e Result\u003c(), RelayerError\u003e {\n        let initial_storage = env::storage_usage();\n        let result = admin::register_existing_account(\n            \u0026mut self.relayer,\n            account_id,\n            public_key,\n            expiration_days,\n            is_multi_sig,\n            multi_sig_threshold,\n        );\n        let storage_used = env::storage_usage() - initial_storage;\n        let storage_cost = storage_used as u128 * env::storage_byte_cost().as_yoctonear();\n        if env::account_balance().as_yoctonear() \u003c self.relayer.min_balance + storage_cost {\n            RelayerEvent::LowBalance {\n                balance: env::account_balance().as_yoctonear(),\n            }\n            .emit();\n            return Err(RelayerError::InsufficientBalance);\n        }\n        env::log_str(\u0026format!(\n            \"register_existing_account: storage_used={} bytes, storage_cost={} yoctoNEAR\",\n            storage_used, storage_cost\n        ));\n        result\n    }\n\n    #[handle_result]\n    pub fn remove_key(\n        \u0026mut self,\n        account_id: AccountId,\n        public_key: PublicKey,\n    ) -\u003e Result\u003c(), RelayerError\u003e {\n        let initial_storage = env::storage_usage();\n        let result = admin::remove_key(\u0026mut self.relayer, account_id, public_key);\n        let storage_used = env::storage_usage() - initial_storage;\n        let storage_cost = storage_used as u128 * env::storage_byte_cost().as_yoctonear();\n        if env::account_balance().as_yoctonear() \u003c self.relayer.min_balance + storage_cost {\n            RelayerEvent::LowBalance {\n                balance: env::account_balance().as_yoctonear(),\n            }\n            .emit();\n            return Err(RelayerError::InsufficientBalance);\n        }\n        env::log_str(\u0026format!(\n            \"remove_key: storage_used={} bytes, storage_cost={} yoctoNEAR\",\n            storage_used, storage_cost\n        ));\n        result\n    }\n\n    #[handle_result]\n    pub fn set_offload_recipient(\u0026mut self, new_recipient: AccountId) -\u003e Result\u003c(), RelayerError\u003e {\n        let initial_storage = env::storage_usage();\n        let result = admin::set_offload_recipient(\u0026mut self.relayer, new_recipient);\n        let storage_used = env::storage_usage() - initial_storage;\n        let storage_cost = storage_used as u128 * env::storage_byte_cost().as_yoctonear();\n        if env::account_balance().as_yoctonear() \u003c self.relayer.min_balance + storage_cost {\n            RelayerEvent::LowBalance {\n                balance: env::account_balance().as_yoctonear(),\n            }\n            .emit();\n            return Err(RelayerError::InsufficientBalance);\n        }\n        env::log_str(\u0026format!(\n            \"set_offload_recipient: storage_used={} bytes, storage_cost={} yoctoNEAR\",\n            storage_used, storage_cost\n        ));\n        result\n    }\n\n    #[handle_result]\n    pub fn set_sponsor_amount(\u0026mut self, new_amount: U128) -\u003e Result\u003c(), RelayerError\u003e {\n        let initial_storage = env::storage_usage();\n        let result = admin::set_sponsor_amount(\u0026mut self.relayer, new_amount.0);\n        let storage_used = env::storage_usage() - initial_storage;\n        let storage_cost = storage_used as u128 * env::storage_byte_cost().as_yoctonear();\n        if env::account_balance().as_yoctonear() \u003c self.relayer.min_balance + storage_cost {\n            RelayerEvent::LowBalance {\n                balance: env::account_balance().as_yoctonear(),\n            }\n            .emit();\n            return Err(RelayerError::InsufficientBalance);\n        }\n        env::log_str(\u0026format!(\n            \"set_sponsor_amount: storage_used={} bytes, storage_cost={} yoctoNEAR\",\n            storage_used, storage_cost\n        ));\n        result\n    }\n\n    #[handle_result]\n    pub fn set_sponsor_gas(\u0026mut self, new_gas: u64) -\u003e Result\u003c(), RelayerError\u003e {\n        let initial_storage = env::storage_usage();\n        let result = admin::set_sponsor_gas(\u0026mut self.relayer, new_gas);\n        let storage_used = env::storage_usage() - initial_storage;\n        let storage_cost = storage_used as u128 * env::storage_byte_cost().as_yoctonear();\n        if env::account_balance().as_yoctonear() \u003c self.relayer.min_balance + storage_cost {\n            RelayerEvent::LowBalance {\n                balance: env::account_balance().as_yoctonear(),\n            }\n            .emit();\n            return Err(RelayerError::InsufficientBalance);\n        }\n        env::log_str(\u0026format!(\n            \"set_sponsor_gas: storage_used={} bytes, storage_cost={} yoctoNEAR\",\n            storage_used, storage_cost\n        ));\n        result\n    }\n\n    #[handle_result]\n    pub fn set_cross_contract_gas(\u0026mut self, new_gas: u64) -\u003e Result\u003c(), RelayerError\u003e {\n        let initial_storage = env::storage_usage();\n        let result = admin::set_cross_contract_gas(\u0026mut self.relayer, new_gas);\n        let storage_used = env::storage_usage() - initial_storage;\n        let storage_cost = storage_used as u128 * env::storage_byte_cost().as_yoctonear();\n        if env::account_balance().as_yoctonear() \u003c self.relayer.min_balance + storage_cost {\n            RelayerEvent::LowBalance {\n                balance: env::account_balance().as_yoctonear(),\n            }\n            .emit();\n            return Err(RelayerError::InsufficientBalance);\n        }\n        env::log_str(\u0026format!(\n            \"set_cross_contract_gas: storage_used={} bytes, storage_cost={} yoctoNEAR\",\n            storage_used, storage_cost\n        ));\n        result\n    }\n\n    #[handle_result]\n    pub fn set_migration_gas(\u0026mut self, new_gas: u64) -\u003e Result\u003c(), RelayerError\u003e {\n        let initial_storage = env::storage_usage();\n        let result = admin::set_migration_gas(\u0026mut self.relayer, new_gas);\n        let storage_used = env::storage_usage() - initial_storage;\n        let storage_cost = storage_used as u128 * env::storage_byte_cost().as_yoctonear();\n        if env::account_balance().as_yoctonear() \u003c self.relayer.min_balance + storage_cost {\n            RelayerEvent::LowBalance {\n                balance: env::account_balance().as_yoctonear(),\n            }\n            .emit();\n            return Err(RelayerError::InsufficientBalance);\n        }\n        env::log_str(\u0026format!(\n            \"set_migration_gas: storage_used={} bytes, storage_cost={} yoctoNEAR\",\n            storage_used, storage_cost\n        ));\n        result\n    }\n\n    #[handle_result]\n    pub fn set_omni_locker_contract(\n        \u0026mut self,\n        new_locker_contract: AccountId,\n    ) -\u003e Result\u003c(), RelayerError\u003e {\n        let initial_storage = env::storage_usage();\n        let result = admin::set_omni_locker_contract(\u0026mut self.relayer, new_locker_contract);\n        let storage_used = env::storage_usage() - initial_storage;\n        let storage_cost = storage_used as u128 * env::storage_byte_cost().as_yoctonear();\n        if env::account_balance().as_yoctonear() \u003c self.relayer.min_balance + storage_cost {\n            RelayerEvent::LowBalance {\n                balance: env::account_balance().as_yoctonear(),\n            }\n            .emit();\n            return Err(RelayerError::InsufficientBalance);\n        }\n        env::log_str(\u0026format!(\n            \"set_omni_locker_contract: storage_used={} bytes, storage_cost={} yoctoNEAR\",\n            storage_used, storage_cost\n        ));\n        result\n    }\n\n    #[handle_result]\n    pub fn add_chain_mpc_mapping(\n        \u0026mut self,\n        chain: String,\n        mpc_contract: AccountId,\n    ) -\u003e Result\u003c(), RelayerError\u003e {\n        let initial_storage = env::storage_usage();\n        let result = admin::add_chain_mpc_mapping(\u0026mut self.relayer, chain, mpc_contract);\n        let storage_used = env::storage_usage() - initial_storage;\n        let storage_cost = storage_used as u128 * env::storage_byte_cost().as_yoctonear();\n        if env::account_balance().as_yoctonear() \u003c self.relayer.min_balance + storage_cost {\n            RelayerEvent::LowBalance {\n                balance: env::account_balance().as_yoctonear(),\n            }\n            .emit();\n            return Err(RelayerError::InsufficientBalance);\n        }\n        env::log_str(\u0026format!(\n            \"add_chain_mpc_mapping: storage_used={} bytes, storage_cost={} yoctoNEAR\",\n            storage_used, storage_cost\n        ));\n        result\n    }\n\n    #[handle_result]\n    pub fn remove_chain_mpc_mapping(\u0026mut self, chain: String) -\u003e Result\u003c(), RelayerError\u003e {\n        let initial_storage = env::storage_usage();\n        let result = admin::remove_chain_mpc_mapping(\u0026mut self.relayer, chain);\n        let storage_used = env::storage_usage() - initial_storage;\n        let storage_cost = storage_used as u128 * env::storage_byte_cost().as_yoctonear();\n        if env::account_balance().as_yoctonear() \u003c self.relayer.min_balance + storage_cost {\n            RelayerEvent::LowBalance {\n                balance: env::account_balance().as_yoctonear(),\n            }\n            .emit();\n            return Err(RelayerError::InsufficientBalance);\n        }\n        env::log_str(\u0026format!(\n            \"remove_chain_mpc_mapping: storage_used={} bytes, storage_cost={} yoctoNEAR\",\n            storage_used, storage_cost\n        ));\n        result\n    }\n\n    #[handle_result]\n    pub fn set_chunk_size(\u0026mut self, new_size: usize) -\u003e Result\u003c(), RelayerError\u003e {\n        let initial_storage = env::storage_usage();\n        let result = admin::set_chunk_size(\u0026mut self.relayer, new_size);\n        let storage_used = env::storage_usage() - initial_storage;\n        let storage_cost = storage_used as u128 * env::storage_byte_cost().as_yoctonear();\n        if env::account_balance().as_yoctonear() \u003c self.relayer.min_balance + storage_cost {\n            RelayerEvent::LowBalance {\n                balance: env::account_balance().as_yoctonear(),\n            }\n            .emit();\n            return Err(RelayerError::InsufficientBalance);\n        }\n        env::log_str(\u0026format!(\n            \"set_chunk_size: storage_used={} bytes, storage_cost={} yoctoNEAR\",\n            storage_used, storage_cost\n        ));\n        result\n    }\n\n    #[handle_result]\n    pub fn set_auth_contract(\u0026mut self, new_auth_contract: AccountId) -\u003e Result\u003c(), RelayerError\u003e {\n        let initial_storage = env::storage_usage();\n        let result = admin::set_auth_contract(\u0026mut self.relayer, new_auth_contract);\n        let storage_used = env::storage_usage() - initial_storage;\n        let storage_cost = storage_used as u128 * env::storage_byte_cost().as_yoctonear();\n        if env::account_balance().as_yoctonear() \u003c self.relayer.min_balance + storage_cost {\n            RelayerEvent::LowBalance {\n                balance: env::account_balance().as_yoctonear(),\n            }\n            .emit();\n            return Err(RelayerError::InsufficientBalance);\n        }\n        env::log_str(\u0026format!(\n            \"set_auth_contract: storage_used={} bytes, storage_cost={} yoctoNEAR\",\n            storage_used, storage_cost\n        ));\n        result\n    }\n\n    #[handle_result]\n    pub fn set_ft_wrapper_contract(\n        \u0026mut self,\n        new_ft_wrapper_contract: AccountId,\n    ) -\u003e Result\u003c(), RelayerError\u003e {\n        let initial_storage = env::storage_usage();\n        let result = admin::set_ft_wrapper_contract(\u0026mut self.relayer, new_ft_wrapper_contract);\n        let storage_used = env::storage_usage() - initial_storage;\n        let storage_cost = storage_used as u128 * env::storage_byte_cost().as_yoctonear();\n        if env::account_balance().as_yoctonear() \u003c self.relayer.min_balance + storage_cost {\n            RelayerEvent::LowBalance {\n                balance: env::account_balance().as_yoctonear(),\n            }\n            .emit();\n            return Err(RelayerError::InsufficientBalance);\n        }\n        env::log_str(\u0026format!(\n            \"set_ft_wrapper_contract: storage_used={} bytes, storage_cost={} yoctoNEAR\",\n            storage_used, storage_cost\n        ));\n        result\n    }\n\n    #[handle_result]\n    pub fn set_base_fee(\n        \u0026mut self,\n        new_fee: U128,\n        signatures: Option\u003cVec\u003cVec\u003cu8\u003e\u003e\u003e,\n    ) -\u003e Result\u003c(), RelayerError\u003e {\n        let initial_storage = env::storage_usage();\n        let result = admin::set_base_fee(\u0026mut self.relayer, new_fee.0, signatures);\n        let storage_used = env::storage_usage() - initial_storage;\n        let storage_cost = storage_used as u128 * env::storage_byte_cost().as_yoctonear();\n        if env::account_balance().as_yoctonear() \u003c self.relayer.min_balance + storage_cost {\n            RelayerEvent::LowBalance {\n                balance: env::account_balance().as_yoctonear(),\n            }\n            .emit();\n            return Err(RelayerError::InsufficientBalance);\n        }\n        env::log_str(\u0026format!(\n            \"set_base_fee: storage_used={} bytes, storage_cost={} yoctoNEAR\",\n            storage_used, storage_cost\n        ));\n        result\n    }\n\n    #[handle_result]\n    pub fn set_manager(\u0026mut self, new_manager: AccountId) -\u003e Result\u003c(), RelayerError\u003e {\n        let initial_storage = env::storage_usage();\n        let result = admin::set_manager(\u0026mut self.relayer, new_manager);\n        let storage_used = env::storage_usage() - initial_storage;\n        let storage_cost = storage_used as u128 * env::storage_byte_cost().as_yoctonear();\n        if env::account_balance().as_yoctonear() \u003c self.relayer.min_balance + storage_cost {\n            RelayerEvent::LowBalance {\n                balance: env::account_balance().as_yoctonear(),\n            }\n            .emit();\n            return Err(RelayerError::InsufficientBalance);\n        }\n        env::log_str(\u0026format!(\n            \"set_manager: storage_used={} bytes, storage_cost={} yoctoNEAR\",\n            storage_used, storage_cost\n        ));\n        result\n    }\n\n    #[handle_result]\n    pub fn update_contract(\u0026mut self) -\u003e Result\u003cPromise, RelayerError\u003e {\n        let caller = env::predecessor_account_id();\n        if !self.relayer.is_manager(\u0026caller) {\n            return Err(RelayerError::Unauthorized);\n        }\n        let code = env::input().ok_or(RelayerError::MissingInput)?.to_vec();\n        RelayerEvent::ContractUpgraded {\n            manager: caller,\n            timestamp: env::block_timestamp_ms(),\n        }\n        .emit();\n        let promise = Promise::new(env::current_account_id())\n            .deploy_contract(code)\n            .function_call(\n                \"migrate\".to_string(),\n                vec![],\n                NearToken::from_yoctonear(0),\n                Gas::from_tgas(self.relayer.migration_gas),\n            );\n        env::log_str(\u0026format!(\n            \"Gas used in update_contract: {} TGas\",\n            env::used_gas().as_tgas()\n        ));\n        Ok(promise)\n    }\n\n    #[handle_result]\n    pub fn set_min_balance(\u0026mut self, new_min: U128) -\u003e Result\u003c(), RelayerError\u003e {\n        let initial_storage = env::storage_usage();\n        let result = admin::set_min_balance(\u0026mut self.relayer, new_min.0);\n        let storage_used = env::storage_usage() - initial_storage;\n        let storage_cost = storage_used as u128 * env::storage_byte_cost().as_yoctonear();\n        if env::account_balance().as_yoctonear() \u003c self.relayer.min_balance + storage_cost {\n            RelayerEvent::LowBalance {\n                balance: env::account_balance().as_yoctonear(),\n            }\n            .emit();\n            return Err(RelayerError::InsufficientBalance);\n        }\n        env::log_str(\u0026format!(\n            \"set_min_balance: storage_used={} bytes, storage_cost={} yoctoNEAR\",\n            storage_used, storage_cost\n        ));\n        result\n    }\n\n    #[handle_result]\n    pub fn set_max_balance(\u0026mut self, new_max: U128) -\u003e Result\u003c(), RelayerError\u003e {\n        let initial_storage = env::storage_usage();\n        let result = admin::set_max_balance(\u0026mut self.relayer, new_max.0);\n        let storage_used = env::storage_usage() - initial_storage;\n        let storage_cost = storage_used as u128 * env::storage_byte_cost().as_yoctonear();\n        if env::account_balance().as_yoctonear() \u003c self.relayer.min_balance + storage_cost {\n            RelayerEvent::LowBalance {\n                balance: env::account_balance().as_yoctonear(),\n            }\n            .emit();\n            return Err(RelayerError::InsufficientBalance);\n        }\n        env::log_str(\u0026format!(\n            \"set_max_balance: storage_used={} bytes, storage_cost={} yoctoNEAR\",\n            storage_used, storage_cost\n        ));\n        result\n    }\n\n    pub fn get_balance(\u0026self) -\u003e U128 {\n        U128(env::account_balance().as_yoctonear())\n    }\n\n    pub fn get_min_balance(\u0026self) -\u003e U128 {\n        U128(self.relayer.min_balance)\n    }\n\n    pub fn get_max_balance(\u0026self) -\u003e U128 {\n        U128(self.relayer.max_balance)\n    }\n\n    pub fn get_sponsor_amount(\u0026self) -\u003e U128 {\n        U128(self.relayer.sponsor_amount)\n    }\n\n    pub fn get_sponsor_gas(\u0026self) -\u003e u64 {\n        self.relayer.sponsor_gas\n    }\n\n    pub fn get_cross_contract_gas(\u0026self) -\u003e u64 {\n        self.relayer.cross_contract_gas\n    }\n\n    pub fn get_migration_gas(\u0026self) -\u003e u64 {\n        self.relayer.migration_gas\n    }\n\n    pub fn get_omni_locker_contract(\u0026self) -\u003e AccountId {\n        self.relayer\n            .omni_locker_contract\n            .get()\n            .clone()\n            .map(|x| x.clone())\n            .unwrap_or_else(|| env::current_account_id())\n    }\n\n    pub fn get_chunk_size(\u0026self) -\u003e usize {\n        self.relayer.chunk_size\n    }\n\n    pub fn get_auth_contract(\u0026self) -\u003e AccountId {\n        self.relayer.auth_contract.clone()\n    }\n\n    pub fn get_ft_wrapper_contract(\u0026self) -\u003e AccountId {\n        self.relayer.ft_wrapper_contract.clone()\n    }\n\n    pub fn get_base_fee(\u0026self) -\u003e U128 {\n        U128(self.relayer.base_fee)\n    }\n}\n\n#[near]\nimpl OnSocialRelayer {\n    #[private]\n    pub fn handle_mpc_signature(\n        \u0026mut self,\n        chain: String,\n        request_id: u64,\n        result: Vec\u003cu8\u003e,\n        #[callback_result] call_result: Result\u003c(), PromiseError\u003e,\n    ) {\n        if call_result.is_err() {\n            env::log_str(\u0026format!(\n                \"MPC signature failed for chain {} request_id {}\",\n                chain, request_id\n            ));\n            // No state changes to revert, just emit event\n            RelayerEvent::CrossChainSignatureResult {\n                chain,\n                request_id,\n                result: vec![],\n            }\n            .emit();\n            return;\n        }\n        RelayerEvent::CrossChainSignatureResult {\n            chain,\n            request_id,\n            result,\n        }\n        .emit();\n    }\n\n    #[private]\n    pub fn handle_bridge_result(\n        \u0026mut self,\n        sender_id: AccountId,\n        action_type: String,\n        result: Vec\u003cu8\u003e,\n        #[callback_result] call_result: Result\u003c(), PromiseError\u003e,\n    ) {\n        if call_result.is_err() {\n            env::log_str(\u0026format!(\n                \"Bridge action {} failed for sender {}\",\n                action_type, sender_id\n            ));\n            // No state changes to revert, just emit event\n            RelayerEvent::BridgeResult {\n                sender_id,\n                action_type,\n                result: vec![],\n            }\n            .emit();\n            return;\n        }\n        RelayerEvent::BridgeResult {\n            sender_id,\n            action_type,\n            result,\n        }\n        .emit();\n    }\n\n    #[private]\n    pub fn handle_bridge_transfer_result(\n        \u0026mut self,\n        sender_id: AccountId,\n        token: String,\n        amount: U128,\n        destination_chain: String,\n        recipient: String,\n        signature: Vec\u003cu8\u003e,\n        #[callback_result] call_result: Result\u003c(), PromiseError\u003e,\n    ) {\n        let nonce = self.relayer.get_pending_nonce(\u0026destination_chain);\n        if call_result.is_err() {\n            env::log_str(\u0026format!(\n                \"Bridge transfer failed for sender {} to chain {}\",\n                sender_id, destination_chain\n            ));\n            // Revert pending transfer and refund fee\n            if let Some(pending) = self\n                .relayer\n                .revert_pending_transfer(\u0026destination_chain, nonce)\n            {\n                if pending.fee \u003e 0 {\n                    Promise::new(sender_id.clone())\n                        .transfer(NearToken::from_yoctonear(pending.fee));\n                    env::log_str(\u0026format!(\n                        \"Refunded {} yoctoNEAR to {}\",\n                        pending.fee, sender_id\n                    ));\n                }\n            }\n            RelayerEvent::BridgeTransferFailed {\n                token,\n                amount,\n                destination_chain,\n                recipient,\n                sender: sender_id,\n                nonce,\n            }\n            .emit();\n            return;\n        }\n        // Confirm transfer and update nonce\n        self.relayer\n            .confirm_pending_transfer(\u0026destination_chain, nonce);\n        RelayerEvent::BridgeTransferCompleted {\n            token,\n            amount,\n            destination_chain,\n            recipient,\n            sender: sender_id,\n            signature,\n        }\n        .emit();\n    }\n\n    #[private]\n    #[handle_result]\n    pub fn handle_auth_result(\n        \u0026mut self,\n        sender_id: AccountId,\n        signed_delegate: SignedDelegateAction,\n        #[callback_unwrap] is_authorized: bool,\n    ) -\u003e Result\u003cPromise, RelayerError\u003e {\n        if !is_authorized {\n            return Err(RelayerError::Unauthorized);\n        }\n        let tx_hash = env::sha256(\n            \u0026borsh::to_vec(\u0026signed_delegate.delegate_action)\n                .map_err(|_| RelayerError::InvalidNonce)?,\n        );\n        relay::verify_signature(\u0026signed_delegate, \u0026tx_hash)?;\n        let delegate = signed_delegate.delegate_action;\n        let action = delegate.actions.first().unwrap();\n        let request_id = env::block_timestamp();\n        let promise = relay::execute_action(\n            \u0026mut self.relayer,\n            action,\n            \u0026sender_id,\n            action.type_name(),\n            Some(request_id),\n        )?;\n        let promise = match action {\n            Action::ChainSignatureRequest { target_chain, .. } =\u003e promise.then(\n                ext_self::ext(env::current_account_id())\n                    .with_static_gas(Gas::from_tgas(self.relayer.cross_contract_gas))\n                    .handle_mpc_signature(target_chain.clone(), request_id, Vec::new()),\n            ),\n            Action::BridgeTransfer {\n                token,\n                amount,\n                destination_chain,\n                recipient,\n                ..\n            } =\u003e promise.then(\n                ext_self::ext(env::current_account_id())\n                    .with_static_gas(Gas::from_tgas(self.relayer.cross_contract_gas))\n                    .handle_bridge_transfer_result(\n                        sender_id.clone(),\n                        token.clone(),\n                        *amount,\n                        destination_chain.clone(),\n                        recipient.clone(),\n                        Vec::new(),\n                    ),\n            ),\n            _ =\u003e promise.then(\n                ext_self::ext(env::current_account_id())\n                    .with_static_gas(Gas::from_tgas(self.relayer.cross_contract_gas))\n                    .handle_bridge_result(\n                        sender_id.clone(),\n                        action.type_name().to_string(),\n                        Vec::new(),\n                    ),\n            ),\n        };\n        Ok(promise)\n    }\n\n    #[private]\n    pub fn handle_registration(\n        \u0026mut self,\n        account_id: AccountId,\n        token: String,\n        _is_sender: bool,\n        #[callback_unwrap] is_registered: bool,\n    ) -\u003e Promise {\n        if !is_registered {\n            ext_ft_wrapper::ext(self.relayer.ft_wrapper_contract.clone())\n                .with_static_gas(Gas::from_tgas(self.relayer.cross_contract_gas))\n                .with_attached_deposit(NearToken::from_yoctonear(1_250_000_000_000_000_000_000))\n                .storage_deposit(token, account_id, U128(1_250_000_000_000_000_000_000))\n        } else {\n            Promise::new(env::current_account_id())\n        }\n    }\n\n    #[private]\n    #[init(ignore_state)]\n    pub fn migrate() -\u003e Self {\n        Self {\n            relayer: Relayer::migrate(),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests;\n","traces":[],"covered":0,"coverable":0},{"path":["/","code","contracts","relayer-onsocial","src","relay.rs"],"content":"use crate::{\n    errors::RelayerError,\n    events::RelayerEvent,\n    ext_auth, ext_ft_wrapper, ext_mpc, ext_omi_locker, ext_self,\n    state::Relayer,\n    types::{Action, SignatureScheme, SignedDelegateAction},\n};\nuse base64::engine::general_purpose::STANDARD as Base64;\nuse base64::Engine;\nuse core::num::NonZeroU128;\nuse ed25519_dalek::{Signature as Ed25519Signature, Verifier, VerifyingKey};\nuse near_crypto::KeyType;\nuse near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};\nuse near_sdk::{env, AccountId, Allowance, Gas, NearToken, Promise};\n\n#[derive(BorshSerialize, BorshDeserialize)]\nstruct SignRequest {\n    payload: Vec\u003cu8\u003e,\n    path: String,\n    key_version: u32,\n    request_id: u64,\n}\n\n#[derive(BorshSerialize, BorshDeserialize)]\nstruct BridgeTransferPayload {\n    token: String,\n    amount: u128,\n    destination_chain: String,\n    recipient: String,\n    sender: AccountId,\n    nonce: u64,\n}\n\npub fn verify_signature(\n    signed_delegate: \u0026SignedDelegateAction,\n    tx_hash: \u0026[u8],\n) -\u003e Result\u003c(), RelayerError\u003e {\n    let payload =\n        borsh::to_vec(\u0026signed_delegate.delegate_action).map_err(|_| RelayerError::InvalidNonce)?;\n    if env::sha256(\u0026payload) != tx_hash {\n        return Err(RelayerError::InvalidSignature);\n    }\n    match signed_delegate.scheme {\n        SignatureScheme::Ed25519 =\u003e {\n            let signature_bytes: [u8; 64] = signed_delegate\n                .signature\n                .clone()\n                .try_into()\n                .map_err(|_| RelayerError::Unauthorized)?;\n            let signature = Ed25519Signature::from_bytes(\u0026signature_bytes);\n            let public_key_bytes = signed_delegate.public_key.as_bytes();\n            if public_key_bytes.len() != 33 || public_key_bytes[0] != KeyType::ED25519 as u8 {\n                return Err(RelayerError::Unauthorized);\n            }\n            let ed25519_key =\n                VerifyingKey::from_bytes(\u0026public_key_bytes[1..33].try_into().unwrap())\n                    .map_err(|_| RelayerError::Unauthorized)?;\n            ed25519_key\n                .verify(\u0026payload, \u0026signature)\n                .map_err(|_| RelayerError::Unauthorized)?;\n        }\n    }\n    Ok(())\n}\n\npub fn relay_meta_transaction(\n    relayer: \u0026mut Relayer,\n    signed_delegate: SignedDelegateAction,\n) -\u003e Result\u003cPromise, RelayerError\u003e {\n    assert!(\n        env::prepaid_gas() \u003e= Gas::from_tgas(250),\n        \"Attach at least 250 TGas\"\n    );\n    if signed_delegate.delegate_action.actions.len() \u003e 1 {\n        return Err(RelayerError::InvalidNonce);\n    }\n    let sender_id = \u0026signed_delegate.delegate_action.sender_id;\n    // Verify signer matches sender_id to prevent intermediary manipulation\n    if env::signer_account_id() != *sender_id {\n        return Err(RelayerError::Unauthorized);\n    }\n    let balance = env::account_balance().as_yoctonear();\n    if balance \u003c relayer.min_balance {\n        RelayerEvent::LowBalance { balance }.emit();\n        return Err(RelayerError::InsufficientBalance);\n    }\n    let tx_hash = env::sha256(\n        \u0026borsh::to_vec(\u0026signed_delegate.delegate_action).map_err(|_| RelayerError::InvalidNonce)?,\n    );\n    let mpc_contract = relayer\n        .chain_mpc_mapping\n        .get(\"testnet\")\n        .cloned()\n        .unwrap_or(\"v1.signer-prod.testnet\".parse().unwrap());\n    let promise = ext_mpc::ext(mpc_contract)\n        .with_static_gas(Gas::from_tgas(relayer.cross_contract_gas))\n        .get_nonce(sender_id.clone(), Base64.encode(tx_hash.clone()))\n        .then(\n            ext_auth::ext(relayer.auth_contract.clone())\n                .with_static_gas(Gas::from_tgas(relayer.cross_contract_gas))\n                .is_authorized(\n                    sender_id.clone(),\n                    signed_delegate.public_key.clone(),\n                    signed_delegate.multi_signatures.clone(),\n                ),\n        )\n        .then(\n            ext_self::ext(env::current_account_id())\n                .with_static_gas(Gas::from_tgas(relayer.cross_contract_gas))\n                .handle_auth_result(sender_id.clone(), signed_delegate.clone(), true),\n        );\n    let remaining_gas = env::prepaid_gas()\n        .as_tgas()\n        .saturating_sub(env::used_gas().as_tgas());\n    // Alert if remaining gas is low\n    if remaining_gas \u003c 50 {\n        RelayerEvent::LowGas { remaining_gas }.emit();\n    }\n    env::log_str(\u0026format!(\n        \"relay_meta_transaction: prepaid={} TGas, used={} TGas, remaining={} TGas\",\n        env::prepaid_gas().as_tgas(),\n        env::used_gas().as_tgas(),\n        remaining_gas\n    ));\n    Ok(promise)\n}\n\npub fn relay_meta_transactions(\n    relayer: \u0026mut Relayer,\n    signed_delegates: Vec\u003cSignedDelegateAction\u003e,\n) -\u003e Result\u003cVec\u003cPromise\u003e, RelayerError\u003e {\n    assert!(\n        env::prepaid_gas() \u003e= Gas::from_tgas(250),\n        \"Attach at least 250 TGas\"\n    );\n    if signed_delegates.is_empty() || signed_delegates.len() \u003e relayer.chunk_size {\n        return Err(RelayerError::InvalidNonce);\n    }\n    let balance = env::account_balance().as_yoctonear();\n    if balance \u003c relayer.min_balance {\n        RelayerEvent::LowBalance { balance }.emit();\n        return Err(RelayerError::InsufficientBalance);\n    }\n    let mut promises: Vec\u003cPromise\u003e = Vec::new();\n    let mpc_contract = relayer\n        .chain_mpc_mapping\n        .get(\"testnet\")\n        .cloned()\n        .unwrap_or(\"v1.signer-prod.testnet\".parse().unwrap());\n    for signed_delegate in signed_delegates {\n        let sender_id = \u0026signed_delegate.delegate_action.sender_id;\n        // Verify signer matches sender_id\n        if env::signer_account_id() != *sender_id {\n            return Err(RelayerError::Unauthorized);\n        }\n        let tx_hash = env::sha256(\n            \u0026borsh::to_vec(\u0026signed_delegate.delegate_action)\n                .map_err(|_| RelayerError::InvalidNonce)?,\n        );\n        let promise = ext_mpc::ext(mpc_contract.clone())\n            .with_static_gas(Gas::from_tgas(relayer.cross_contract_gas))\n            .get_nonce(sender_id.clone(), Base64.encode(tx_hash))\n            .then(\n                ext_auth::ext(relayer.auth_contract.clone())\n                    .with_static_gas(Gas::from_tgas(relayer.cross_contract_gas))\n                    .is_authorized(\n                        sender_id.clone(),\n                        signed_delegate.public_key.clone(),\n                        signed_delegate.multi_signatures.clone(),\n                    ),\n            )\n            .then(\n                ext_self::ext(env::current_account_id())\n                    .with_static_gas(Gas::from_tgas(relayer.cross_contract_gas))\n                    .handle_auth_result(sender_id.clone(), signed_delegate.clone(), true),\n            );\n        promises.push(promise);\n    }\n    let remaining_gas = env::prepaid_gas()\n        .as_tgas()\n        .saturating_sub(env::used_gas().as_tgas());\n    if remaining_gas \u003c 50 {\n        RelayerEvent::LowGas { remaining_gas }.emit();\n    }\n    env::log_str(\u0026format!(\n        \"relay_meta_transactions: prepaid={} TGas, used={} TGas, remaining={} TGas\",\n        env::prepaid_gas().as_tgas(),\n        env::used_gas().as_tgas(),\n        remaining_gas\n    ));\n    Ok(promises)\n}\n\npub fn relay_chunked_meta_transactions(\n    relayer: \u0026mut Relayer,\n    signed_delegates: Vec\u003cSignedDelegateAction\u003e,\n) -\u003e Result\u003cVec\u003cPromise\u003e, RelayerError\u003e {\n    assert!(\n        env::prepaid_gas() \u003e= Gas::from_tgas(250),\n        \"Attach at least 250 TGas\"\n    );\n    if signed_delegates.is_empty() {\n        return Err(RelayerError::InvalidNonce);\n    }\n    let balance = env::account_balance().as_yoctonear();\n    if balance \u003c relayer.min_balance {\n        RelayerEvent::LowBalance { balance }.emit();\n        return Err(RelayerError::InsufficientBalance);\n    }\n    let mpc_contract = relayer\n        .chain_mpc_mapping\n        .get(\"testnet\")\n        .cloned()\n        .unwrap_or(\"v1.signer-prod.testnet\".parse().unwrap());\n    let mut all_promises = Vec::new();\n    for chunk in signed_delegates.chunks(relayer.chunk_size) {\n        let chunk_promises: Vec\u003cPromise\u003e = chunk\n            .iter()\n            .map(|signed_delegate| {\n                let sender_id = \u0026signed_delegate.delegate_action.sender_id;\n                // Verify signer matches sender_id\n                if env::signer_account_id() != *sender_id {\n                    return Promise::new(env::current_account_id()).function_call(\n                        \"panic\".to_string(),\n                        borsh::to_vec(\u0026RelayerError::Unauthorized).unwrap_or_default(),\n                        NearToken::from_yoctonear(0),\n                        Gas::from_tgas(relayer.cross_contract_gas),\n                    );\n                }\n                match borsh::to_vec(\u0026signed_delegate.delegate_action) {\n                    Ok(payload) =\u003e {\n                        let tx_hash = env::sha256(\u0026payload);\n                        ext_mpc::ext(mpc_contract.clone())\n                            .with_static_gas(Gas::from_tgas(relayer.cross_contract_gas))\n                            .get_nonce(sender_id.clone(), Base64.encode(tx_hash))\n                            .then(\n                                ext_auth::ext(relayer.auth_contract.clone())\n                                    .with_static_gas(Gas::from_tgas(relayer.cross_contract_gas))\n                                    .is_authorized(\n                                        sender_id.clone(),\n                                        signed_delegate.public_key.clone(),\n                                        signed_delegate.multi_signatures.clone(),\n                                    ),\n                            )\n                            .then(\n                                ext_self::ext(env::current_account_id())\n                                    .with_static_gas(Gas::from_tgas(relayer.cross_contract_gas))\n                                    .handle_auth_result(\n                                        sender_id.clone(),\n                                        signed_delegate.clone(),\n                                        true,\n                                    ),\n                            )\n                    }\n                    Err(_) =\u003e Promise::new(env::current_account_id()).function_call(\n                        \"panic\".to_string(),\n                        borsh::to_vec(\u0026RelayerError::InvalidNonce).unwrap_or_default(),\n                        NearToken::from_yoctonear(0),\n                        Gas::from_tgas(relayer.cross_contract_gas),\n                    ),\n                }\n            })\n            .collect();\n        all_promises.extend(chunk_promises);\n    }\n    let remaining_gas = env::prepaid_gas()\n        .as_tgas()\n        .saturating_sub(env::used_gas().as_tgas());\n    if remaining_gas \u003c 50 {\n        RelayerEvent::LowGas { remaining_gas }.emit();\n    }\n    env::log_str(\u0026format!(\n        \"relay_chunked_meta_transactions: prepaid={} TGas, used={} TGas, remaining={} TGas\",\n        env::prepaid_gas().as_tgas(),\n        env::used_gas().as_tgas(),\n        remaining_gas\n    ));\n    Ok(all_promises)\n}\n\npub fn execute_action(\n    relayer: \u0026mut Relayer,\n    action: \u0026Action,\n    sender_id: \u0026AccountId,\n    _action_type: \u0026str,\n    request_id: Option\u003cu64\u003e,\n) -\u003e Result\u003cPromise, RelayerError\u003e {\n    assert!(\n        env::prepaid_gas() \u003e= Gas::from_tgas(250),\n        \"Attach at least 250 TGas\"\n    );\n    let initial_storage = env::storage_usage();\n    let mut promise = Promise::new(sender_id.clone());\n    match action {\n        Action::FunctionCall {\n            method_name,\n            args,\n            gas: _,\n            deposit,\n        } =\u003e {\n            promise = promise.function_call(\n                method_name.clone(),\n                args.clone(),\n                NearToken::from_yoctonear(deposit.as_yoctonear()),\n                Gas::from_tgas(relayer.cross_contract_gas),\n            );\n        }\n        Action::Transfer { deposit } =\u003e {\n            promise = promise.transfer(NearToken::from_yoctonear(deposit.as_yoctonear()));\n        }\n        Action::AddKey {\n            public_key,\n            allowance,\n            receiver_id,\n            method_names,\n        } =\u003e {\n            promise = promise.add_access_key_allowance(\n                public_key.clone(),\n                allowance.map_or(Allowance::Unlimited, |t| {\n                    Allowance::Limited(NonZeroU128::new(t.as_yoctonear()).unwrap())\n                }),\n                receiver_id.clone(),\n                method_names.join(\",\"),\n            );\n        }\n        Action::ChainSignatureRequest {\n            target_chain,\n            derivation_path,\n            payload,\n        } =\u003e {\n            let mpc_contract = relayer\n                .chain_mpc_mapping\n                .get(target_chain)\n                .ok_or(RelayerError::InvalidAccountId)?;\n            let request = SignRequest {\n                payload: payload.clone(),\n                path: derivation_path.clone(),\n                key_version: 0,\n                request_id: request_id.ok_or(RelayerError::InvalidNonce)?,\n            };\n            let args = borsh::to_vec(\u0026request).map_err(|_| RelayerError::InvalidAccountId)?;\n            promise = Promise::new(mpc_contract.clone()).function_call(\n                \"sign\".to_string(),\n                args,\n                NearToken::from_yoctonear(1),\n                Gas::from_tgas(relayer.cross_contract_gas),\n            );\n        }\n        Action::FtTransfer {\n            token,\n            receiver_id,\n            amount,\n            memo,\n        } =\u003e {\n            let sender_promise = ext_ft_wrapper::ext(relayer.ft_wrapper_contract.clone())\n                .with_static_gas(Gas::from_tgas(100))\n                .is_registered(token.clone(), sender_id.clone())\n                .then(\n                    ext_self::ext(env::current_account_id())\n                        .with_static_gas(Gas::from_tgas(100))\n                        .handle_registration(sender_id.clone(), token.clone(), true, true),\n                );\n            let receiver_promise = ext_ft_wrapper::ext(relayer.ft_wrapper_contract.clone())\n                .with_static_gas(Gas::from_tgas(100))\n                .is_registered(token.clone(), receiver_id.clone())\n                .then(\n                    ext_self::ext(env::current_account_id())\n                        .with_static_gas(Gas::from_tgas(100))\n                        .handle_registration(receiver_id.clone(), token.clone(), false, true),\n                );\n            promise = sender_promise.then(receiver_promise).then(\n                ext_ft_wrapper::ext(relayer.ft_wrapper_contract.clone())\n                    .with_static_gas(Gas::from_tgas(100))\n                    .ft_transfer(token.clone(), receiver_id.clone(), *amount, memo.clone()),\n            );\n        }\n        Action::BridgeTransfer {\n            token,\n            amount,\n            destination_chain,\n            recipient,\n        } =\u003e {\n            let fee = relayer.base_fee;\n            let balance = env::account_balance().as_yoctonear();\n            // Check if relayer can cover the fee\n            if balance \u003c relayer.min_balance + fee {\n                RelayerEvent::LowBalance { balance }.emit();\n                return Err(RelayerError::InsufficientBalance);\n            }\n            let total_cost = 15_000_000_000_000; // 15 TGas for lock + sign\n            if fee \u003e 0 \u0026\u0026 fee \u003c total_cost / 1_000_000_000_000 * 1_000_000_000_000_000_000_000 {\n                return Err(RelayerError::FeeTooLow);\n            }\n            // Store pending transfer instead of incrementing nonce immediately\n            let nonce = relayer.get_pending_nonce(destination_chain);\n            let lock_promise = ext_omi_locker::ext(\n                relayer\n                    .omni_locker_contract\n                    .get()\n                    .clone()\n                    .map(|x| x.clone())\n                    .unwrap_or_else(|| env::current_account_id()),\n            )\n            .with_static_gas(Gas::from_tgas(relayer.cross_contract_gas))\n            .lock(\n                token.clone(),\n                *amount,\n                destination_chain.clone(),\n                recipient.clone(),\n            );\n            let mpc_contract = relayer\n                .chain_mpc_mapping\n                .get(destination_chain)\n                .ok_or(RelayerError::InvalidNonce)?;\n            let payload = BridgeTransferPayload {\n                token: token.clone(),\n                amount: amount.0,\n                destination_chain: destination_chain.clone(),\n                recipient: recipient.clone(),\n                sender: sender_id.clone(),\n                nonce,\n            };\n            let payload_bytes =\n                borsh::to_vec(\u0026payload).map_err(|_| RelayerError::InvalidAccountId)?;\n            let sign_promise = Promise::new(mpc_contract.clone()).function_call(\n                \"sign\".to_string(),\n                borsh::to_vec(\u0026SignRequest {\n                    payload: payload_bytes,\n                    path: \"\".to_string(),\n                    key_version: 0,\n                    request_id: request_id.unwrap_or(env::block_timestamp()),\n                })\n                .map_err(|_| RelayerError::InvalidAccountId)?,\n                NearToken::from_yoctonear(0),\n                Gas::from_tgas(relayer.cross_contract_gas),\n            );\n            // Store pending transfer\n            relayer.add_pending_transfer(\n                destination_chain.clone(),\n                nonce,\n                sender_id.clone(),\n                token.clone(),\n                *amount,\n                recipient.clone(),\n                fee,\n            );\n            RelayerEvent::BridgeTransferInitiated {\n                token: token.clone(),\n                amount: *amount,\n                destination_chain: destination_chain.clone(),\n                recipient: recipient.clone(),\n                sender: sender_id.clone(),\n                nonce,\n            }\n            .emit();\n            RelayerEvent::FeeCharged {\n                action: \"BridgeTransfer\".to_string(),\n                fee,\n                sender: sender_id.clone(),\n            }\n            .emit();\n            promise = lock_promise.then(sign_promise);\n        }\n    }\n    // Check storage cost\n    let storage_used = env::storage_usage() - initial_storage;\n    let storage_cost = storage_used as u128 * env::storage_byte_cost().as_yoctonear();\n    if env::account_balance().as_yoctonear() \u003c relayer.min_balance + storage_cost {\n        RelayerEvent::LowBalance {\n            balance: env::account_balance().as_yoctonear(),\n        }\n        .emit();\n        return Err(RelayerError::InsufficientBalance);\n    }\n    let remaining_gas = env::prepaid_gas()\n        .as_tgas()\n        .saturating_sub(env::used_gas().as_tgas());\n    if remaining_gas \u003c 50 {\n        RelayerEvent::LowGas { remaining_gas }.emit();\n    }\n    env::log_str(\u0026format!(\n        \"execute_action: prepaid={} TGas, used={} TGas, remaining={} TGas, storage_used={} bytes, storage_cost={} yoctoNEAR\",\n        env::prepaid_gas().as_tgas(),\n        env::used_gas().as_tgas(),\n        remaining_gas,\n        storage_used,\n        storage_cost\n    ));\n    Ok(promise)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","code","contracts","relayer-onsocial","src","sponsor.rs"],"content":"use crate::errors::RelayerError;\nuse crate::events::RelayerEvent;\nuse crate::relay;\nuse crate::types::SignedDelegateAction;\nuse crate::{ext_auth, state::Relayer};\nuse near_sdk::borsh::to_vec;\nuse near_sdk::{env, AccountId, Gas, NearToken, Promise, PublicKey};\n\npub fn sponsor_account_with_registrar(\n    relayer: \u0026mut Relayer,\n    new_account_id: AccountId,\n    public_key: PublicKey,\n    is_multi_sig: bool,\n    multi_sig_threshold: Option\u003cu32\u003e,\n) -\u003e Result\u003cPromise, RelayerError\u003e {\n    let balance = env::account_balance();\n    if balance.as_yoctonear() \u003c relayer.min_balance {\n        RelayerEvent::LowBalance {\n            balance: balance.as_yoctonear(),\n        }\n        .emit();\n        return Err(RelayerError::InsufficientBalance);\n    }\n    let is_mainnet = env::current_account_id().to_string().ends_with(\".near\");\n    let registrar = if is_mainnet {\n        \"registrar.near\".parse().unwrap()\n    } else {\n        \"testnet\".parse().unwrap()\n    };\n    let account_id_str = new_account_id.to_string();\n    let account_name = account_id_str\n        .split('.')\n        .next()\n        .ok_or(RelayerError::InvalidAccountId)?;\n    if is_mainnet {\n        let len = account_name.len();\n        if len \u003c 3 || len \u003e 16 {\n            return Err(RelayerError::InvalidAccountId);\n        }\n    } else if !account_id_str.ends_with(\".testnet\") {\n        return Err(RelayerError::InvalidAccountId);\n    }\n    let min_funding = 50_000_000_000_000_000_000_000; // 0.05 NEAR\n    let funding_amount = relayer.sponsor_amount.max(min_funding);\n    let creation_deposit = if is_mainnet {\n        funding_amount / 10\n    } else {\n        1_820_000_000_000_000_000_000 // 0.00182 NEAR\n    };\n    let args = to_vec(\u0026(new_account_id.to_string(), public_key.clone()))\n        .map_err(|_| RelayerError::InvalidAccountId)?;\n    let promise = Promise::new(registrar)\n        .function_call(\n            \"create_account\".to_string(),\n            args,\n            NearToken::from_yoctonear(creation_deposit),\n            Gas::from_tgas(relayer.cross_contract_gas),\n        )\n        .then(\n            Promise::new(new_account_id.clone())\n                .add_full_access_key(public_key.clone())\n                .transfer(NearToken::from_yoctonear(funding_amount)),\n        )\n        .then(\n            ext_auth::ext(relayer.auth_contract.clone())\n                .with_static_gas(Gas::from_tgas(relayer.cross_contract_gas))\n                .register_key(\n                    new_account_id.clone(),\n                    public_key,\n                    Some(30),\n                    is_multi_sig,\n                    multi_sig_threshold,\n                ),\n        );\n    RelayerEvent::AccountSponsored {\n        account_id: new_account_id.clone(),\n    }\n    .emit();\n    Ok(promise)\n}\n\npub fn sponsor_account_signed(\n    relayer: \u0026mut Relayer,\n    signed_delegate: SignedDelegateAction,\n) -\u003e Result\u003cPromise, RelayerError\u003e {\n    relay::relay_meta_transaction(relayer, signed_delegate)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","code","contracts","relayer-onsocial","src","state.rs"],"content":"use crate::events::RelayerEvent;\nuse crate::state_versions::{StateV010, StateV011};\nuse near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};\nuse near_sdk::json_types::U128;\nuse near_sdk::store::{LazyOption, LookupMap};\nuse near_sdk::{env, AccountId};\nuse near_sdk_macros::NearSchema;\n\n#[derive(BorshDeserialize, BorshSerialize, NearSchema)]\n#[abi(borsh)]\npub struct PendingTransfer {\n    pub nonce: u64,\n    pub sender_id: AccountId,\n    pub token: String,\n    pub amount: U128,\n    pub recipient: String,\n    pub fee: u128,\n}\n\n#[derive(BorshDeserialize, BorshSerialize, NearSchema)]\n#[abi(borsh)]\npub struct Relayer {\n    pub version: String,\n    pub manager: AccountId,\n    pub offload_recipient: AccountId,\n    pub auth_contract: AccountId,\n    pub ft_wrapper_contract: AccountId,\n    pub omni_locker_contract: LazyOption\u003cAccountId\u003e,\n    pub chain_mpc_mapping: LookupMap\u003cString, AccountId\u003e,\n    pub sponsor_amount: u128,\n    pub sponsor_gas: u64,\n    pub cross_contract_gas: u64,\n    pub migration_gas: u64,\n    pub chunk_size: usize,\n    pub min_balance: u128,\n    pub max_balance: u128,\n    pub base_fee: u128,\n    pub transfer_nonces: LookupMap\u003cString, u64\u003e,\n    pub pending_transfers: LookupMap\u003cString, PendingTransfer\u003e,\n}\n\nimpl Relayer {\n    pub fn new(\n        manager: AccountId,\n        offload_recipient: AccountId,\n        auth_contract: AccountId,\n        ft_wrapper_contract: AccountId,\n    ) -\u003e Self {\n        Self {\n            version: \"0.1.1\".to_string(),\n            manager,\n            offload_recipient,\n            auth_contract,\n            ft_wrapper_contract,\n            omni_locker_contract: LazyOption::new(\n                b\"omni_locker\".to_vec(),\n                Some(env::current_account_id()),\n            ),\n            chain_mpc_mapping: LookupMap::new(b\"chain_mpc\".to_vec()),\n            sponsor_amount: 10_000_000_000_000_000_000_000,\n            sponsor_gas: 100_000_000_000_000,\n            cross_contract_gas: 100_000_000_000_000, // Default: 100 TGas for cross-contract calls\n            migration_gas: 200_000_000_000_000,      // Default: 200 TGas for migrations\n            chunk_size: 5,                           // Default: 5 for chunked transactions\n            min_balance: 10_000_000_000_000_000_000_000_000,\n            max_balance: 1_000_000_000_000_000_000_000_000_000,\n            base_fee: 100_000_000_000_000_000_000,\n            transfer_nonces: LookupMap::new(b\"nonces\".to_vec()),\n            pending_transfers: LookupMap::new(b\"pending_transfers\".to_vec()),\n        }\n    }\n\n    pub fn is_manager(\u0026self, account_id: \u0026AccountId) -\u003e bool {\n        \u0026self.manager == account_id\n    }\n\n    pub fn get_pending_nonce(\u0026self, chain: \u0026str) -\u003e u64 {\n        self.transfer_nonces.get(chain).copied().unwrap_or(0)\n    }\n\n    pub fn add_pending_transfer(\n        \u0026mut self,\n        chain: String,\n        nonce: u64,\n        sender_id: AccountId,\n        token: String,\n        amount: U128,\n        recipient: String,\n        fee: u128,\n    ) {\n        let key = format!(\"{}-{}\", chain, nonce);\n        self.pending_transfers.insert(\n            key,\n            PendingTransfer {\n                nonce,\n                sender_id,\n                token,\n                amount,\n                recipient,\n                fee,\n            },\n        );\n    }\n\n    pub fn confirm_pending_transfer(\u0026mut self, chain: \u0026str, nonce: u64) {\n        let key = format!(\"{}-{}\", chain, nonce);\n        self.pending_transfers.remove(\u0026key);\n        let current_nonce = self.transfer_nonces.get(chain).copied().unwrap_or(0);\n        if nonce \u003e= current_nonce {\n            self.transfer_nonces.insert(chain.to_string(), nonce + 1);\n        }\n    }\n\n    pub fn revert_pending_transfer(\u0026mut self, chain: \u0026str, nonce: u64) -\u003e Option\u003cPendingTransfer\u003e {\n        let key = format!(\"{}-{}\", chain, nonce);\n        self.pending_transfers.remove(\u0026key)\n    }\n\n    pub fn migrate() -\u003e Self {\n        const CURRENT_VERSION: \u0026str = \"0.1.1\";\n\n        // Read raw state bytes, default to empty if none\n        let state_bytes: Vec\u003cu8\u003e = env::state_read().unwrap_or_default();\n\n        // Try current version (0.1.1)\n        if let Ok(state) = borsh::from_slice::\u003cRelayer\u003e(\u0026state_bytes) {\n            if state.version == CURRENT_VERSION {\n                env::log_str(\"State is already at latest version\");\n                return state;\n            }\n        }\n\n        // Try version 0.1.1\n        if let Ok(old_state) = borsh::from_slice::\u003cStateV011\u003e(\u0026state_bytes) {\n            if old_state.version == \"0.1.1\" {\n                env::log_str(\"Migrating from state version 0.1.1\");\n                let new_state = Relayer {\n                    version: CURRENT_VERSION.to_string(),\n                    manager: old_state.manager,\n                    offload_recipient: old_state.offload_recipient,\n                    auth_contract: old_state.auth_contract,\n                    ft_wrapper_contract: old_state.ft_wrapper_contract,\n                    omni_locker_contract: old_state.omni_locker_contract,\n                    chain_mpc_mapping: old_state.chain_mpc_mapping,\n                    sponsor_amount: old_state.sponsor_amount,\n                    sponsor_gas: old_state.sponsor_gas,\n                    cross_contract_gas: old_state.cross_contract_gas,\n                    migration_gas: old_state.migration_gas,\n                    chunk_size: old_state.chunk_size,\n                    min_balance: old_state.min_balance,\n                    max_balance: old_state.max_balance,\n                    base_fee: old_state.base_fee,\n                    transfer_nonces: LookupMap::new(b\"nonces\".to_vec()),\n                    pending_transfers: LookupMap::new(b\"pending_transfers\".to_vec()),\n                };\n                RelayerEvent::StateMigrated {\n                    old_version: \"0.1.1\".to_string(),\n                    new_version: CURRENT_VERSION.to_string(),\n                }\n                .emit();\n                return new_state;\n            }\n        }\n\n        // Try version 0.1.0\n        if let Ok(old_state) = borsh::from_slice::\u003cStateV010\u003e(\u0026state_bytes) {\n            if old_state.version == \"0.1.0\" {\n                env::log_str(\"Migrating from state version 0.1.0\");\n                let new_state = Relayer {\n                    version: CURRENT_VERSION.to_string(),\n                    manager: old_state.manager,\n                    offload_recipient: old_state.offload_recipient,\n                    auth_contract: old_state.auth_contract,\n                    ft_wrapper_contract: old_state.ft_wrapper_contract,\n                    omni_locker_contract: old_state.omni_locker_contract,\n                    chain_mpc_mapping: old_state.chain_mpc_mapping,\n                    sponsor_amount: old_state.sponsor_amount,\n                    sponsor_gas: old_state.sponsor_gas,\n                    cross_contract_gas: old_state.cross_contract_gas,\n                    migration_gas: old_state.migration_gas,\n                    chunk_size: old_state.chunk_size,\n                    min_balance: 10_000_000_000_000_000_000_000_000,\n                    max_balance: 1_000_000_000_000_000_000_000_000_000,\n                    base_fee: 100_000_000_000_000_000_000,\n                    transfer_nonces: LookupMap::new(b\"nonces\".to_vec()),\n                    pending_transfers: LookupMap::new(b\"pending_transfers\".to_vec()),\n                };\n                RelayerEvent::StateMigrated {\n                    old_version: \"0.1.0\".to_string(),\n                    new_version: CURRENT_VERSION.to_string(),\n                }\n                .emit();\n                return new_state;\n            }\n        }\n\n        env::log_str(\"No valid prior state found, initializing new state\");\n        Self::new(\n            env::current_account_id(),\n            \"recipient.testnet\".parse::\u003cAccountId\u003e().unwrap(),\n            \"auth.testnet\".parse::\u003cAccountId\u003e().unwrap(),\n            \"ft.testnet\".parse::\u003cAccountId\u003e().unwrap(),\n        )\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","code","contracts","relayer-onsocial","src","state_versions.rs"],"content":"use near_sdk::borsh::{BorshDeserialize, BorshSerialize};\nuse near_sdk::store::{LazyOption, LookupMap};\nuse near_sdk::AccountId;\nuse near_sdk_macros::NearSchema;\n\n// State for version 0.1.0\n#[derive(BorshSerialize, BorshDeserialize, NearSchema)]\n#[abi(borsh)]\npub struct StateV010 {\n    pub version: String,\n    pub manager: AccountId,\n    pub offload_recipient: AccountId,\n    pub auth_contract: AccountId,\n    pub ft_wrapper_contract: AccountId,\n    pub omni_locker_contract: LazyOption\u003cAccountId\u003e,\n    pub chain_mpc_mapping: LookupMap\u003cString, AccountId\u003e,\n    pub sponsor_amount: u128,\n    pub sponsor_gas: u64,\n    pub cross_contract_gas: u64,\n    pub migration_gas: u64,\n    pub chunk_size: usize,\n}\n\n// State for version 0.1.1\n#[derive(BorshSerialize, BorshDeserialize, NearSchema)]\n#[abi(borsh)]\npub struct StateV011 {\n    pub version: String,\n    pub manager: AccountId,\n    pub offload_recipient: AccountId,\n    pub auth_contract: AccountId,\n    pub ft_wrapper_contract: AccountId,\n    pub omni_locker_contract: LazyOption\u003cAccountId\u003e,\n    pub chain_mpc_mapping: LookupMap\u003cString, AccountId\u003e,\n    pub sponsor_amount: u128,\n    pub sponsor_gas: u64,\n    pub cross_contract_gas: u64,\n    pub migration_gas: u64,\n    pub chunk_size: usize,\n    pub min_balance: u128,\n    pub max_balance: u128,\n    pub base_fee: u128,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","code","contracts","relayer-onsocial","src","tests.rs"],"content":"#[cfg(test)]\nmod tests {\n    use crate::types::{Action, DelegateAction, SignatureScheme, SignedDelegateAction};\n    use crate::{\n        state_versions::{StateV010, StateV011},\n        OnSocialRelayer,\n    };\n    use near_sdk::borsh;\n    use near_sdk::store::{LazyOption, LookupMap};\n    use near_sdk::{\n        env,\n        test_utils::{get_logs, VMContextBuilder},\n        testing_env, AccountId, CurveType, NearToken, PublicKey,\n    };\n\n    fn setup_context(predecessor: AccountId) -\u003e VMContextBuilder {\n        let mut context = VMContextBuilder::new();\n        context\n            .predecessor_account_id(predecessor)\n            .current_account_id(\"relayer.testnet\".parse::\u003cAccountId\u003e().unwrap())\n            .block_timestamp(1_000_000_000_000)\n            .attached_deposit(NearToken::from_yoctonear(0));\n        context\n    }\n\n    #[test]\n    fn test_migration_from_010_to_011() {\n        let manager: AccountId = \"manager.testnet\".parse().unwrap();\n        let context = setup_context(manager.clone());\n        testing_env!(context.build());\n\n        let state_v010 = StateV010 {\n            version: \"0.1.0\".to_string(),\n            manager: manager.clone(),\n            offload_recipient: \"recipient.testnet\".parse().unwrap(),\n            auth_contract: \"auth.testnet\".parse().unwrap(),\n            ft_wrapper_contract: \"ft.testnet\".parse().unwrap(),\n            omni_locker_contract: LazyOption::new(\n                b\"omni_locker\".to_vec(),\n                Some(\"locker.testnet\".parse::\u003cAccountId\u003e().unwrap()),\n            ),\n            chain_mpc_mapping: LookupMap::new(b\"chain_mpc\".to_vec()),\n            sponsor_amount: 10_000_000_000_000_000_000_000,\n            sponsor_gas: 100_000_000_000_000,\n            cross_contract_gas: 100_000_000_000_000,\n            migration_gas: 250_000_000_000_000, // Added: 250 TGas\n            chunk_size: 10,\n        };\n        // Serialize state to Borsh\n        let state_bytes = borsh::to_vec(\u0026state_v010).expect(\"Failed to serialize state\");\n        env::state_write(\u0026state_bytes);\n\n        let new_contract = OnSocialRelayer::migrate();\n\n        assert_eq!(\n            new_contract.relayer.version, \"0.1.1\",\n            \"Version should be 0.1.1\"\n        );\n        assert_eq!(\n            new_contract.relayer.manager, manager,\n            \"Manager should be preserved\"\n        );\n        assert_eq!(\n            new_contract.relayer.offload_recipient,\n            \"recipient.testnet\".parse::\u003cAccountId\u003e().unwrap(),\n            \"Offload recipient should be preserved\"\n        );\n        assert_eq!(\n            new_contract.relayer.auth_contract,\n            \"auth.testnet\".parse::\u003cAccountId\u003e().unwrap(),\n            \"Auth contract should be preserved\"\n        );\n        assert_eq!(\n            new_contract.relayer.ft_wrapper_contract,\n            \"ft.testnet\".parse::\u003cAccountId\u003e().unwrap(),\n            \"FT wrapper contract should be preserved\"\n        );\n        assert_eq!(\n            new_contract.relayer.min_balance, 10_000_000_000_000_000_000_000_000,\n            \"Min balance should be initialized\"\n        );\n        assert_eq!(\n            new_contract.relayer.max_balance, 1_000_000_000_000_000_000_000_000_000,\n            \"Max balance should be initialized\"\n        );\n        assert_eq!(\n            new_contract.relayer.base_fee, 100_000_000_000_000_000_000,\n            \"Base fee should be initialized\"\n        );\n\n        let logs = get_logs();\n        assert!(\n            logs.contains(\u0026\"Migrating from state version 0.1.0\".to_string()),\n            \"Expected migration log, got: {:?}\",\n            logs\n        );\n        assert!(\n            logs.contains(\u0026\"EVENT_JSON:{\\\"standard\\\":\\\"nep297\\\",\\\"version\\\":\\\"1.0.0\\\",\\\"event\\\":\\\"state_migrated\\\",\\\"data\\\":{\\\"old_version\\\":\\\"0.1.0\\\",\\\"new_version\\\":\\\"0.1.1\\\"}}\".to_string()),\n            \"Expected state_migrated event, got: {:?}\", logs\n        );\n    }\n\n    #[test]\n    fn test_migration_from_011_to_011() {\n        let manager: AccountId = \"manager.testnet\".parse().unwrap();\n        let context = setup_context(manager.clone());\n        testing_env!(context.build());\n\n        let state_v011 = StateV011 {\n            version: \"0.1.1\".to_string(),\n            manager: manager.clone(),\n            offload_recipient: \"recipient.testnet\".parse().unwrap(),\n            auth_contract: \"auth.testnet\".parse().unwrap(),\n            ft_wrapper_contract: \"ft.testnet\".parse().unwrap(),\n            omni_locker_contract: LazyOption::new(\n                b\"omni_locker\".to_vec(),\n                Some(\"locker.testnet\".parse::\u003cAccountId\u003e().unwrap()),\n            ),\n            chain_mpc_mapping: LookupMap::new(b\"chain_mpc\".to_vec()),\n            sponsor_amount: 10_000_000_000_000_000_000_000,\n            sponsor_gas: 100_000_000_000_000,\n            cross_contract_gas: 100_000_000_000_000,\n            migration_gas: 250_000_000_000_000, // Added: 250 TGas\n            chunk_size: 10,\n            min_balance: 10_000_000_000_000_000_000_000_000,\n            max_balance: 1_000_000_000_000_000_000_000_000_000,\n            base_fee: 100_000_000_000_000_000_000,\n        };\n        // Serialize state to Borsh\n        let state_bytes = borsh::to_vec(\u0026state_v011).expect(\"Failed to serialize state\");\n        env::state_write(\u0026state_bytes);\n\n        let new_contract = OnSocialRelayer::migrate();\n\n        assert_eq!(\n            new_contract.relayer.version, \"0.1.1\",\n            \"Version should be 0.1.1\"\n        );\n        assert_eq!(\n            new_contract.relayer.manager, manager,\n            \"Manager should be preserved\"\n        );\n        assert_eq!(\n            new_contract.relayer.offload_recipient,\n            \"recipient.testnet\".parse::\u003cAccountId\u003e().unwrap(),\n            \"Offload recipient should be preserved\"\n        );\n        assert_eq!(\n            new_contract.relayer.auth_contract,\n            \"auth.testnet\".parse::\u003cAccountId\u003e().unwrap(),\n            \"Auth contract should be preserved\"\n        );\n        assert_eq!(\n            new_contract.relayer.ft_wrapper_contract,\n            \"ft.testnet\".parse::\u003cAccountId\u003e().unwrap(),\n            \"FT wrapper contract should be preserved\"\n        );\n        assert_eq!(\n            new_contract.relayer.min_balance, 10_000_000_000_000_000_000_000_000,\n            \"Min balance should be preserved\"\n        );\n        assert_eq!(\n            new_contract.relayer.max_balance, 1_000_000_000_000_000_000_000_000_000,\n            \"Max balance should be preserved\"\n        );\n        assert_eq!(\n            new_contract.relayer.base_fee, 100_000_000_000_000_000_000,\n            \"Base fee should be preserved\"\n        );\n\n        let logs = get_logs();\n        assert!(\n            logs.contains(\u0026\"Migrating from state version 0.1.1\".to_string()),\n            \"Expected migration log, got: {:?}\",\n            logs\n        );\n        assert!(\n            logs.contains(\u0026\"EVENT_JSON:{\\\"standard\\\":\\\"nep297\\\",\\\"version\\\":\\\"1.0.0\\\",\\\"event\\\":\\\"state_migrated\\\",\\\"data\\\":{\\\"old_version\\\":\\\"0.1.1\\\",\\\"new_version\\\":\\\"0.1.1\\\"}}\".to_string()),\n            \"Expected state_migrated event, got: {:?}\", logs\n        );\n    }\n\n    #[test]\n    fn test_migration_no_prior_state() {\n        let manager: AccountId = \"manager.testnet\".parse().unwrap();\n        let context = setup_context(manager.clone());\n        testing_env!(context.build());\n\n        let new_contract = OnSocialRelayer::migrate();\n\n        assert_eq!(\n            new_contract.relayer.version, \"0.1.1\",\n            \"Version should be 0.1.1\"\n        );\n        assert_eq!(\n            new_contract.relayer.manager,\n            env::current_account_id(),\n            \"Manager should be current account\"\n        );\n        assert_eq!(\n            new_contract.relayer.offload_recipient,\n            \"recipient.testnet\".parse::\u003cAccountId\u003e().unwrap(),\n            \"Offload recipient should be initialized\"\n        );\n        assert_eq!(\n            new_contract.relayer.auth_contract,\n            \"auth.testnet\".parse::\u003cAccountId\u003e().unwrap(),\n            \"Auth contract should be initialized\"\n        );\n        assert_eq!(\n            new_contract.relayer.ft_wrapper_contract,\n            \"ft.testnet\".parse::\u003cAccountId\u003e().unwrap(),\n            \"FT wrapper contract should be initialized\"\n        );\n\n        let logs = get_logs();\n        assert!(\n            logs.contains(\u0026\"No valid prior state found, initializing new state\".to_string()),\n            \"Expected no prior state log, got: {:?}\",\n            logs\n        );\n    }\n\n    #[test]\n    fn test_migration_corrupted_state() {\n        let manager: AccountId = \"manager.testnet\".parse().unwrap();\n        let context = setup_context(manager.clone());\n        testing_env!(context.build());\n\n        // Simulate corrupted state\n        env::state_write(\u0026vec![0u8; 10]); // Invalid Borsh data\n\n        let new_contract = OnSocialRelayer::migrate();\n\n        assert_eq!(\n            new_contract.relayer.version, \"0.1.1\",\n            \"Version should be 0.1.1\"\n        );\n        assert_eq!(\n            new_contract.relayer.manager,\n            env::current_account_id(),\n            \"Manager should be current account\"\n        );\n        assert_eq!(\n            new_contract.relayer.offload_recipient,\n            \"recipient.testnet\".parse::\u003cAccountId\u003e().unwrap(),\n            \"Offload recipient should be initialized\"\n        );\n        assert_eq!(\n            new_contract.relayer.auth_contract,\n            \"auth.testnet\".parse::\u003cAccountId\u003e().unwrap(),\n            \"Auth contract should be initialized\"\n        );\n        assert_eq!(\n            new_contract.relayer.ft_wrapper_contract,\n            \"ft.testnet\".parse::\u003cAccountId\u003e().unwrap(),\n            \"FT wrapper contract should be initialized\"\n        );\n\n        let logs = get_logs();\n        assert!(\n            logs.contains(\u0026\"No valid prior state found, initializing new state\".to_string()),\n            \"Expected no prior state log, got: {:?}\",\n            logs\n        );\n    }\n\n    #[test]\n    fn test_gas_logging_relay_meta_transaction() {\n        let manager: AccountId = \"manager.testnet\".parse().unwrap();\n        let context = setup_context(manager.clone());\n        testing_env!(context.build());\n\n        let mut contract = OnSocialRelayer::new(\n            \"recipient.testnet\".parse().unwrap(),\n            \"auth.testnet\".parse().unwrap(),\n            \"ft.testnet\".parse().unwrap(),\n        );\n\n        // Create a mock SignedDelegateAction with multiple actions to trigger InvalidNonce\n        let delegate_action = DelegateAction {\n            sender_id: \"sender.testnet\".parse().unwrap(),\n            receiver_id: \"receiver.testnet\".parse().unwrap(),\n            actions: vec![\n                Action::Transfer {\n                    deposit: NearToken::from_yoctonear(1_000_000_000_000_000_000_000),\n                },\n                Action::Transfer {\n                    deposit: NearToken::from_yoctonear(1_000_000_000_000_000_000_000),\n                },\n            ],\n            nonce: 1,\n            max_block_height: 1_000_000,\n        };\n        let dummy_key = vec![0u8; 32]; // Use 32 bytes for Ed25519 public key\n        let signed_delegate = SignedDelegateAction {\n            delegate_action,\n            signature: vec![0u8; 64], // Dummy signature\n            public_key: PublicKey::from_parts(CurveType::ED25519, dummy_key)\n                .expect(\"Failed to create dummy public key\"),\n            session_nonce: 0,\n            scheme: SignatureScheme::Ed25519,\n            fee_action: None,\n            multi_signatures: None,\n        };\n\n        let result = contract.relay_meta_transaction(signed_delegate);\n        assert!(result.is_err(), \"Expected InvalidNonce error\");\n        let logs = get_logs();\n        assert!(\n            logs.iter()\n                .any(|log| log.contains(\"Gas used in relay_meta_transaction\")),\n            \"Expected gas usage log, got: {:?}\",\n            logs\n        );\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","code","contracts","relayer-onsocial","src","types.rs"],"content":"use near_sdk::borsh::{BorshDeserialize, BorshSerialize};\nuse near_sdk::json_types::U128;\nuse near_sdk::{AccountId, Gas, NearToken, PublicKey};\nuse near_sdk_macros::NearSchema;\nuse serde::{Deserialize, Serialize};\n\n#[derive(\n    Clone, Eq, PartialEq, BorshSerialize, BorshDeserialize, Serialize, Deserialize, NearSchema,\n)]\n#[abi(borsh, json)]\npub enum Action {\n    ChainSignatureRequest {\n        target_chain: String,\n        derivation_path: String,\n        payload: Vec\u003cu8\u003e,\n    },\n    FunctionCall {\n        method_name: String,\n        args: Vec\u003cu8\u003e,\n        gas: Gas,\n        deposit: NearToken,\n    },\n    Transfer {\n        deposit: NearToken,\n    },\n    AddKey {\n        public_key: PublicKey,\n        allowance: Option\u003cNearToken\u003e,\n        receiver_id: AccountId,\n        method_names: Vec\u003cString\u003e,\n    },\n    FtTransfer {\n        token: String,\n        receiver_id: AccountId,\n        amount: U128,\n        memo: Option\u003cString\u003e,\n    },\n    BridgeTransfer {\n        token: String,\n        amount: U128,\n        destination_chain: String,\n        recipient: String,\n    },\n}\n\nimpl Action {\n    pub fn type_name(\u0026self) -\u003e \u0026str {\n        match self {\n            Action::ChainSignatureRequest { .. } =\u003e \"ChainSignatureRequest\",\n            Action::FunctionCall { .. } =\u003e \"FunctionCall\",\n            Action::Transfer { .. } =\u003e \"Transfer\",\n            Action::AddKey { .. } =\u003e \"AddKey\",\n            Action::FtTransfer { .. } =\u003e \"FtTransfer\",\n            Action::BridgeTransfer { .. } =\u003e \"BridgeTransfer\",\n        }\n    }\n}\n\n#[derive(\n    Clone, Eq, PartialEq, BorshSerialize, BorshDeserialize, Serialize, Deserialize, NearSchema,\n)]\n#[abi(borsh, json)]\npub struct DelegateAction {\n    pub sender_id: AccountId,\n    pub receiver_id: AccountId,\n    pub actions: Vec\u003cAction\u003e,\n    pub nonce: u64,\n    pub max_block_height: u64,\n}\n\n#[derive(\n    Clone, Eq, PartialEq, BorshSerialize, BorshDeserialize, Serialize, Deserialize, NearSchema,\n)]\n#[abi(borsh, json)]\npub enum SignatureScheme {\n    Ed25519,\n}\n\n#[derive(\n    Clone, Eq, PartialEq, BorshSerialize, BorshDeserialize, Serialize, Deserialize, NearSchema,\n)]\n#[abi(borsh, json)]\npub struct SignedDelegateAction {\n    pub delegate_action: DelegateAction,\n    pub signature: Vec\u003cu8\u003e,\n    pub public_key: PublicKey,\n    pub session_nonce: u64,\n    pub scheme: SignatureScheme,\n    pub fee_action: Option\u003cAction\u003e,\n    pub multi_signatures: Option\u003cVec\u003cVec\u003cu8\u003e\u003e\u003e, // Added for multi-sig support\n}\n","traces":[],"covered":0,"coverable":0}]};
        var previousData = {"files":[{"path":["/","code","contracts","auth-onsocial","src","errors.rs"],"content":"use near_sdk::borsh::{BorshDeserialize, BorshSerialize};\nuse near_sdk::{env, FunctionError};\nuse near_sdk_macros::NearSchema;\n\n#[derive(Debug, PartialEq, NearSchema, BorshSerialize, BorshDeserialize)]\n#[abi(borsh)]\npub enum AuthError {\n    Unauthorized,\n    KeyNotFound,\n    KeyAlreadyExists,\n    AccountStillActive,\n    MissingInput,\n}\n\nimpl FunctionError for AuthError {\n    fn panic(\u0026self) -\u003e ! {\n        env::panic_str(match self {\n            AuthError::Unauthorized =\u003e \"Unauthorized access\",\n            AuthError::KeyNotFound =\u003e \"Key not found\",\n            AuthError::KeyAlreadyExists =\u003e \"Key already exists\",\n            AuthError::AccountStillActive =\u003e \"Account is still active\",\n            AuthError::MissingInput =\u003e \"No input provided\",\n        })\n    }\n}\n","traces":[{"line":16,"address":[1293472],"length":1,"stats":{"Line":0}},{"line":17,"address":[1293625,1293481],"length":1,"stats":{"Line":0}},{"line":18,"address":[1293512],"length":1,"stats":{"Line":0}},{"line":19,"address":[1293535],"length":1,"stats":{"Line":0}},{"line":20,"address":[1293558],"length":1,"stats":{"Line":0}},{"line":21,"address":[1293581],"length":1,"stats":{"Line":0}},{"line":22,"address":[1293604],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":7},{"path":["/","code","contracts","auth-onsocial","src","events.rs"],"content":"use near_sdk::{near, AccountId};\n\n#[near(event_json(standard = \"nep297\"))]\npub enum AuthEvent {\n    #[event_version(\"1.0.0\")]\n    KeyRegistered {\n        account_id: AccountId,\n        public_key: String,\n    },\n    #[event_version(\"1.0.0\")]\n    KeyRemoved {\n        account_id: AccountId,\n        public_key: String,\n    },\n    #[event_version(\"1.0.0\")]\n    KeyRotated {\n        account_id: AccountId,\n        old_public_key: String,\n        new_public_key: String,\n    },\n    #[event_version(\"1.0.0\")]\n    ContractUpgraded { manager: AccountId, timestamp: u64 },\n    #[event_version(\"1.0.0\")]\n    ManagerChanged {\n        old_manager: AccountId,\n        new_manager: AccountId,\n        timestamp: u64,\n    },\n    #[event_version(\"1.0.0\")]\n    StateMigrated {\n        old_version: String,\n        new_version: String,\n    },\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","code","contracts","auth-onsocial","src","lib.rs"],"content":"use crate::errors::AuthError;\nuse crate::events::AuthEvent;\nuse crate::state::AuthContractState;\nuse crate::state_versions::{StateV010, StateV011};\nuse crate::types::{KeyInfo, RotateKeyArgs};\nuse near_sdk::{env, near, AccountId, PanicOnDefault, Promise, PublicKey};\n\npub mod errors;\nmod events;\npub mod state;\npub mod state_versions;\n#[cfg(test)]\nmod tests;\npub mod types;\n\n#[near(contract_state)]\n#[derive(PanicOnDefault)]\npub struct AuthContract {\n    state: AuthContractState,\n}\n\n#[near]\nimpl AuthContract {\n    #[init]\n    pub fn new() -\u003e Self {\n        Self {\n            state: AuthContractState::new(),\n        }\n    }\n\n    pub fn is_authorized(\n        \u0026mut self,\n        account_id: AccountId,\n        public_key: PublicKey,\n        signatures: Option\u003cVec\u003cVec\u003cu8\u003e\u003e\u003e,\n    ) -\u003e bool {\n        self.state\n            .is_authorized(\u0026account_id, \u0026public_key, signatures)\n    }\n\n    #[handle_result]\n    pub fn register_key(\n        \u0026mut self,\n        account_id: AccountId,\n        public_key: PublicKey,\n        expiration_days: Option\u003cu32\u003e,\n        is_multi_sig: bool,\n        multi_sig_threshold: Option\u003cu32\u003e,\n    ) -\u003e Result\u003c(), AuthError\u003e {\n        self.state.register_key(\n            \u0026env::predecessor_account_id(),\n            \u0026account_id,\n            public_key,\n            expiration_days,\n            is_multi_sig,\n            multi_sig_threshold,\n        )\n    }\n\n    #[handle_result]\n    pub fn remove_key(\n        \u0026mut self,\n        account_id: AccountId,\n        public_key: PublicKey,\n    ) -\u003e Result\u003c(), AuthError\u003e {\n        self.state\n            .remove_key(\u0026env::predecessor_account_id(), \u0026account_id, public_key)\n    }\n\n    #[handle_result]\n    pub fn rotate_key(\u0026mut self, args: RotateKeyArgs) -\u003e Result\u003c(), AuthError\u003e {\n        self.state.rotate_key(\u0026env::predecessor_account_id(), args)\n    }\n\n    #[handle_result]\n    pub fn remove_expired_keys(\u0026mut self, account_id: AccountId) -\u003e Result\u003c(), AuthError\u003e {\n        self.state.remove_expired_keys(\u0026account_id)\n    }\n\n    #[handle_result]\n    pub fn remove_inactive_accounts(\u0026mut self, account_id: AccountId) -\u003e Result\u003c(), AuthError\u003e {\n        self.state.remove_inactive_accounts(account_id)\n    }\n\n    pub fn get_inactive_accounts(\u0026self, limit: u32, offset: u32) -\u003e Vec\u003cAccountId\u003e {\n        self.state.get_inactive_accounts(limit, offset)\n    }\n\n    pub fn get_key_info(\u0026self, account_id: AccountId, public_key: PublicKey) -\u003e Option\u003cKeyInfo\u003e {\n        self.state.get_key_info(\u0026account_id, \u0026public_key)\n    }\n\n    pub fn get_keys(\u0026self, account_id: AccountId, limit: u32, offset: u32) -\u003e Vec\u003cKeyInfo\u003e {\n        self.state.get_keys(\u0026account_id, limit, offset)\n    }\n\n    #[handle_result]\n    pub fn update_contract(\u0026mut self) -\u003e Result\u003cPromise, AuthError\u003e {\n        self.state.update_contract()\n    }\n\n    #[handle_result]\n    pub fn set_manager(\u0026mut self, new_manager: AccountId) -\u003e Result\u003c(), AuthError\u003e {\n        self.state\n            .set_manager(\u0026env::predecessor_account_id(), new_manager)\n    }\n\n    #[private]\n    #[init(ignore_state)]\n    pub fn migrate() -\u003e Self {\n        const CURRENT_VERSION: \u0026str = \"0.1.1\";\n\n        let state_bytes: Vec\u003cu8\u003e = env::state_read().unwrap_or_default();\n\n        // Try current version (0.1.1)\n        if let Ok(state) = near_sdk::borsh::from_slice::\u003cAuthContractState\u003e(\u0026state_bytes) {\n            if state.version == CURRENT_VERSION {\n                env::log_str(\"State is already at latest version\");\n                return Self { state };\n            }\n        }\n\n        // Try version 0.1.1\n        if let Ok(old_state) = near_sdk::borsh::from_slice::\u003cStateV011\u003e(\u0026state_bytes) {\n            if old_state.version == \"0.1.1\" {\n                env::log_str(\"Migrating from state version 0.1.1\");\n                let new_state = AuthContractState {\n                    version: CURRENT_VERSION.to_string(),\n                    keys: old_state.keys,\n                    last_active_timestamps: old_state.last_active_timestamps,\n                    registered_accounts: old_state.registered_accounts,\n                    manager: old_state.manager,\n                    max_keys_per_account: old_state.max_keys_per_account,\n                };\n                AuthEvent::StateMigrated {\n                    old_version: \"0.1.1\".to_string(),\n                    new_version: CURRENT_VERSION.to_string(),\n                }\n                .emit();\n                return Self { state: new_state };\n            }\n        }\n\n        // Try version 0.1.0\n        if let Ok(old_state) = near_sdk::borsh::from_slice::\u003cStateV010\u003e(\u0026state_bytes) {\n            if old_state.version == \"0.1.0\" {\n                env::log_str(\"Migrating from state version 0.1.0\");\n                let new_state = AuthContractState {\n                    version: CURRENT_VERSION.to_string(),\n                    keys: old_state.keys,\n                    last_active_timestamps: old_state.last_active_timestamps,\n                    registered_accounts: old_state.registered_accounts,\n                    manager: old_state.manager,\n                    max_keys_per_account: 100, // Default value\n                };\n                AuthEvent::StateMigrated {\n                    old_version: \"0.1.0\".to_string(),\n                    new_version: CURRENT_VERSION.to_string(),\n                }\n                .emit();\n                return Self { state: new_state };\n            }\n        }\n\n        env::log_str(\"No valid prior state found, initializing new state\");\n        Self {\n            state: AuthContractState::new(),\n        }\n    }\n}\n","traces":[{"line":25,"address":[1662640],"length":1,"stats":{"Line":0}},{"line":27,"address":[1662656],"length":1,"stats":{"Line":0}},{"line":31,"address":[1662870,1662704],"length":1,"stats":{"Line":0}},{"line":37,"address":[1662757],"length":1,"stats":{"Line":0}},{"line":42,"address":[1662896,1663314,1663355],"length":1,"stats":{"Line":0}},{"line":50,"address":[1663188,1663027],"length":1,"stats":{"Line":0}},{"line":51,"address":[1663147,1663043],"length":1,"stats":{"Line":0}},{"line":53,"address":[1663157],"length":1,"stats":{"Line":0}},{"line":61,"address":[1663670,1663629,1663376],"length":1,"stats":{"Line":0}},{"line":66,"address":[1663408,1663541],"length":1,"stats":{"Line":0}},{"line":67,"address":[1663418,1663494],"length":1,"stats":{"Line":0}},{"line":71,"address":[1664168,1664237,1663680],"length":1,"stats":{"Line":0}},{"line":80,"address":[1663815,1664029],"length":1,"stats":{"Line":0}},{"line":81,"address":[1663956,1663847],"length":1,"stats":{"Line":0}},{"line":83,"address":[1663966],"length":1,"stats":{"Line":0}},{"line":84,"address":[1663998],"length":1,"stats":{"Line":0}},{"line":92,"address":[1664256,1664343],"length":1,"stats":{"Line":0}},{"line":93,"address":[1664280],"length":1,"stats":{"Line":0}},{"line":97,"address":[1664368],"length":1,"stats":{"Line":0}},{"line":98,"address":[1664386],"length":1,"stats":{"Line":0}},{"line":101,"address":[1664400],"length":1,"stats":{"Line":0}},{"line":102,"address":[1664424],"length":1,"stats":{"Line":0}},{"line":105,"address":[1664448,1664597],"length":1,"stats":{"Line":0}},{"line":106,"address":[1664491],"length":1,"stats":{"Line":0}},{"line":109,"address":[1664624,1664749],"length":1,"stats":{"Line":0}},{"line":110,"address":[1664689],"length":1,"stats":{"Line":0}},{"line":114,"address":[1664768],"length":1,"stats":{"Line":0}},{"line":115,"address":[1664785],"length":1,"stats":{"Line":0}},{"line":119,"address":[1665000,1664800],"length":1,"stats":{"Line":0}},{"line":120,"address":[1664932,1664824],"length":1,"stats":{"Line":0}},{"line":121,"address":[1664834,1664902],"length":1,"stats":{"Line":0}},{"line":126,"address":[1669041,1665040,1665752],"length":1,"stats":{"Line":2}},{"line":129,"address":[1665063],"length":1,"stats":{"Line":2}},{"line":132,"address":[1665209,1665304],"length":1,"stats":{"Line":2}},{"line":133,"address":[1665511,1665402],"length":1,"stats":{"Line":2}},{"line":134,"address":[1665532],"length":1,"stats":{"Line":1}},{"line":135,"address":[1665621],"length":1,"stats":{"Line":1}},{"line":140,"address":[1666258,1665814,1665876],"length":1,"stats":{"Line":2}},{"line":141,"address":[1666006,1666116],"length":1,"stats":{"Line":0}},{"line":142,"address":[1666137],"length":1,"stats":{"Line":0}},{"line":144,"address":[1666263],"length":1,"stats":{"Line":0}},{"line":145,"address":[1666294],"length":1,"stats":{"Line":0}},{"line":146,"address":[1666350],"length":1,"stats":{"Line":0}},{"line":147,"address":[1666406],"length":1,"stats":{"Line":0}},{"line":148,"address":[1666478],"length":1,"stats":{"Line":0}},{"line":149,"address":[1666502],"length":1,"stats":{"Line":0}},{"line":152,"address":[1666724],"length":1,"stats":{"Line":0}},{"line":153,"address":[1666795],"length":1,"stats":{"Line":0}},{"line":156,"address":[1667062],"length":1,"stats":{"Line":0}},{"line":161,"address":[1667434,1667816,1667372],"length":1,"stats":{"Line":2}},{"line":162,"address":[1667674,1667564],"length":1,"stats":{"Line":2}},{"line":163,"address":[1667695],"length":1,"stats":{"Line":1}},{"line":165,"address":[1667821],"length":1,"stats":{"Line":1}},{"line":166,"address":[1667852],"length":1,"stats":{"Line":1}},{"line":167,"address":[1667908],"length":1,"stats":{"Line":1}},{"line":168,"address":[1667964],"length":1,"stats":{"Line":1}},{"line":169,"address":[1668036],"length":1,"stats":{"Line":1}},{"line":173,"address":[1668279],"length":1,"stats":{"Line":1}},{"line":174,"address":[1668350],"length":1,"stats":{"Line":1}},{"line":177,"address":[1668617],"length":1,"stats":{"Line":1}},{"line":181,"address":[1668943],"length":1,"stats":{"Line":1}},{"line":183,"address":[1668989],"length":1,"stats":{"Line":1}}],"covered":20,"coverable":62},{"path":["/","code","contracts","auth-onsocial","src","state.rs"],"content":"use crate::errors::AuthError;\nuse crate::events::AuthEvent;\nuse crate::types::{KeyInfo, RotateKeyArgs};\nuse near_sdk::borsh::{BorshDeserialize, BorshSerialize};\nuse near_sdk::store::{IterableSet, LookupMap, Vector};\nuse near_sdk::{env, log, AccountId, BorshStorageKey, Gas, NearToken, Promise, PublicKey};\n\nconst CALL_GAS: Gas = Gas::from_tgas(200);\nconst NO_ARGS: Vec\u003cu8\u003e = vec![];\n\n#[derive(BorshSerialize, BorshDeserialize, BorshStorageKey)]\n#[borsh(crate = \"near_sdk::borsh\")]\npub enum StorageKey {\n    Keys,\n    KeySet { account_id: AccountId },\n    LastActive,\n    Accounts,\n}\n\n#[derive(BorshSerialize, BorshDeserialize, near_sdk_macros::NearSchema)]\n#[borsh(crate = \"near_sdk::borsh\")]\n#[abi(borsh)]\npub struct AuthContractState {\n    pub version: String,\n    pub keys: LookupMap\u003cAccountId, IterableSet\u003cKeyInfo\u003e\u003e,\n    pub last_active_timestamps: LookupMap\u003cAccountId, u64\u003e,\n    pub registered_accounts: Vector\u003cAccountId\u003e,\n    pub manager: AccountId,\n    pub max_keys_per_account: u32,\n}\n\nimpl AuthContractState {\n    pub fn new() -\u003e Self {\n        Self {\n            version: \"0.1.1\".to_string(),\n            keys: LookupMap::new(StorageKey::Keys),\n            last_active_timestamps: LookupMap::new(StorageKey::LastActive),\n            registered_accounts: Vector::new(StorageKey::Accounts),\n            manager: env::predecessor_account_id(),\n            max_keys_per_account: 100,\n        }\n    }\n\n    pub fn is_authorized(\n        \u0026mut self,\n        account_id: \u0026AccountId,\n        public_key: \u0026PublicKey,\n        signatures: Option\u003cVec\u003cVec\u003cu8\u003e\u003e\u003e,\n    ) -\u003e bool {\n        let key_set = match self.keys.get(account_id) {\n            Some(set) =\u003e set,\n            None =\u003e return false,\n        };\n\n        let key_info = match key_set.iter().find(|k| k.public_key == *public_key) {\n            Some(info) =\u003e info,\n            None =\u003e return false,\n        };\n\n        if let Some(expiration) = key_info.expiration_timestamp {\n            if env::block_timestamp_ms() \u003e expiration {\n                return false;\n            }\n        }\n\n        let authorized = if key_info.is_multi_sig {\n            let threshold = key_info.multi_sig_threshold.unwrap_or(1);\n            let signatures = signatures.unwrap_or_default();\n            signatures.len() as u32 \u003e= threshold\n        } else {\n            true\n        };\n\n        if authorized {\n            self.last_active_timestamps\n                .insert(account_id.clone(), env::block_timestamp_ms());\n        }\n\n        authorized\n    }\n\n    pub fn register_key(\n        \u0026mut self,\n        caller: \u0026AccountId,\n        account_id: \u0026AccountId,\n        public_key: PublicKey,\n        expiration_days: Option\u003cu32\u003e,\n        is_multi_sig: bool,\n        multi_sig_threshold: Option\u003cu32\u003e,\n    ) -\u003e Result\u003c(), AuthError\u003e {\n        log!(\"Registering key for account: {}\", account_id);\n        if caller != account_id {\n            return Err(AuthError::Unauthorized);\n        }\n\n        let expiration_timestamp = expiration_days\n            .map(|days| env::block_timestamp_ms() + (days as u64 * 24 * 60 * 60 * 1000));\n\n        let key_info = KeyInfo {\n            public_key: public_key.clone(),\n            expiration_timestamp,\n            is_multi_sig,\n            multi_sig_threshold,\n        };\n\n        if self.keys.get(account_id).is_none() {\n            log!(\"Creating new key set for account: {}\", account_id);\n            self.keys.insert(\n                account_id.clone(),\n                IterableSet::new(StorageKey::KeySet {\n                    account_id: account_id.clone(),\n                }),\n            );\n            self.registered_accounts.push(account_id.clone());\n        }\n\n        let key_set = self.keys.get_mut(account_id).expect(\"Key set should exist\");\n        if key_set.contains(\u0026key_info) {\n            return Err(AuthError::KeyAlreadyExists);\n        }\n        if key_set.len() \u003e= self.max_keys_per_account {\n            return Err(AuthError::KeyAlreadyExists); // Reuse error for max keys limit\n        }\n        key_set.insert(key_info);\n\n        self.last_active_timestamps\n            .insert(account_id.clone(), env::block_timestamp_ms());\n\n        AuthEvent::KeyRegistered {\n            account_id: account_id.clone(),\n            public_key: format!(\"{:?}\", public_key),\n        }\n        .emit();\n\n        Ok(())\n    }\n\n    pub fn remove_key(\n        \u0026mut self,\n        caller: \u0026AccountId,\n        account_id: \u0026AccountId,\n        public_key: PublicKey,\n    ) -\u003e Result\u003c(), AuthError\u003e {\n        if caller != account_id {\n            return Err(AuthError::Unauthorized);\n        }\n\n        let key_set = self\n            .keys\n            .get_mut(account_id)\n            .ok_or(AuthError::KeyNotFound)?;\n        let key_info = KeyInfo {\n            public_key: public_key.clone(),\n            expiration_timestamp: None,\n            is_multi_sig: false,\n            multi_sig_threshold: None,\n        };\n        if !key_set.remove(\u0026key_info) {\n            return Err(AuthError::KeyNotFound);\n        }\n\n        if key_set.is_empty() {\n            self.keys.remove(account_id);\n            self.last_active_timestamps.remove(account_id);\n            if let Some(index) = self\n                .registered_accounts\n                .iter()\n                .position(|id| id == account_id)\n            {\n                self.registered_accounts.swap_remove(index as u32);\n            }\n        }\n\n        AuthEvent::KeyRemoved {\n            account_id: account_id.clone(),\n            public_key: format!(\"{:?}\", public_key),\n        }\n        .emit();\n\n        Ok(())\n    }\n\n    pub fn rotate_key(\u0026mut self, caller: \u0026AccountId, args: RotateKeyArgs) -\u003e Result\u003c(), AuthError\u003e {\n        if caller != \u0026args.account_id {\n            return Err(AuthError::Unauthorized);\n        }\n\n        let key_set = self\n            .keys\n            .get_mut(\u0026args.account_id)\n            .ok_or(AuthError::KeyNotFound)?;\n        let old_key_info = KeyInfo {\n            public_key: args.old_public_key.clone(),\n            expiration_timestamp: None,\n            is_multi_sig: false,\n            multi_sig_threshold: None,\n        };\n        if !key_set.contains(\u0026old_key_info) {\n            return Err(AuthError::KeyNotFound);\n        }\n\n        let new_key_info = KeyInfo {\n            public_key: args.new_public_key.clone(),\n            expiration_timestamp: args\n                .expiration_days\n                .map(|days| env::block_timestamp_ms() + (days as u64 * 24 * 60 * 60 * 1000)),\n            is_multi_sig: args.is_multi_sig,\n            multi_sig_threshold: args.multi_sig_threshold,\n        };\n        if key_set.contains(\u0026new_key_info) {\n            return Err(AuthError::KeyAlreadyExists);\n        }\n\n        key_set.remove(\u0026old_key_info);\n        key_set.insert(new_key_info);\n        self.last_active_timestamps\n            .insert(args.account_id.clone(), env::block_timestamp_ms());\n\n        AuthEvent::KeyRotated {\n            account_id: args.account_id.clone(),\n            old_public_key: format!(\"{:?}\", args.old_public_key),\n            new_public_key: format!(\"{:?}\", args.new_public_key),\n        }\n        .emit();\n\n        Ok(())\n    }\n\n    pub fn remove_expired_keys(\u0026mut self, account_id: \u0026AccountId) -\u003e Result\u003c(), AuthError\u003e {\n        let key_set = self\n            .keys\n            .get_mut(account_id)\n            .ok_or(AuthError::KeyNotFound)?;\n        let current_timestamp = env::block_timestamp_ms();\n        let mut to_remove = Vec::new();\n\n        for key_info in key_set.iter() {\n            if key_info\n                .expiration_timestamp\n                .is_some_and(|exp| current_timestamp \u003e exp)\n            {\n                to_remove.push(key_info.clone());\n            }\n        }\n\n        for key_info in to_remove {\n            key_set.remove(\u0026key_info);\n            AuthEvent::KeyRemoved {\n                account_id: account_id.clone(),\n                public_key: format!(\"{:?}\", key_info.public_key),\n            }\n            .emit();\n        }\n\n        if key_set.is_empty() {\n            self.keys.remove(account_id);\n            self.last_active_timestamps.remove(account_id);\n            if let Some(index) = self\n                .registered_accounts\n                .iter()\n                .position(|id| id == account_id)\n            {\n                self.registered_accounts.swap_remove(index as u32);\n            }\n        }\n\n        Ok(())\n    }\n\n    pub fn remove_inactive_accounts(\u0026mut self, account_id: AccountId) -\u003e Result\u003c(), AuthError\u003e {\n        let last_active = self\n            .last_active_timestamps\n            .get(\u0026account_id)\n            .ok_or(AuthError::KeyNotFound)?;\n        let current_timestamp = env::block_timestamp_ms();\n        const ONE_YEAR_MS: u64 = 31_536_000_000;\n\n        if current_timestamp \u003c= last_active + ONE_YEAR_MS {\n            return Err(AuthError::AccountStillActive);\n        }\n\n        let key_set = self\n            .keys\n            .get_mut(\u0026account_id)\n            .ok_or(AuthError::KeyNotFound)?;\n        let to_remove: Vec\u003c_\u003e = key_set.iter().cloned().collect();\n        for key_info in to_remove {\n            key_set.remove(\u0026key_info);\n            AuthEvent::KeyRemoved {\n                account_id: account_id.clone(),\n                public_key: format!(\"{:?}\", key_info.public_key),\n            }\n            .emit();\n        }\n\n        self.keys.remove(\u0026account_id);\n        self.last_active_timestamps.remove(\u0026account_id);\n        if let Some(index) = self\n            .registered_accounts\n            .iter()\n            .position(|id| id == \u0026account_id)\n        {\n            self.registered_accounts.swap_remove(index as u32);\n        }\n\n        Ok(())\n    }\n\n    pub fn get_inactive_accounts(\u0026self, limit: u32, offset: u32) -\u003e Vec\u003cAccountId\u003e {\n        assert!(limit \u003c= 100, \"Limit exceeds maximum allowed value\");\n        let current_timestamp = env::block_timestamp_ms();\n        const ONE_YEAR_MS: u64 = 31_536_000_000;\n        let mut inactive_accounts = Vec::new();\n        let start = offset as usize;\n        let end = (offset + limit) as usize;\n\n        for account_id in self\n            .registered_accounts\n            .iter()\n            .skip(start)\n            .take(end - start)\n        {\n            if let Some(timestamp) = self.last_active_timestamps.get(account_id) {\n                if current_timestamp \u003e timestamp + ONE_YEAR_MS {\n                    inactive_accounts.push(account_id.clone());\n                }\n            }\n        }\n        inactive_accounts\n    }\n\n    pub fn get_key_info(\u0026self, account_id: \u0026AccountId, public_key: \u0026PublicKey) -\u003e Option\u003cKeyInfo\u003e {\n        self.keys\n            .get(account_id)\n            .and_then(|set| set.iter().find(|k| k.public_key == *public_key).cloned())\n    }\n\n    pub fn get_keys(\u0026self, account_id: \u0026AccountId, limit: u32, offset: u32) -\u003e Vec\u003cKeyInfo\u003e {\n        assert!(limit \u003c= 100, \"Limit exceeds maximum allowed value\");\n        let key_set = match self.keys.get(account_id) {\n            Some(set) =\u003e set,\n            None =\u003e return Vec::new(),\n        };\n        let start = offset as usize;\n        let end = (offset + limit) as usize;\n        key_set\n            .iter()\n            .skip(start)\n            .take(end - start)\n            .cloned()\n            .collect()\n    }\n\n    pub fn update_contract(\u0026mut self) -\u003e Result\u003cPromise, AuthError\u003e {\n        if env::predecessor_account_id() != self.manager {\n            return Err(AuthError::Unauthorized);\n        }\n        let code = env::input()\n            .filter(|input| !input.is_empty())\n            .ok_or(AuthError::MissingInput)?\n            .to_vec();\n        log!(\"Upgrading contract by manager: {}\", self.manager);\n        AuthEvent::ContractUpgraded {\n            manager: self.manager.clone(),\n            timestamp: env::block_timestamp_ms(),\n        }\n        .emit();\n        Ok(Promise::new(env::current_account_id())\n            .deploy_contract(code)\n            .function_call(\n                \"migrate\".to_string(),\n                NO_ARGS,\n                NearToken::from_near(0),\n                CALL_GAS,\n            ))\n    }\n\n    pub fn set_manager(\n        \u0026mut self,\n        caller: \u0026AccountId,\n        new_manager: AccountId,\n    ) -\u003e Result\u003c(), AuthError\u003e {\n        if caller != \u0026self.manager {\n            return Err(AuthError::Unauthorized);\n        }\n        log!(\"Changing manager from {} to {}\", caller, new_manager);\n        self.manager = new_manager.clone();\n        AuthEvent::ManagerChanged {\n            old_manager: caller.clone(),\n            new_manager,\n            timestamp: env::block_timestamp_ms(),\n        }\n        .emit();\n        Ok(())\n    }\n}\n\nimpl Default for AuthContractState {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n","traces":[{"line":33,"address":[1440143,1439680],"length":1,"stats":{"Line":1}},{"line":35,"address":[1439697],"length":1,"stats":{"Line":1}},{"line":36,"address":[1439723],"length":1,"stats":{"Line":1}},{"line":37,"address":[1439790],"length":1,"stats":{"Line":1}},{"line":38,"address":[1439859],"length":1,"stats":{"Line":1}},{"line":39,"address":[1439931],"length":1,"stats":{"Line":1}},{"line":44,"address":[1441079,1440176],"length":1,"stats":{"Line":0}},{"line":50,"address":[1440313,1440227],"length":1,"stats":{"Line":0}},{"line":51,"address":[1440357],"length":1,"stats":{"Line":0}},{"line":52,"address":[1440350],"length":1,"stats":{"Line":0}},{"line":55,"address":[1440417,1440381],"length":1,"stats":{"Line":0}},{"line":56,"address":[1440478],"length":1,"stats":{"Line":0}},{"line":57,"address":[1440471],"length":1,"stats":{"Line":0}},{"line":60,"address":[1440499],"length":1,"stats":{"Line":0}},{"line":61,"address":[1440527,1440566],"length":1,"stats":{"Line":0}},{"line":62,"address":[1440571],"length":1,"stats":{"Line":0}},{"line":66,"address":[1440548,1440603],"length":1,"stats":{"Line":0}},{"line":67,"address":[1440664,1440610],"length":1,"stats":{"Line":0}},{"line":68,"address":[1440671],"length":1,"stats":{"Line":0}},{"line":69,"address":[1440725,1440802],"length":1,"stats":{"Line":0}},{"line":71,"address":[1440595],"length":1,"stats":{"Line":0}},{"line":74,"address":[1441036,1440636],"length":1,"stats":{"Line":0}},{"line":75,"address":[1440876,1440997],"length":1,"stats":{"Line":0}},{"line":76,"address":[1441057,1441028,1440885],"length":1,"stats":{"Line":0}},{"line":79,"address":[1440834],"length":1,"stats":{"Line":0}},{"line":82,"address":[1441120,1443637,1443527],"length":1,"stats":{"Line":2}},{"line":91,"address":[1441379,1441284],"length":1,"stats":{"Line":4}},{"line":92,"address":[1441616],"length":1,"stats":{"Line":2}},{"line":93,"address":[1441680],"length":1,"stats":{"Line":0}},{"line":96,"address":[1441731,1441657],"length":1,"stats":{"Line":3}},{"line":97,"address":[1424860,1424848],"length":1,"stats":{"Line":2}},{"line":100,"address":[1441777],"length":1,"stats":{"Line":1}},{"line":106,"address":[1441909,1441985],"length":1,"stats":{"Line":4}},{"line":107,"address":[1442066],"length":1,"stats":{"Line":2}},{"line":108,"address":[1442528,1442322],"length":1,"stats":{"Line":4}},{"line":109,"address":[1442331],"length":1,"stats":{"Line":2}},{"line":110,"address":[1442472],"length":1,"stats":{"Line":2}},{"line":111,"address":[1442396],"length":1,"stats":{"Line":2}},{"line":114,"address":[1442606],"length":1,"stats":{"Line":2}},{"line":117,"address":[1442036,1442675],"length":1,"stats":{"Line":4}},{"line":118,"address":[1442727],"length":1,"stats":{"Line":2}},{"line":119,"address":[1442764],"length":1,"stats":{"Line":0}},{"line":121,"address":[1442803,1442753],"length":1,"stats":{"Line":4}},{"line":122,"address":[1442903],"length":1,"stats":{"Line":0}},{"line":124,"address":[1442816],"length":1,"stats":{"Line":2}},{"line":126,"address":[1443073,1442938],"length":1,"stats":{"Line":4}},{"line":127,"address":[1443104,1442947,1443536],"length":1,"stats":{"Line":4}},{"line":130,"address":[1443112],"length":1,"stats":{"Line":2}},{"line":131,"address":[1443179,1443230],"length":1,"stats":{"Line":4}},{"line":135,"address":[1443490],"length":1,"stats":{"Line":2}},{"line":138,"address":[1444929,1444907,1443664],"length":1,"stats":{"Line":0}},{"line":144,"address":[1443709,1443765],"length":1,"stats":{"Line":0}},{"line":145,"address":[1443797],"length":1,"stats":{"Line":0}},{"line":148,"address":[1443951,1444920,1443776,1443828,1443933],"length":1,"stats":{"Line":0}},{"line":151,"address":[1443820,1443941],"length":1,"stats":{"Line":0}},{"line":153,"address":[1443926],"length":1,"stats":{"Line":0}},{"line":158,"address":[1444108,1444163],"length":1,"stats":{"Line":0}},{"line":159,"address":[1444169],"length":1,"stats":{"Line":0}},{"line":162,"address":[1444239,1444208],"length":1,"stats":{"Line":0}},{"line":163,"address":[1444275],"length":1,"stats":{"Line":0}},{"line":164,"address":[1444319],"length":1,"stats":{"Line":0}},{"line":165,"address":[1444340],"length":1,"stats":{"Line":0}},{"line":168,"address":[1425102,1425088],"length":1,"stats":{"Line":0}},{"line":170,"address":[1444451],"length":1,"stats":{"Line":0}},{"line":175,"address":[1444537,1444245],"length":1,"stats":{"Line":0}},{"line":176,"address":[1444561,1444612],"length":1,"stats":{"Line":0}},{"line":180,"address":[1444864],"length":1,"stats":{"Line":0}},{"line":183,"address":[1446914,1447018,1444944],"length":1,"stats":{"Line":1}},{"line":193,"address":[1445096,1445190],"length":1,"stats":{"Line":2}},{"line":194,"address":[1445225],"length":1,"stats":{"Line":1}},{"line":197,"address":[1445370,1446996,1445265,1445201,1445388],"length":1,"stats":{"Line":5}},{"line":200,"address":[1445378,1445257],"length":1,"stats":{"Line":2}},{"line":202,"address":[1445363],"length":1,"stats":{"Line":1}},{"line":207,"address":[1445545,1445600],"length":1,"stats":{"Line":2}},{"line":208,"address":[1445606],"length":1,"stats":{"Line":0}},{"line":212,"address":[1445643],"length":1,"stats":{"Line":1}},{"line":213,"address":[1445679],"length":1,"stats":{"Line":1}},{"line":218,"address":[1445920,1445864],"length":1,"stats":{"Line":2}},{"line":219,"address":[1445946],"length":1,"stats":{"Line":0}},{"line":222,"address":[1445939],"length":1,"stats":{"Line":1}},{"line":223,"address":[1445991],"length":1,"stats":{"Line":1}},{"line":224,"address":[1446083,1446218],"length":1,"stats":{"Line":2}},{"line":225,"address":[1446249,1446923,1446092],"length":1,"stats":{"Line":2}},{"line":228,"address":[1446257],"length":1,"stats":{"Line":1}},{"line":229,"address":[1446319,1446370],"length":1,"stats":{"Line":2}},{"line":230,"address":[1446483,1446534],"length":1,"stats":{"Line":2}},{"line":234,"address":[1446800],"length":1,"stats":{"Line":1}},{"line":237,"address":[1448604,1447040,1448527],"length":1,"stats":{"Line":0}},{"line":238,"address":[1447242,1447098,1447065],"length":1,"stats":{"Line":0}},{"line":241,"address":[1447231,1447090],"length":1,"stats":{"Line":0}},{"line":242,"address":[1447173],"length":1,"stats":{"Line":0}},{"line":243,"address":[1447190],"length":1,"stats":{"Line":0}},{"line":245,"address":[1447224,1447323,1447487],"length":1,"stats":{"Line":0}},{"line":246,"address":[1448540,1447508],"length":1,"stats":{"Line":0}},{"line":248,"address":[1425376,1425386],"length":1,"stats":{"Line":0}},{"line":250,"address":[1448562],"length":1,"stats":{"Line":0}},{"line":254,"address":[1447666,1447424,1447712,1447539],"length":1,"stats":{"Line":0}},{"line":255,"address":[1447784],"length":1,"stats":{"Line":0}},{"line":257,"address":[1448142],"length":1,"stats":{"Line":0}},{"line":258,"address":[1448190,1448257],"length":1,"stats":{"Line":0}},{"line":263,"address":[1447799],"length":1,"stats":{"Line":0}},{"line":264,"address":[1447843],"length":1,"stats":{"Line":0}},{"line":265,"address":[1447887],"length":1,"stats":{"Line":0}},{"line":266,"address":[1447908],"length":1,"stats":{"Line":0}},{"line":269,"address":[1425408,1425422],"length":1,"stats":{"Line":0}},{"line":271,"address":[1448019],"length":1,"stats":{"Line":0}},{"line":275,"address":[1447820],"length":1,"stats":{"Line":0}},{"line":278,"address":[1450180,1448640,1450229],"length":1,"stats":{"Line":0}},{"line":279,"address":[1448867,1448673,1450220,1448748,1448849],"length":1,"stats":{"Line":0}},{"line":282,"address":[1448857,1448740],"length":1,"stats":{"Line":0}},{"line":283,"address":[1448898,1448833],"length":1,"stats":{"Line":0}},{"line":286,"address":[1448906],"length":1,"stats":{"Line":0}},{"line":287,"address":[1448976],"length":1,"stats":{"Line":0}},{"line":290,"address":[1449116,1448955,1449016,1449134,1450193],"length":1,"stats":{"Line":0}},{"line":293,"address":[1449008,1449124],"length":1,"stats":{"Line":0}},{"line":294,"address":[1449109,1449171],"length":1,"stats":{"Line":0}},{"line":295,"address":[1449351,1449217,1449397],"length":1,"stats":{"Line":0}},{"line":296,"address":[1449469],"length":1,"stats":{"Line":0}},{"line":298,"address":[1449805],"length":1,"stats":{"Line":0}},{"line":299,"address":[1449846,1449910],"length":1,"stats":{"Line":0}},{"line":304,"address":[1449484],"length":1,"stats":{"Line":0}},{"line":305,"address":[1449528],"length":1,"stats":{"Line":0}},{"line":306,"address":[1449549],"length":1,"stats":{"Line":0}},{"line":309,"address":[1425456,1425469],"length":1,"stats":{"Line":0}},{"line":311,"address":[1449656,1449710],"length":1,"stats":{"Line":0}},{"line":314,"address":[1449679],"length":1,"stats":{"Line":0}},{"line":317,"address":[1451052,1450256],"length":1,"stats":{"Line":0}},{"line":318,"address":[1450308],"length":1,"stats":{"Line":0}},{"line":319,"address":[1450363],"length":1,"stats":{"Line":0}},{"line":321,"address":[1450382],"length":1,"stats":{"Line":0}},{"line":322,"address":[1450404],"length":1,"stats":{"Line":0}},{"line":323,"address":[1450473,1450419],"length":1,"stats":{"Line":0}},{"line":325,"address":[1450454,1450612,1450558,1450653,1450844],"length":1,"stats":{"Line":0}},{"line":329,"address":[1450575,1450619],"length":1,"stats":{"Line":0}},{"line":331,"address":[1450865],"length":1,"stats":{"Line":0}},{"line":332,"address":[1450943],"length":1,"stats":{"Line":0}},{"line":333,"address":[1450996],"length":1,"stats":{"Line":0}},{"line":337,"address":[1450796],"length":1,"stats":{"Line":0}},{"line":340,"address":[1451088],"length":1,"stats":{"Line":1}},{"line":341,"address":[1451148],"length":1,"stats":{"Line":1}},{"line":343,"address":[1425600,1425539,1425504,1425617],"length":1,"stats":{"Line":4}},{"line":346,"address":[1451200],"length":1,"stats":{"Line":1}},{"line":347,"address":[1451267],"length":1,"stats":{"Line":1}},{"line":348,"address":[1451329],"length":1,"stats":{"Line":1}},{"line":349,"address":[1451395],"length":1,"stats":{"Line":1}},{"line":350,"address":[1451380],"length":1,"stats":{"Line":0}},{"line":352,"address":[1451416],"length":1,"stats":{"Line":1}},{"line":353,"address":[1451431,1451466,1451546],"length":1,"stats":{"Line":2}},{"line":354,"address":[1451480,1451567],"length":1,"stats":{"Line":2}},{"line":357,"address":[1451528,1451632],"length":1,"stats":{"Line":1}},{"line":362,"address":[1453334,1451648,1453387],"length":1,"stats":{"Line":1}},{"line":363,"address":[1451678,1451975],"length":1,"stats":{"Line":2}},{"line":364,"address":[1451994],"length":1,"stats":{"Line":1}},{"line":366,"address":[1452218,1451842,1452136,1452024,1451885],"length":1,"stats":{"Line":5}},{"line":367,"address":[1425657,1425648],"length":1,"stats":{"Line":2}},{"line":368,"address":[1452122,1451877],"length":1,"stats":{"Line":2}},{"line":370,"address":[1452310],"length":1,"stats":{"Line":1}},{"line":372,"address":[1452550],"length":1,"stats":{"Line":1}},{"line":373,"address":[1452600],"length":1,"stats":{"Line":1}},{"line":376,"address":[1453232,1453120,1452883,1452793],"length":1,"stats":{"Line":4}},{"line":377,"address":[1452918,1452843],"length":1,"stats":{"Line":2}},{"line":379,"address":[1452998,1452926],"length":1,"stats":{"Line":2}},{"line":380,"address":[1453006],"length":1,"stats":{"Line":1}},{"line":381,"address":[1453041],"length":1,"stats":{"Line":1}},{"line":386,"address":[1454347,1454378,1453424],"length":1,"stats":{"Line":2}},{"line":391,"address":[1453559,1453459],"length":1,"stats":{"Line":2}},{"line":392,"address":[1453589],"length":1,"stats":{"Line":1}},{"line":394,"address":[1453624,1453565],"length":1,"stats":{"Line":2}},{"line":395,"address":[1453878],"length":1,"stats":{"Line":1}},{"line":397,"address":[1454023],"length":1,"stats":{"Line":1}},{"line":399,"address":[1454105],"length":1,"stats":{"Line":1}},{"line":402,"address":[1454330],"length":1,"stats":{"Line":1}}],"covered":79,"coverable":172},{"path":["/","code","contracts","auth-onsocial","src","state_versions.rs"],"content":"use crate::types::KeyInfo;\nuse near_sdk::borsh::{BorshDeserialize, BorshSerialize};\nuse near_sdk::store::{IterableSet, LookupMap, Vector};\nuse near_sdk::AccountId;\n\n#[derive(BorshSerialize, BorshDeserialize)]\n#[borsh(crate = \"near_sdk::borsh\")]\npub struct StateV010 {\n    pub version: String,\n    pub keys: LookupMap\u003cAccountId, IterableSet\u003cKeyInfo\u003e\u003e,\n    pub last_active_timestamps: LookupMap\u003cAccountId, u64\u003e,\n    pub registered_accounts: Vector\u003cAccountId\u003e,\n    pub manager: AccountId,\n}\n\n#[derive(BorshSerialize, BorshDeserialize)]\n#[borsh(crate = \"near_sdk::borsh\")]\npub struct StateV011 {\n    pub version: String,\n    pub keys: LookupMap\u003cAccountId, IterableSet\u003cKeyInfo\u003e\u003e,\n    pub last_active_timestamps: LookupMap\u003cAccountId, u64\u003e,\n    pub registered_accounts: Vector\u003cAccountId\u003e,\n    pub manager: AccountId,\n    pub max_keys_per_account: u32,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","code","contracts","auth-onsocial","src","tests.rs"],"content":"#[cfg(test)]\nmod tests {\n    use crate::{\n        errors::AuthError,\n        state::AuthContractState,\n        state_versions::{StateV010, StateV011},\n        types::{KeyInfo, RotateKeyArgs},\n        AuthContract,\n    };\n    use near_sdk::borsh;\n    use near_sdk::store::{IterableSet, LookupMap, Vector};\n    use near_sdk::test_utils::{accounts, get_logs, VMContextBuilder};\n    use near_sdk::{env, testing_env, AccountId, PublicKey};\n\n    fn setup_context(predecessor: \u0026AccountId) -\u003e VMContextBuilder {\n        let mut context = VMContextBuilder::new();\n        context\n            .predecessor_account_id(predecessor.clone())\n            .current_account_id(\"auth.testnet\".parse().unwrap())\n            .block_timestamp(1_000_000_000_000);\n        context\n    }\n\n    fn setup_contract() -\u003e AuthContractState {\n        let context = setup_context(\u0026accounts(0));\n        testing_env!(context.build());\n        AuthContractState::new()\n    }\n\n    #[test]\n    fn test_register_and_get_keys() {\n        let mut state = setup_contract();\n        let account_id = accounts(0);\n        let pk1: PublicKey = \"ed25519:6E8sCci9badyRkbrr2TV5CC3oKTo7Znny8mG5k415kZU\"\n            .parse()\n            .unwrap();\n        let pk2: PublicKey = \"ed25519:4jS5V2kAWg7fW7V5F8mD8Z5Y3mJ5gG5kAW7fW7V5F8mD\"\n            .parse()\n            .unwrap();\n\n        state\n            .register_key(\u0026account_id, \u0026account_id, pk1.clone(), None, false, None)\n            .unwrap();\n        state\n            .register_key(\u0026account_id, \u0026account_id, pk2.clone(), None, false, None)\n            .unwrap();\n\n        let keys = state.get_keys(\u0026account_id, 1, 0);\n        assert_eq!(keys.len(), 1, \"Should return 1 key\");\n\n        let keys = state.get_keys(\u0026account_id, 2, 1);\n        assert_eq!(keys.len(), 1, \"Should return 1 key\");\n\n        let keys = state.get_keys(\u0026account_id, 10, 0);\n        assert_eq!(keys.len(), 2, \"Should return all 2 keys\");\n\n        let key_info = state.get_key_info(\u0026account_id, \u0026pk1).unwrap();\n        assert_eq!(key_info.public_key, pk1, \"Key info should match\");\n    }\n\n    #[test]\n    fn test_rotate_key() {\n        let mut state = setup_contract();\n        let account_id = accounts(0);\n        let old_pk: PublicKey = \"ed25519:6E8sCci9badyRkbrr2TV5CC3oKTo7Znny8mG5k415kZU\"\n            .parse()\n            .unwrap();\n        let new_pk: PublicKey = \"ed25519:4jS5V2kAWg7fW7V5F8mD8Z5Y3mJ5gG5kAW7fW7V5F8mD\"\n            .parse()\n            .unwrap();\n\n        state\n            .register_key(\n                \u0026account_id,\n                \u0026account_id,\n                old_pk.clone(),\n                Some(30),\n                true,\n                Some(2),\n            )\n            .unwrap();\n\n        state\n            .rotate_key(\n                \u0026account_id,\n                RotateKeyArgs {\n                    account_id: account_id.clone(),\n                    old_public_key: old_pk.clone(),\n                    new_public_key: new_pk.clone(),\n                    expiration_days: Some(60),\n                    is_multi_sig: false,\n                    multi_sig_threshold: None,\n                },\n            )\n            .unwrap();\n\n        assert!(\n            state.get_key_info(\u0026account_id, \u0026old_pk).is_none(),\n            \"Old key should be removed\"\n        );\n        let new_key_info = state.get_key_info(\u0026account_id, \u0026new_pk).unwrap();\n        assert_eq!(new_key_info.public_key, new_pk, \"New key should match\");\n        assert!(\n            new_key_info.expiration_timestamp.is_some(),\n            \"Expiration should be set\"\n        );\n        assert_eq!(\n            new_key_info.is_multi_sig, false,\n            \"Multi-sig should be false\"\n        );\n        assert_eq!(\n            new_key_info.multi_sig_threshold, None,\n            \"Threshold should be None\"\n        );\n    }\n\n    #[test]\n    fn test_rotate_key_unauthorized() {\n        let mut state = setup_contract();\n        let account_id = accounts(0);\n        let caller = accounts(1);\n        let old_pk: PublicKey = \"ed25519:6E8sCci9badyRkbrr2TV5CC3oKTo7Znny8mG5k415kZU\"\n            .parse()\n            .unwrap();\n        let new_pk: PublicKey = \"ed25519:4jS5V2kAWg7fW7V5F8mD8Z5Y3mJ5gG5kAW7fW7V5F8mD\"\n            .parse()\n            .unwrap();\n\n        state\n            .register_key(\u0026account_id, \u0026account_id, old_pk.clone(), None, false, None)\n            .unwrap();\n\n        let result = state.rotate_key(\n            \u0026caller,\n            RotateKeyArgs {\n                account_id: account_id.clone(),\n                old_public_key: old_pk,\n                new_public_key: new_pk,\n                expiration_days: None,\n                is_multi_sig: false,\n                multi_sig_threshold: None,\n            },\n        );\n        assert_eq!(result, Err(AuthError::Unauthorized));\n    }\n\n    #[test]\n    fn test_rotate_key_not_found() {\n        let mut state = setup_contract();\n        let account_id = accounts(0);\n        let old_pk: PublicKey = \"ed25519:6E8sCci9badyRkbrr2TV5CC3oKTo7Znny8mG5k415kZU\"\n            .parse()\n            .unwrap();\n        let new_pk: PublicKey = \"ed25519:4jS5V2kAWg7fW7V5F8mD8Z5Y3mJ5gG5kAW7fW7V5F8mD\"\n            .parse()\n            .unwrap();\n\n        let result = state.rotate_key(\n            \u0026account_id,\n            RotateKeyArgs {\n                account_id: account_id.clone(),\n                old_public_key: old_pk,\n                new_public_key: new_pk,\n                expiration_days: None,\n                is_multi_sig: false,\n                multi_sig_threshold: None,\n            },\n        );\n        assert_eq!(result, Err(AuthError::KeyNotFound));\n    }\n\n    #[test]\n    fn test_update_contract_no_input() {\n        let mut state = setup_contract();\n        let manager = accounts(0);\n        let context = setup_context(\u0026manager);\n        testing_env!(context.build());\n        let result = state.update_contract();\n        match result {\n            Err(AuthError::MissingInput) =\u003e (), // Expected error\n            Err(_e) =\u003e panic!(\"Expected MissingInput error, got different error\"),\n            Ok(_) =\u003e panic!(\"Expected MissingInput error, got Ok\"),\n        }\n    }\n\n    #[test]\n    fn test_update_contract_unauthorized() {\n        let mut state = setup_contract();\n        let non_manager = accounts(1);\n        let context = setup_context(\u0026non_manager);\n        let mut vm_context = context.build();\n        vm_context.input = vec![1, 2, 3];\n        testing_env!(vm_context);\n        let result = state.update_contract();\n        match result {\n            Err(AuthError::Unauthorized) =\u003e (), // Expected error\n            Err(_e) =\u003e panic!(\"Expected Unauthorized error, got different error\"),\n            Ok(_) =\u003e panic!(\"Expected Unauthorized error, got Ok\"),\n        }\n    }\n\n    #[test]\n    fn test_update_contract_authorized() {\n        let mut state = setup_contract();\n        let manager = accounts(0);\n        let context = setup_context(\u0026manager);\n        let mut vm_context = context.build();\n        vm_context.input = vec![1, 2, 3];\n        testing_env!(vm_context);\n        let result = state.update_contract();\n        assert!(result.is_ok(), \"Expected successful contract update\");\n    }\n\n    #[test]\n    fn test_set_manager_authorized() {\n        let mut state = setup_contract();\n        let manager = accounts(0);\n        let new_manager = accounts(1);\n        let context = setup_context(\u0026manager);\n        testing_env!(context.build());\n        let result = state.set_manager(\u0026manager, new_manager.clone());\n        assert!(result.is_ok());\n        assert_eq!(state.manager, new_manager);\n    }\n\n    #[test]\n    fn test_set_manager_unauthorized() {\n        let mut state = setup_contract();\n        let non_manager = accounts(1);\n        let new_manager = accounts(2);\n        let context = setup_context(\u0026non_manager);\n        testing_env!(context.build());\n        let result = state.set_manager(\u0026non_manager, new_manager);\n        assert_eq!(result, Err(AuthError::Unauthorized));\n    }\n\n    #[test]\n    fn test_migration_from_010_to_011() {\n        let manager = accounts(0);\n        let account_id = accounts(1);\n        let pk: PublicKey = \"ed25519:6E8sCci9badyRkbrr2TV5CC3oKTo7Znny8mG5k415kZU\"\n            .parse()\n            .unwrap();\n        let context = setup_context(\u0026manager);\n        testing_env!(context.build());\n\n        let mut state_v010 = StateV010 {\n            version: \"0.1.0\".to_string(),\n            keys: LookupMap::new(b\"k\".to_vec()),\n            last_active_timestamps: LookupMap::new(b\"t\".to_vec()),\n            registered_accounts: Vector::new(b\"a\".to_vec()),\n            manager: manager.clone(),\n        };\n        let mut key_set = IterableSet::new(b\"s\".to_vec());\n        key_set.insert(KeyInfo {\n            public_key: pk.clone(),\n            expiration_timestamp: None,\n            is_multi_sig: false,\n            multi_sig_threshold: None,\n        });\n        key_set.flush();\n        state_v010.keys.insert(account_id.clone(), key_set);\n        state_v010.keys.flush();\n        state_v010.registered_accounts.push(account_id.clone());\n        state_v010.registered_accounts.flush();\n        state_v010\n            .last_active_timestamps\n            .insert(account_id.clone(), 0);\n        let state_bytes = borsh::to_vec(\u0026state_v010).expect(\"Failed to serialize state\");\n        env::state_write(\u0026state_bytes);\n\n        let new_contract = AuthContract::migrate();\n\n        assert_eq!(\n            new_contract.state.version, \"0.1.1\",\n            \"Version should be 0.1.1\"\n        );\n        assert_eq!(\n            new_contract.state.manager, manager,\n            \"Manager should be preserved\"\n        );\n        assert_eq!(\n            new_contract.state.registered_accounts.len(),\n            1,\n            \"Accounts should be preserved\"\n        );\n        assert_eq!(\n            new_contract.state.max_keys_per_account, 100,\n            \"Max keys should be initialized\"\n        );\n        let keys = new_contract.state.get_keys(\u0026account_id, 10, 0);\n        assert_eq!(keys.len(), 1, \"Should have one key\");\n        assert_eq!(keys[0].public_key, pk, \"Key should match\");\n\n        let logs = get_logs();\n        assert!(\n            logs.contains(\u0026\"Migrating from state version 0.1.0\".to_string()),\n            \"Expected migration log\"\n        );\n        assert!(logs.contains(\u0026\"EVENT_JSON:{\\\"standard\\\":\\\"nep297\\\",\\\"version\\\":\\\"1.0.0\\\",\\\"event\\\":\\\"state_migrated\\\",\\\"data\\\":{\\\"old_version\\\":\\\"0.1.0\\\",\\\"new_version\\\":\\\"0.1.1\\\"}}\".to_string()), \"Expected state_migrated event\");\n    }\n\n    #[test]\n    fn test_migration_from_011_to_011() {\n        let manager = accounts(0);\n        let account_id = accounts(1);\n        let pk: PublicKey = \"ed25519:6E8sCci9badyRkbrr2TV5CC3oKTo7Znny8mG5k415kZU\"\n            .parse()\n            .unwrap();\n        let context = setup_context(\u0026manager);\n        testing_env!(context.build());\n\n        let mut state_v011 = StateV011 {\n            version: \"0.1.1\".to_string(),\n            keys: LookupMap::new(b\"k\".to_vec()),\n            last_active_timestamps: LookupMap::new(b\"t\".to_vec()),\n            registered_accounts: Vector::new(b\"a\".to_vec()),\n            manager: manager.clone(),\n            max_keys_per_account: 50,\n        };\n        let mut key_set = IterableSet::new(b\"s\".to_vec());\n        key_set.insert(KeyInfo {\n            public_key: pk.clone(),\n            expiration_timestamp: None,\n            is_multi_sig: false,\n            multi_sig_threshold: None,\n        });\n        key_set.flush();\n        state_v011.keys.insert(account_id.clone(), key_set);\n        state_v011.keys.flush();\n        state_v011.registered_accounts.push(account_id.clone());\n        state_v011.registered_accounts.flush();\n        state_v011\n            .last_active_timestamps\n            .insert(account_id.clone(), 0);\n        let state_bytes = borsh::to_vec(\u0026state_v011).expect(\"Failed to serialize state\");\n        env::state_write(\u0026state_bytes);\n\n        let new_contract = AuthContract::migrate();\n\n        assert_eq!(\n            new_contract.state.version, \"0.1.1\",\n            \"Version should be 0.1.1\"\n        );\n        assert_eq!(\n            new_contract.state.manager, manager,\n            \"Manager should be preserved\"\n        );\n        assert_eq!(\n            new_contract.state.registered_accounts.len(),\n            1,\n            \"Accounts should be preserved\"\n        );\n        assert_eq!(\n            new_contract.state.max_keys_per_account, 50,\n            \"Max keys should be preserved\"\n        );\n        let keys = new_contract.state.get_keys(\u0026account_id, 10, 0);\n        assert_eq!(keys.len(), 1, \"Should have one key\");\n        assert_eq!(keys[0].public_key, pk, \"Key should match\");\n\n        let logs = get_logs();\n        assert!(\n            logs.contains(\u0026\"State is already at latest version\".to_string()),\n            \"Expected latest version log\"\n        );\n    }\n\n    #[test]\n    fn test_migration_no_prior_state() {\n        let manager = accounts(0);\n        let context = setup_context(\u0026manager);\n        testing_env!(context.build());\n\n        let new_contract = AuthContract::migrate();\n\n        assert_eq!(\n            new_contract.state.version, \"0.1.1\",\n            \"Version should be 0.1.1\"\n        );\n        assert_eq!(\n            new_contract.state.manager, manager,\n            \"Manager should be current account\"\n        );\n        assert_eq!(\n            new_contract.state.registered_accounts.len(),\n            0,\n            \"No accounts should exist\"\n        );\n        assert_eq!(\n            new_contract.state.max_keys_per_account, 100,\n            \"Max keys should be initialized\"\n        );\n\n        let logs = get_logs();\n        assert!(\n            logs.contains(\u0026\"No valid prior state found, initializing new state\".to_string()),\n            \"Expected no prior state log\"\n        );\n    }\n\n    #[test]\n    fn test_migration_corrupted_state() {\n        let manager = accounts(0);\n        let context = setup_context(\u0026manager);\n        testing_env!(context.build());\n\n        env::state_write(\u0026vec![0u8; 10]);\n\n        let new_contract = AuthContract::migrate();\n\n        assert_eq!(\n            new_contract.state.version, \"0.1.1\",\n            \"Version should be 0.1.1\"\n        );\n        assert_eq!(\n            new_contract.state.manager, manager,\n            \"Manager should be current account\"\n        );\n        assert_eq!(\n            new_contract.state.registered_accounts.len(),\n            0,\n            \"No accounts should exist\"\n        );\n        assert_eq!(\n            new_contract.state.max_keys_per_account, 100,\n            \"Max keys should be initialized\"\n        );\n\n        let logs = get_logs();\n        assert!(\n            logs.contains(\u0026\"No valid prior state found, initializing new state\".to_string()),\n            \"Expected no prior state log\"\n        );\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","code","contracts","auth-onsocial","src","types.rs"],"content":"use near_sdk::borsh::{BorshDeserialize, BorshSerialize};\nuse near_sdk::serde::{Deserialize, Serialize};\nuse near_sdk::AccountId;\nuse near_sdk::PublicKey;\nuse near_sdk_macros::NearSchema;\nuse std::cmp::Ordering;\n\n#[derive(Clone, Serialize, Deserialize, BorshSerialize, BorshDeserialize, NearSchema)]\n#[serde(crate = \"near_sdk::serde\")]\n#[borsh(crate = \"near_sdk::borsh\")]\n#[abi(json, borsh)]\npub struct KeyInfo {\n    pub public_key: PublicKey,\n    pub expiration_timestamp: Option\u003cu64\u003e,\n    pub is_multi_sig: bool,\n    pub multi_sig_threshold: Option\u003cu32\u003e,\n}\n\n#[derive(Clone, Serialize, Deserialize, BorshSerialize, BorshDeserialize, NearSchema)]\n#[serde(crate = \"near_sdk::serde\")]\n#[borsh(crate = \"near_sdk::borsh\")]\n#[abi(json, borsh)]\npub struct RotateKeyArgs {\n    pub account_id: AccountId,\n    pub old_public_key: PublicKey,\n    pub new_public_key: PublicKey,\n    pub expiration_days: Option\u003cu32\u003e,\n    pub is_multi_sig: bool,\n    pub multi_sig_threshold: Option\u003cu32\u003e,\n}\n\nimpl PartialEq for KeyInfo {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        self.public_key == other.public_key\n    }\n}\n\nimpl Eq for KeyInfo {}\n\nimpl std::hash::Hash for KeyInfo {\n    fn hash\u003cH: std::hash::Hasher\u003e(\u0026self, state: \u0026mut H) {\n        self.public_key.hash(state);\n    }\n}\n\nimpl PartialOrd for KeyInfo {\n    fn partial_cmp(\u0026self, other: \u0026Self) -\u003e Option\u003cOrdering\u003e {\n        Some(self.public_key.cmp(\u0026other.public_key))\n    }\n}\n\nimpl Ord for KeyInfo {\n    fn cmp(\u0026self, other: \u0026Self) -\u003e Ordering {\n        self.public_key.cmp(\u0026other.public_key)\n    }\n}\n","traces":[{"line":19,"address":[1468400],"length":1,"stats":{"Line":0}},{"line":20,"address":[1468414],"length":1,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[1468448],"length":1,"stats":{"Line":0}},{"line":34,"address":[1468462],"length":1,"stats":{"Line":0}},{"line":39,"address":[1468496],"length":1,"stats":{"Line":2}},{"line":40,"address":[1468510],"length":1,"stats":{"Line":2}}],"covered":2,"coverable":8},{"path":["/","code","contracts","ft-wrapper-onsocial","src","admin.rs"],"content":"use crate::errors::FtWrapperError;\nuse crate::events::FtWrapperEvent;\nuse crate::state::FtWrapperContractState;\nuse near_sdk::json_types::U128;\nuse near_sdk::{env, AccountId};\n\npub fn add_supported_token(\n    state: \u0026mut FtWrapperContractState,\n    token: AccountId,\n) -\u003e Result\u003c(), FtWrapperError\u003e {\n    let caller = env::predecessor_account_id();\n    if !state.is_manager(\u0026caller) {\n        return Err(FtWrapperError::Unauthorized);\n    }\n    if state.supported_tokens.contains(\u0026token) {\n        return Err(FtWrapperError::TokenNotSupported); // Token already exists\n    }\n    state.supported_tokens.push(token.clone());\n    FtWrapperEvent::TokenAdded { token }.emit();\n    Ok(())\n}\n\npub fn remove_supported_token(\n    state: \u0026mut FtWrapperContractState,\n    token: AccountId,\n) -\u003e Result\u003c(), FtWrapperError\u003e {\n    let caller = env::predecessor_account_id();\n    if !state.is_manager(\u0026caller) {\n        return Err(FtWrapperError::Unauthorized);\n    }\n    if let Some(index) = state.supported_tokens.iter().position(|t| t == \u0026token) {\n        state.supported_tokens.remove(index);\n        FtWrapperEvent::TokenRemoved { token }.emit();\n        Ok(())\n    } else {\n        Err(FtWrapperError::TokenNotSupported)\n    }\n}\n\npub fn set_cross_contract_gas(\n    state: \u0026mut FtWrapperContractState,\n    gas_tgas: u64,\n) -\u003e Result\u003c(), FtWrapperError\u003e {\n    let caller = env::predecessor_account_id();\n    if !state.is_manager(\u0026caller) {\n        return Err(FtWrapperError::Unauthorized);\n    }\n    state.cross_contract_gas = gas_tgas * 1_000_000_000_000; // Convert TGas to Gas\n    FtWrapperEvent::GasUpdated { gas_tgas }.emit();\n    Ok(())\n}\n\npub fn set_storage_deposit(\n    state: \u0026mut FtWrapperContractState,\n    storage_deposit: U128,\n) -\u003e Result\u003c(), FtWrapperError\u003e {\n    let caller = env::predecessor_account_id();\n    if !state.is_manager(\u0026caller) {\n        return Err(FtWrapperError::Unauthorized);\n    }\n    if storage_deposit.0 \u003c 1_250_000_000_000_000_000_000 {\n        // Minimum 0.00125 NEAR\n        return Err(FtWrapperError::AmountTooLow);\n    }\n    state.storage_deposit = storage_deposit;\n    FtWrapperEvent::StorageDepositUpdated { storage_deposit }.emit();\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","code","contracts","ft-wrapper-onsocial","src","errors.rs"],"content":"use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};\nuse near_sdk::FunctionError;\nuse near_sdk_macros::NearSchema;\n\n#[derive(Debug, NearSchema, BorshSerialize, BorshDeserialize)]\n#[abi(borsh)]\npub enum FtWrapperError {\n    TokenNotSupported,\n    AmountTooLow,\n    InvalidDeposit,\n    AccountNotRegistered,\n    InsufficientStorageBalance,\n    NonZeroBalance,\n    Unauthorized,\n    LowBalance,\n}\n\nimpl FunctionError for FtWrapperError {\n    fn panic(\u0026self) -\u003e ! {\n        panic!(\n            \"{}\",\n            match self {\n                FtWrapperError::TokenNotSupported =\u003e \"Token not supported\",\n                FtWrapperError::AmountTooLow =\u003e \"Amount too low\",\n                FtWrapperError::InvalidDeposit =\u003e \"Invalid deposit amount\",\n                FtWrapperError::AccountNotRegistered =\u003e \"Account not registered\",\n                FtWrapperError::InsufficientStorageBalance =\u003e \"Insufficient storage balance\",\n                FtWrapperError::NonZeroBalance =\u003e \"Non-zero token balance\",\n                FtWrapperError::Unauthorized =\u003e \"Unauthorized access\",\n                FtWrapperError::LowBalance =\u003e \"Contract balance too low\",\n            }\n        )\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","code","contracts","ft-wrapper-onsocial","src","events.rs"],"content":"use near_sdk::json_types::U128;\nuse near_sdk::{near, AccountId};\n\n#[near(event_json(standard = \"nep297\"))]\npub enum FtWrapperEvent {\n    #[event_version(\"1.0.0\")]\n    TokenAdded { token: AccountId },\n    #[event_version(\"1.0.0\")]\n    TokenRemoved { token: AccountId },\n    #[event_version(\"1.0.0\")]\n    FtTransfer {\n        token: AccountId,\n        sender: AccountId,\n        receiver: AccountId,\n        amount: U128,\n    },\n    #[event_version(\"1.0.0\")]\n    StorageDeposited {\n        token: AccountId,\n        account_id: AccountId,\n        amount: U128,\n    },\n    #[event_version(\"1.0.0\")]\n    StorageWithdrawn {\n        token: AccountId,\n        account_id: AccountId,\n        amount: U128,\n    },\n    #[event_version(\"1.0.0\")]\n    StorageUnregistered {\n        token: AccountId,\n        account_id: AccountId,\n    },\n    #[event_version(\"1.0.0\")]\n    GasUpdated { gas_tgas: u64 },\n    #[event_version(\"1.0.0\")]\n    LowBalance { balance: u128 },\n    #[event_version(\"1.0.0\")]\n    StorageDepositUpdated { storage_deposit: U128 },\n    #[event_version(\"1.0.0\")]\n    ContractUpgraded { manager: AccountId, timestamp: u64 },\n    #[event_version(\"1.0.0\")]\n    ManagerUpdated { new_manager: AccountId },\n    #[event_version(\"1.0.0\")]\n    StateMigrated {\n        old_version: String,\n        new_version: String,\n    },\n    #[event_version(\"1.0.0\")]\n    TransferFinalized {\n        token: AccountId,\n        recipient: AccountId,\n        amount: U128,\n        fee: U128,\n        source_chain: String,\n    },\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","code","contracts","ft-wrapper-onsocial","src","ft.rs"],"content":"use crate::errors::FtWrapperError;\nuse crate::events::FtWrapperEvent;\nuse crate::state::FtWrapperContractState;\nuse crate::types::{\n    BridgeTransferArgs, FinalizeTransferArgs, FtTransferArgs, RequestChainSignatureArgs,\n    StorageBalance,\n};\nuse crate::{ext_ft, ext_self};\nuse near_sdk::json_types::U128;\nuse near_sdk::{env, AccountId, Gas, NearToken, Promise};\n\npub fn ft_transfer(\n    state: \u0026mut FtWrapperContractState,\n    args: FtTransferArgs,\n) -\u003e Result\u003cPromise, FtWrapperError\u003e {\n    state.assert_balance()?;\n    if !state.supported_tokens.contains(\u0026args.token) {\n        return Err(FtWrapperError::TokenNotSupported);\n    }\n    if args.amount.0 == 0 {\n        return Err(FtWrapperError::AmountTooLow);\n    }\n\n    let sender_id = env::predecessor_account_id();\n\n    let sender_promise = ensure_registered(state, args.token.clone(), sender_id.clone())?;\n    let receiver_promise = ensure_registered(state, args.token.clone(), args.receiver_id.clone())?;\n\n    let transfer_promise = ext_ft::ext(args.token.clone())\n        .with_static_gas(Gas::from_tgas(state.cross_contract_gas))\n        .ft_transfer(args.receiver_id.clone(), args.amount, args.memo.clone());\n\n    FtWrapperEvent::FtTransfer {\n        token: args.token,\n        sender: sender_id,\n        receiver: args.receiver_id,\n        amount: args.amount,\n    }\n    .emit();\n\n    Ok(sender_promise.and(receiver_promise).then(transfer_promise))\n}\n\npub fn ensure_registered(\n    state: \u0026mut FtWrapperContractState,\n    token: AccountId,\n    account_id: AccountId,\n) -\u003e Result\u003cPromise, FtWrapperError\u003e {\n    state.assert_balance()?;\n    if !state.supported_tokens.contains(\u0026token) {\n        return Err(FtWrapperError::TokenNotSupported);\n    }\n\n    let storage_balance = state\n        .storage_balances\n        .get(\u0026(token.clone(), account_id.clone()));\n\n    if storage_balance.is_some() {\n        Ok(Promise::new(env::current_account_id()))\n    } else {\n        let deposit_amount = state.storage_deposit.0;\n        let contract_balance = env::account_balance().as_yoctonear();\n        if contract_balance \u003c deposit_amount {\n            FtWrapperEvent::LowBalance {\n                balance: contract_balance,\n            }\n            .emit();\n            return Err(FtWrapperError::LowBalance);\n        }\n        let deposit_promise = ext_ft::ext(token.clone())\n            .with_static_gas(Gas::from_tgas(state.cross_contract_gas))\n            .with_attached_deposit(NearToken::from_yoctonear(deposit_amount))\n            .storage_deposit(Some(account_id.clone()), Some(true))\n            .then(\n                ext_self::ext(env::current_account_id())\n                    .with_static_gas(Gas::from_tgas(state.cross_contract_gas))\n                    .handle_storage_deposit(token.clone(), account_id.clone()),\n            );\n\n        FtWrapperEvent::StorageDeposited {\n            token: token.clone(),\n            account_id: account_id.clone(),\n            amount: U128(deposit_amount),\n        }\n        .emit();\n\n        Ok(deposit_promise)\n    }\n}\n\npub fn ft_balance_of(\n    state: \u0026FtWrapperContractState,\n    token: AccountId,\n    account_id: AccountId,\n) -\u003e Promise {\n    if !state.supported_tokens.contains(\u0026token) {\n        env::panic_str(\"Token not supported\");\n    }\n    ext_ft::ext(token)\n        .with_static_gas(Gas::from_tgas(state.cross_contract_gas))\n        .ft_balance_of(account_id)\n}\n\npub fn storage_deposit(\n    state: \u0026mut FtWrapperContractState,\n    token: AccountId,\n    account_id: Option\u003cAccountId\u003e,\n    registration_only: Option\u003cbool\u003e,\n) -\u003e Result\u003cStorageBalance, FtWrapperError\u003e {\n    state.assert_balance()?;\n    if !state.supported_tokens.contains(\u0026token) {\n        return Err(FtWrapperError::TokenNotSupported);\n    }\n\n    let account_id = account_id.unwrap_or_else(|| env::predecessor_account_id());\n    let registration_only = registration_only.unwrap_or(false);\n\n    let storage_balance = state\n        .storage_balances\n        .get(\u0026(token.clone(), account_id.clone()));\n\n    if let Some(balance) = storage_balance {\n        return Ok(balance.clone());\n    }\n\n    let deposit_amount = state.storage_deposit.0;\n    let contract_balance = env::account_balance().as_yoctonear();\n    if contract_balance \u003c deposit_amount {\n        FtWrapperEvent::LowBalance {\n            balance: contract_balance,\n        }\n        .emit();\n        return Err(FtWrapperError::LowBalance);\n    }\n\n    let deposit_promise = ext_ft::ext(token.clone())\n        .with_static_gas(Gas::from_tgas(state.cross_contract_gas))\n        .with_attached_deposit(NearToken::from_yoctonear(deposit_amount))\n        .storage_deposit(Some(account_id.clone()), Some(registration_only))\n        .then(\n            ext_self::ext(env::current_account_id())\n                .with_static_gas(Gas::from_tgas(state.cross_contract_gas))\n                .handle_storage_deposit(token.clone(), account_id.clone()),\n        );\n\n    state.storage_balances.insert(\n        (token.clone(), account_id.clone()),\n        StorageBalance {\n            total: U128(deposit_amount),\n            available: U128(0),\n        },\n    );\n\n    FtWrapperEvent::StorageDeposited {\n        token,\n        account_id,\n        amount: U128(deposit_amount),\n    }\n    .emit();\n\n    deposit_promise.then(Promise::new(env::current_account_id()));\n\n    Ok(StorageBalance {\n        total: U128(deposit_amount),\n        available: U128(0),\n    })\n}\n\npub fn storage_withdraw(\n    state: \u0026mut FtWrapperContractState,\n    token: AccountId,\n    amount: Option\u003cU128\u003e,\n) -\u003e Result\u003cStorageBalance, FtWrapperError\u003e {\n    if !state.supported_tokens.contains(\u0026token) {\n        return Err(FtWrapperError::TokenNotSupported);\n    }\n\n    let account_id = env::predecessor_account_id();\n\n    let storage_balance = state\n        .storage_balances\n        .get(\u0026(token.clone(), account_id.clone()))\n        .ok_or(FtWrapperError::AccountNotRegistered)?;\n\n    let available = storage_balance.available.0;\n    let withdraw_amount = amount.map(|a| a.0).unwrap_or(available);\n\n    if withdraw_amount \u003e available {\n        return Err(FtWrapperError::InsufficientStorageBalance);\n    }\n\n    let new_balance = StorageBalance {\n        total: storage_balance.total,\n        available: U128(available - withdraw_amount),\n    };\n    state\n        .storage_balances\n        .insert((token.clone(), account_id.clone()), new_balance.clone());\n\n    if withdraw_amount \u003e 0 {\n        Promise::new(account_id.clone()).transfer(NearToken::from_yoctonear(withdraw_amount));\n    }\n\n    FtWrapperEvent::StorageWithdrawn {\n        token,\n        account_id,\n        amount: U128(withdraw_amount),\n    }\n    .emit();\n\n    Ok(new_balance)\n}\n\npub fn storage_balance_of(\n    state: \u0026FtWrapperContractState,\n    token: AccountId,\n    account_id: AccountId,\n) -\u003e Promise {\n    if !state.supported_tokens.contains(\u0026token) {\n        env::panic_str(\"Token not supported\");\n    }\n    ext_ft::ext(token)\n        .with_static_gas(Gas::from_tgas(state.cross_contract_gas))\n        .storage_balance_of(account_id)\n}\n\npub fn storage_balance_bounds(state: \u0026FtWrapperContractState, token: AccountId) -\u003e Promise {\n    if !state.supported_tokens.contains(\u0026token) {\n        env::panic_str(\"Token not supported\");\n    }\n    ext_ft::ext(token)\n        .with_static_gas(Gas::from_tgas(state.cross_contract_gas))\n        .storage_balance_bounds()\n}\n\npub fn storage_unregister(\n    state: \u0026mut FtWrapperContractState,\n    token: AccountId,\n    force: Option\u003cbool\u003e,\n) -\u003e Result\u003cbool, FtWrapperError\u003e {\n    if !state.supported_tokens.contains(\u0026token) {\n        return Err(FtWrapperError::TokenNotSupported);\n    }\n\n    let account_id = env::predecessor_account_id();\n\n    let storage_balance = state\n        .storage_balances\n        .get(\u0026(token.clone(), account_id.clone()));\n\n    if storage_balance.is_none() {\n        return Ok(false);\n    }\n\n    let force = force.unwrap_or(false);\n    let balance = storage_balance.unwrap();\n\n    if !force {\n        ext_ft::ext(token.clone())\n            .with_static_gas(Gas::from_tgas(state.cross_contract_gas))\n            .ft_balance_of(account_id.clone())\n            .then(\n                ext_self::ext(env::current_account_id())\n                    .with_static_gas(Gas::from_tgas(state.cross_contract_gas))\n                    .handle_balance_check(token.clone(), account_id.clone()),\n            );\n        return Ok(false);\n    }\n\n    if balance.total.0 \u003e 0 {\n        Promise::new(account_id.clone()).transfer(NearToken::from_yoctonear(balance.total.0));\n    }\n\n    state\n        .storage_balances\n        .remove(\u0026(token.clone(), account_id.clone()));\n\n    FtWrapperEvent::StorageUnregistered { token, account_id }.emit();\n\n    Ok(true)\n}\n\npub fn handle_balance_check(\n    state: \u0026mut FtWrapperContractState,\n    token: AccountId,\n    account_id: AccountId,\n    balance: U128,\n) -\u003e bool {\n    if balance.0 != 0 {\n        env::log_str(\"Non-zero balance detected, unregistration aborted\");\n        return false;\n    }\n\n    let storage_balance = state\n        .storage_balances\n        .get(\u0026(token.clone(), account_id.clone()));\n    if let Some(balance) = storage_balance {\n        if balance.total.0 \u003e 0 {\n            Promise::new(account_id.clone()).transfer(NearToken::from_yoctonear(balance.total.0));\n        }\n        state\n            .storage_balances\n            .remove(\u0026(token.clone(), account_id.clone()));\n        FtWrapperEvent::StorageUnregistered { token, account_id }.emit();\n        return true;\n    }\n\n    false\n}\n\npub fn handle_registration(\n    state: \u0026mut FtWrapperContractState,\n    token: AccountId,\n    account_id: AccountId,\n) -\u003e Promise {\n    let storage_balance = state\n        .storage_balances\n        .get(\u0026(token.clone(), account_id.clone()));\n    if storage_balance.is_none() {\n        let bounds_promise = ext_ft::ext(token.clone())\n            .with_static_gas(Gas::from_tgas(state.cross_contract_gas))\n            .storage_balance_bounds()\n            .then(\n                ext_self::ext(env::current_account_id())\n                    .with_static_gas(Gas::from_tgas(state.cross_contract_gas))\n                    .handle_storage_deposit(token.clone(), account_id.clone()),\n            );\n        bounds_promise\n    } else {\n        Promise::new(env::current_account_id())\n    }\n}\n\npub fn handle_storage_deposit(\n    state: \u0026mut FtWrapperContractState,\n    token: AccountId,\n    account_id: AccountId,\n) -\u003e Promise {\n    state\n        .assert_balance()\n        .unwrap_or_else(|_| env::panic_str(\"Low balance\"));\n    let deposit_amount = state.storage_deposit.0;\n    let deposit_promise = ext_ft::ext(token.clone())\n        .with_static_gas(Gas::from_tgas(state.cross_contract_gas))\n        .with_attached_deposit(NearToken::from_yoctonear(deposit_amount))\n        .storage_deposit(Some(account_id.clone()), Some(true));\n\n    FtWrapperEvent::StorageDeposited {\n        token,\n        account_id,\n        amount: U128(deposit_amount),\n    }\n    .emit();\n\n    deposit_promise\n}\n\npub fn request_chain_signature(\n    state: \u0026mut FtWrapperContractState,\n    args: RequestChainSignatureArgs,\n) -\u003e Result\u003cPromise, FtWrapperError\u003e {\n    state.assert_balance()?;\n    if !state.supported_tokens.contains(\u0026args.token) {\n        return Err(FtWrapperError::TokenNotSupported);\n    }\n    let sender_id = env::predecessor_account_id();\n    let promise = ensure_registered(state, args.token.clone(), sender_id)?;\n    Ok(\n        promise.then(Promise::new(state.relayer_contract.clone()).function_call(\n            \"relay_meta_transaction\".to_string(),\n            vec![],\n            NearToken::from_yoctonear(0),\n            Gas::from_tgas(state.cross_contract_gas),\n        )),\n    )\n}\n\npub fn bridge_transfer(\n    state: \u0026mut FtWrapperContractState,\n    args: BridgeTransferArgs,\n) -\u003e Result\u003cPromise, FtWrapperError\u003e {\n    state.assert_balance()?;\n    if !state.supported_tokens.contains(\u0026args.token) {\n        return Err(FtWrapperError::TokenNotSupported);\n    }\n    if args.amount.0 == 0 {\n        return Err(FtWrapperError::AmountTooLow);\n    }\n    let sender_id = env::predecessor_account_id();\n    let promise = ensure_registered(state, args.token.clone(), sender_id)?;\n    Ok(\n        promise.then(Promise::new(state.relayer_contract.clone()).function_call(\n            \"relay_meta_transaction\".to_string(),\n            vec![],\n            NearToken::from_yoctonear(0),\n            Gas::from_tgas(state.cross_contract_gas),\n        )),\n    )\n}\n\npub fn finalize_transfer(\n    state: \u0026mut FtWrapperContractState,\n    args: FinalizeTransferArgs,\n) -\u003e Result\u003cPromise, FtWrapperError\u003e {\n    state.assert_balance()?;\n    if !state.supported_tokens.contains(\u0026args.token) {\n        return Err(FtWrapperError::TokenNotSupported);\n    }\n    if args.amount.0 == 0 {\n        return Err(FtWrapperError::AmountTooLow);\n    }\n\n    // Verify MPC signature (simplified; in practice, integrate with NEAR MPC or light client)\n    if !verify_mpc_signature(\u0026args.signature, \u0026args.message_payload) {\n        return Err(FtWrapperError::Unauthorized);\n    }\n\n    // Calculate fees (based on fee_percentage or fixed amount)\n    let fee = (args.amount.0 as u128 * state.fee_percentage as u128) / 10000; // fee_percentage is in basis points\n    let net_amount = args\n        .amount\n        .0\n        .checked_sub(fee)\n        .ok_or(FtWrapperError::AmountTooLow)?;\n\n    // Ensure recipient is registered\n    let recipient_promise = ensure_registered(state, args.token.clone(), args.recipient.clone())?;\n\n    // Handle token type: mint for bridged, release for native\n    let transfer_promise = if args.is_native {\n        // Release native tokens from lock\n        ext_ft::ext(args.token.clone())\n            .with_static_gas(Gas::from_tgas(state.cross_contract_gas))\n            .ft_transfer(\n                args.recipient.clone(),\n                U128(net_amount),\n                Some(\"Incoming bridge transfer\".to_string()),\n            )\n    } else {\n        // Mint bridged tokens\n        ext_ft::ext(args.token.clone())\n            .with_static_gas(Gas::from_tgas(state.cross_contract_gas))\n            .ft_transfer(\n                args.recipient.clone(),\n                U128(net_amount),\n                Some(\"Mint bridged tokens\".to_string()),\n            )\n    };\n\n    // Transfer fees to relayer if applicable\n    let fee_promise = if fee \u003e 0 {\n        Promise::new(state.relayer_contract.clone()).transfer(NearToken::from_yoctonear(fee))\n    } else {\n        Promise::new(env::current_account_id())\n    };\n\n    // Emit event for finalization\n    FtWrapperEvent::TransferFinalized {\n        token: args.token.clone(),\n        recipient: args.recipient.clone(),\n        amount: U128(net_amount),\n        fee: U128(fee),\n        source_chain: args.source_chain.clone(),\n    }\n    .emit();\n\n    Ok(recipient_promise.and(fee_promise).then(transfer_promise))\n}\n\n// Placeholder for MPC signature verification (to be implemented with NEAR MPC or light client)\nfn verify_mpc_signature(_signature: \u0026[u8], _payload: \u0026[u8]) -\u003e bool {\n    // TODO: Integrate NEAR MPC verification or light client proof validation\n    // For now, return true for demonstration (replace with actual logic)\n    true\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","code","contracts","ft-wrapper-onsocial","src","lib.rs"],"content":"use crate::errors::FtWrapperError;\nuse crate::events::FtWrapperEvent;\nuse crate::state::FtWrapperContractState;\nuse crate::types::{\n    BridgeTransferArgs, FinalizeTransferArgs, FtTransferArgs, RequestChainSignatureArgs,\n    StorageBalance, StorageBalanceBounds,\n}; // Added FinalizeTransferArgs\nuse near_sdk::json_types::U128;\nuse near_sdk::{env, ext_contract, near, AccountId, Gas, NearToken, PanicOnDefault, Promise};\n\nmod admin;\nmod errors;\nmod events;\nmod ft;\nmod state;\nmod state_versions;\nmod types;\n\n#[ext_contract(ext_ft)]\npub trait FungibleToken {\n    fn ft_transfer(\u0026mut self, receiver_id: AccountId, amount: U128, memo: Option\u003cString\u003e);\n    fn storage_deposit(\n        \u0026mut self,\n        account_id: Option\u003cAccountId\u003e,\n        registration_only: Option\u003cbool\u003e,\n    ) -\u003e StorageBalance;\n    fn ft_balance_of(\u0026self, account_id: AccountId) -\u003e U128;\n    fn storage_balance_of(\u0026self, account_id: AccountId) -\u003e Option\u003cStorageBalance\u003e;\n    fn storage_balance_bounds(\u0026self) -\u003e StorageBalanceBounds;\n}\n\n#[ext_contract(ext_self)]\npub trait SelfCallback {\n    fn handle_registration(\u0026mut self, token: AccountId, account_id: AccountId) -\u003e Promise;\n    fn handle_storage_deposit(\u0026mut self, token: AccountId, account_id: AccountId) -\u003e Promise;\n    fn handle_balance_check(\u0026mut self, token: AccountId, account_id: AccountId) -\u003e bool;\n}\n\n#[near(contract_state)]\n#[derive(PanicOnDefault)]\npub struct FtWrapperContract {\n    state: FtWrapperContractState,\n}\n\n#[near]\nimpl FtWrapperContract {\n    #[init]\n    pub fn new(manager: AccountId, relayer_contract: AccountId, storage_deposit: U128) -\u003e Self {\n        Self {\n            state: FtWrapperContractState::new(manager, relayer_contract, storage_deposit),\n        }\n    }\n\n    #[private]\n    #[init(ignore_state)]\n    pub fn migrate() -\u003e Self {\n        use near_sdk::borsh;\n        use state_versions::{StateV010, StateV011};\n\n        const CURRENT_VERSION: \u0026str = \"0.1.1\";\n\n        // Read raw state bytes, default to empty if none\n        let state_bytes: Vec\u003cu8\u003e = env::state_read().unwrap_or_default();\n\n        // Try current version (0.1.1)\n        if let Ok(state) = borsh::from_slice::\u003cFtWrapperContractState\u003e(\u0026state_bytes) {\n            if state.version == CURRENT_VERSION {\n                env::log_str(\"State is already at latest version\");\n                return Self { state };\n            }\n        }\n\n        // Try version 0.1.1\n        if let Ok(old_state) = borsh::from_slice::\u003cStateV011\u003e(\u0026state_bytes) {\n            if old_state.version == \"0.1.1\" {\n                env::log_str(\"Migrating from state version 0.1.1\");\n                let new_state = FtWrapperContractState {\n                    version: CURRENT_VERSION.to_string(),\n                    manager: old_state.manager,\n                    relayer_contract: old_state.relayer_contract,\n                    supported_tokens: old_state.supported_tokens,\n                    storage_deposit: old_state.storage_deposit,\n                    cross_contract_gas: old_state.cross_contract_gas,\n                    storage_balances: old_state.storage_balances,\n                    min_balance: old_state.min_balance,\n                    max_balance: old_state.max_balance,\n                    fee_percentage: old_state.fee_percentage,\n                };\n                FtWrapperEvent::StateMigrated {\n                    old_version: \"0.1.1\".to_string(),\n                    new_version: CURRENT_VERSION.to_string(),\n                }\n                .emit();\n                return Self { state: new_state };\n            }\n        }\n\n        // Try version 0.1.0\n        if let Ok(old_state) = borsh::from_slice::\u003cStateV010\u003e(\u0026state_bytes) {\n            if old_state.version == \"0.1.0\" {\n                env::log_str(\"Migrating from state version 0.1.0\");\n                let new_state = FtWrapperContractState {\n                    version: CURRENT_VERSION.to_string(),\n                    manager: old_state.manager,\n                    relayer_contract: old_state.relayer_contract,\n                    supported_tokens: old_state.supported_tokens,\n                    storage_deposit: old_state.storage_deposit,\n                    cross_contract_gas: old_state.cross_contract_gas,\n                    storage_balances: old_state.storage_balances,\n                    min_balance: old_state.min_balance,\n                    max_balance: old_state.max_balance,\n                    fee_percentage: 0,\n                };\n                FtWrapperEvent::StateMigrated {\n                    old_version: \"0.1.0\".to_string(),\n                    new_version: CURRENT_VERSION.to_string(),\n                }\n                .emit();\n                return Self { state: new_state };\n            }\n        }\n\n        env::log_str(\"No valid prior state found, initializing new state\");\n        Self {\n            state: FtWrapperContractState::new(\n                env::current_account_id(),\n                env::current_account_id(),\n                U128(1_250_000_000_000_000_000_000),\n            ),\n        }\n    }\n\n    #[payable]\n    #[handle_result]\n    pub fn deposit(\u0026mut self) -\u003e Result\u003c(), FtWrapperError\u003e {\n        let caller = env::predecessor_account_id();\n        if !self.state.is_manager(\u0026caller) {\n            return Err(FtWrapperError::Unauthorized);\n        }\n        let deposit = env::attached_deposit().as_yoctonear();\n        let balance = env::account_balance().as_yoctonear() + deposit;\n        if balance \u003e self.state.max_balance {\n            let excess = balance - self.state.max_balance;\n            Promise::new(caller).transfer(NearToken::from_yoctonear(excess));\n        }\n        Ok(())\n    }\n\n    pub fn ft_transfer(\u0026mut self, args: FtTransferArgs) -\u003e Promise {\n        self.ft_transfer_internal(args).expect(\"FT transfer failed\")\n    }\n\n    pub fn request_chain_signature(\u0026mut self, args: RequestChainSignatureArgs) -\u003e Promise {\n        self.request_chain_signature_internal(args)\n            .expect(\"Chain signature request failed\")\n    }\n\n    pub fn bridge_transfer(\u0026mut self, args: BridgeTransferArgs) -\u003e Promise {\n        self.bridge_transfer_internal(args)\n            .expect(\"Bridge transfer failed\")\n    }\n\n    pub fn finalize_transfer(\u0026mut self, args: FinalizeTransferArgs) -\u003e Promise {\n        self.finalize_transfer_internal(args)\n            .expect(\"Finalize transfer failed\")\n    }\n\n    pub fn storage_deposit(\n        \u0026mut self,\n        token: AccountId,\n        account_id: Option\u003cAccountId\u003e,\n        registration_only: Option\u003cbool\u003e,\n    ) -\u003e StorageBalance {\n        self.storage_deposit_internal(token, account_id, registration_only)\n            .expect(\"Storage deposit failed\")\n    }\n\n    #[payable]\n    pub fn storage_withdraw(\u0026mut self, token: AccountId, amount: Option\u003cU128\u003e) -\u003e StorageBalance {\n        self.storage_withdraw_internal(token, amount)\n            .expect(\"Storage withdraw failed\")\n    }\n\n    pub fn storage_balance_of(\u0026self, token: AccountId, account_id: AccountId) -\u003e Promise {\n        self.storage_balance_of_internal(token, account_id)\n    }\n\n    pub fn storage_balance_bounds(\u0026self, token: AccountId) -\u003e Promise {\n        self.storage_balance_bounds_internal(token)\n    }\n\n    #[payable]\n    pub fn storage_unregister(\u0026mut self, token: AccountId, force: Option\u003cbool\u003e) -\u003e bool {\n        self.storage_unregister_internal(token, force)\n            .expect(\"Storage unregister failed\")\n    }\n\n    #[handle_result]\n    pub fn add_supported_token(\u0026mut self, token: AccountId) -\u003e Result\u003c(), FtWrapperError\u003e {\n        self.add_supported_token_internal(token)\n    }\n\n    #[handle_result]\n    pub fn remove_supported_token(\u0026mut self, token: AccountId) -\u003e Result\u003c(), FtWrapperError\u003e {\n        self.remove_supported_token_internal(token)\n    }\n\n    #[handle_result]\n    pub fn set_cross_contract_gas(\u0026mut self, gas_tgas: u64) -\u003e Result\u003c(), FtWrapperError\u003e {\n        self.set_cross_contract_gas_internal(gas_tgas)\n    }\n\n    #[handle_result]\n    pub fn set_storage_deposit(\u0026mut self, storage_deposit: U128) -\u003e Result\u003c(), FtWrapperError\u003e {\n        self.set_storage_deposit_internal(storage_deposit)\n    }\n\n    #[handle_result]\n    pub fn set_manager(\u0026mut self, new_manager: AccountId) -\u003e Result\u003c(), FtWrapperError\u003e {\n        self.state.set_manager(new_manager.clone())?;\n        FtWrapperEvent::ManagerUpdated { new_manager }.emit();\n        Ok(())\n    }\n\n    pub fn get_supported_tokens(\u0026self) -\u003e Vec\u003cAccountId\u003e {\n        self.state\n            .supported_tokens\n            .iter()\n            .map(|token| token.clone())\n            .collect()\n    }\n\n    pub fn ft_balance_of(\u0026mut self, token: AccountId, account_id: AccountId) -\u003e Promise {\n        self.ft_balance_of_internal(token, account_id)\n    }\n\n    #[handle_result]\n    pub fn update_contract(\u0026mut self) -\u003e Result\u003cPromise, FtWrapperError\u003e {\n        let caller = env::predecessor_account_id();\n        if !self.state.is_manager(\u0026caller) {\n            return Err(FtWrapperError::Unauthorized);\n        }\n        let code = env::input().ok_or(FtWrapperError::Unauthorized)?.to_vec();\n        FtWrapperEvent::ContractUpgraded {\n            manager: caller.clone(),\n            timestamp: env::block_timestamp_ms(),\n        }\n        .emit();\n        Ok(Promise::new(env::current_account_id())\n            .deploy_contract(code)\n            .function_call(\n                \"migrate\".to_string(),\n                vec![],\n                NearToken::from_yoctonear(0),\n                Gas::from_tgas(250),\n            ))\n    }\n\n    #[private]\n    pub fn handle_registration(\u0026mut self, token: AccountId, account_id: AccountId) -\u003e Promise {\n        self.handle_registration_internal(token, account_id)\n    }\n\n    #[private]\n    pub fn handle_storage_deposit(\u0026mut self, token: AccountId, account_id: AccountId) -\u003e Promise {\n        self.handle_storage_deposit_internal(token, account_id)\n    }\n\n    #[private]\n    pub fn handle_balance_check(\n        \u0026mut self,\n        token: AccountId,\n        account_id: AccountId,\n        balance: U128,\n    ) -\u003e bool {\n        crate::ft::handle_balance_check(\u0026mut self.state, token, account_id, balance)\n    }\n\n    fn ft_transfer_internal(\u0026mut self, args: FtTransferArgs) -\u003e Result\u003cPromise, FtWrapperError\u003e {\n        crate::ft::ft_transfer(\u0026mut self.state, args)\n    }\n\n    fn request_chain_signature_internal(\n        \u0026mut self,\n        args: RequestChainSignatureArgs,\n    ) -\u003e Result\u003cPromise, FtWrapperError\u003e {\n        crate::ft::request_chain_signature(\u0026mut self.state, args)\n    }\n\n    fn bridge_transfer_internal(\n        \u0026mut self,\n        args: BridgeTransferArgs,\n    ) -\u003e Result\u003cPromise, FtWrapperError\u003e {\n        crate::ft::bridge_transfer(\u0026mut self.state, args)\n    }\n\n    fn finalize_transfer_internal(\n        \u0026mut self,\n        args: FinalizeTransferArgs,\n    ) -\u003e Result\u003cPromise, FtWrapperError\u003e {\n        crate::ft::finalize_transfer(\u0026mut self.state, args)\n    }\n\n    fn storage_deposit_internal(\n        \u0026mut self,\n        token: AccountId,\n        account_id: Option\u003cAccountId\u003e,\n        registration_only: Option\u003cbool\u003e,\n    ) -\u003e Result\u003cStorageBalance, FtWrapperError\u003e {\n        crate::ft::storage_deposit(\u0026mut self.state, token, account_id, registration_only)\n    }\n\n    fn storage_withdraw_internal(\n        \u0026mut self,\n        token: AccountId,\n        amount: Option\u003cU128\u003e,\n    ) -\u003e Result\u003cStorageBalance, FtWrapperError\u003e {\n        crate::ft::storage_withdraw(\u0026mut self.state, token, amount)\n    }\n\n    fn storage_balance_of_internal(\u0026self, token: AccountId, account_id: AccountId) -\u003e Promise {\n        crate::ft::storage_balance_of(\u0026self.state, token, account_id)\n    }\n\n    fn storage_balance_bounds_internal(\u0026self, token: AccountId) -\u003e Promise {\n        crate::ft::storage_balance_bounds(\u0026self.state, token)\n    }\n\n    fn storage_unregister_internal(\n        \u0026mut self,\n        token: AccountId,\n        force: Option\u003cbool\u003e,\n    ) -\u003e Result\u003cbool, FtWrapperError\u003e {\n        crate::ft::storage_unregister(\u0026mut self.state, token, force)\n    }\n\n    fn add_supported_token_internal(\u0026mut self, token: AccountId) -\u003e Result\u003c(), FtWrapperError\u003e {\n        crate::admin::add_supported_token(\u0026mut self.state, token)\n    }\n\n    fn remove_supported_token_internal(\u0026mut self, token: AccountId) -\u003e Result\u003c(), FtWrapperError\u003e {\n        crate::admin::remove_supported_token(\u0026mut self.state, token)\n    }\n\n    fn set_cross_contract_gas_internal(\u0026mut self, gas_tgas: u64) -\u003e Result\u003c(), FtWrapperError\u003e {\n        crate::admin::set_cross_contract_gas(\u0026mut self.state, gas_tgas)\n    }\n\n    fn set_storage_deposit_internal(\n        \u0026mut self,\n        storage_deposit: U128,\n    ) -\u003e Result\u003c(), FtWrapperError\u003e {\n        crate::admin::set_storage_deposit(\u0026mut self.state, storage_deposit)\n    }\n\n    fn ft_balance_of_internal(\u0026mut self, token: AccountId, account_id: AccountId) -\u003e Promise {\n        crate::ft::ft_balance_of(\u0026mut self.state, token, account_id)\n    }\n\n    fn handle_registration_internal(\u0026mut self, token: AccountId, account_id: AccountId) -\u003e Promise {\n        crate::ft::handle_registration(\u0026mut self.state, token, account_id)\n    }\n\n    fn handle_storage_deposit_internal(\n        \u0026mut self,\n        token: AccountId,\n        account_id: AccountId,\n    ) -\u003e Promise {\n        crate::ft::handle_storage_deposit(\u0026mut self.state, token, account_id)\n    }\n}\n\n#[cfg(test)]\nmod tests;\n","traces":[],"covered":0,"coverable":0},{"path":["/","code","contracts","ft-wrapper-onsocial","src","state.rs"],"content":"use crate::errors::FtWrapperError;\nuse crate::types::StorageBalance;\nuse near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};\nuse near_sdk::json_types::U128;\nuse near_sdk::store::LookupMap;\nuse near_sdk::{env, AccountId};\nuse near_sdk_macros::NearSchema;\n\n#[derive(BorshSerialize, BorshDeserialize, NearSchema)]\n#[abi(borsh)]\npub struct FtWrapperContractState {\n    pub version: String,\n    pub manager: AccountId,\n    pub relayer_contract: AccountId,\n    pub supported_tokens: Vec\u003cAccountId\u003e,\n    pub storage_deposit: U128,\n    pub cross_contract_gas: u64,\n    pub storage_balances: LookupMap\u003c(AccountId, AccountId), StorageBalance\u003e,\n    pub min_balance: u128,\n    pub max_balance: u128,\n    pub fee_percentage: u64, // Added for 0.1.1\n}\n\nimpl FtWrapperContractState {\n    pub fn new(manager: AccountId, relayer_contract: AccountId, storage_deposit: U128) -\u003e Self {\n        Self {\n            version: \"0.1.1\".to_string(), // Updated to 0.1.1\n            manager,\n            relayer_contract,\n            supported_tokens: Vec::new(),\n            storage_deposit,\n            cross_contract_gas: 100_000_000_000_000,\n            storage_balances: LookupMap::new(b\"s\".to_vec()),\n            min_balance: 10_000_000_000_000_000_000_000_000,\n            max_balance: 1_000_000_000_000_000_000_000_000_000,\n            fee_percentage: 0, // Default value\n        }\n    }\n\n    pub fn is_manager(\u0026self, account_id: \u0026AccountId) -\u003e bool {\n        \u0026self.manager == account_id\n    }\n\n    pub fn assert_balance(\u0026self) -\u003e Result\u003c(), FtWrapperError\u003e {\n        let balance = env::account_balance().as_yoctonear();\n        if balance \u003c self.min_balance {\n            return Err(FtWrapperError::LowBalance);\n        }\n        Ok(())\n    }\n\n    pub fn set_manager(\u0026mut self, new_manager: AccountId) -\u003e Result\u003c(), FtWrapperError\u003e {\n        let caller = env::predecessor_account_id();\n        if !self.is_manager(\u0026caller) {\n            return Err(FtWrapperError::Unauthorized);\n        }\n        self.manager = new_manager.clone();\n        Ok(())\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","code","contracts","ft-wrapper-onsocial","src","state_versions.rs"],"content":"use crate::types::StorageBalance;\nuse near_sdk::borsh::{BorshDeserialize, BorshSerialize};\nuse near_sdk::json_types::U128;\nuse near_sdk::store::LookupMap;\nuse near_sdk::AccountId;\n\n/// State for version 0.1.0\n#[derive(BorshSerialize, BorshDeserialize)]\npub struct StateV010 {\n    pub version: String,\n    pub manager: AccountId,\n    pub relayer_contract: AccountId,\n    pub supported_tokens: Vec\u003cAccountId\u003e,\n    pub storage_deposit: U128,\n    pub cross_contract_gas: u64,\n    pub storage_balances: LookupMap\u003c(AccountId, AccountId), StorageBalance\u003e,\n    pub min_balance: u128,\n    pub max_balance: u128,\n}\n\n/// State for version 0.1.1 (adds fee_percentage)\n#[derive(BorshSerialize, BorshDeserialize)]\npub struct StateV011 {\n    pub version: String,\n    pub manager: AccountId,\n    pub relayer_contract: AccountId,\n    pub supported_tokens: Vec\u003cAccountId\u003e,\n    pub storage_deposit: U128,\n    pub cross_contract_gas: u64,\n    pub storage_balances: LookupMap\u003c(AccountId, AccountId), StorageBalance\u003e,\n    pub min_balance: u128,\n    pub max_balance: u128,\n    pub fee_percentage: u64,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","code","contracts","ft-wrapper-onsocial","src","tests.rs"],"content":"#[cfg(test)]\nmod tests {\n    use crate::{\n        state_versions::{StateV010, StateV011},\n        FtWrapperContract,\n    };\n    use near_sdk::borsh;\n    use near_sdk::json_types::U128;\n    use near_sdk::store::LookupMap;\n    use near_sdk::{\n        env,\n        test_utils::{get_logs, VMContextBuilder},\n        testing_env, AccountId, NearToken,\n    };\n\n    fn setup_context(predecessor: AccountId) -\u003e VMContextBuilder {\n        let mut context = VMContextBuilder::new();\n        context\n            .predecessor_account_id(predecessor)\n            .current_account_id(\"ft-wrapper.testnet\".parse::\u003cAccountId\u003e().unwrap())\n            .block_timestamp(1_000_000_000_000)\n            .attached_deposit(NearToken::from_yoctonear(0));\n        context\n    }\n\n    #[test]\n    fn test_add_supported_token() {\n        let manager: AccountId = \"manager.testnet\".parse().unwrap();\n        let context = setup_context(manager.clone());\n        testing_env!(context.build());\n\n        let mut contract = FtWrapperContract::new(\n            manager.clone(),\n            \"relayer.testnet\".parse().unwrap(),\n            U128(1_250_000_000_000_000_000_000),\n        );\n        let token: AccountId = \"token.testnet\".parse().unwrap();\n\n        contract\n            .add_supported_token(token.clone())\n            .expect(\"Failed to add token\");\n        assert!(\n            contract.state.supported_tokens.contains(\u0026token),\n            \"Token should be supported\"\n        );\n\n        let logs = get_logs();\n        assert!(\n            logs.contains(\u0026\"EVENT_JSON:{\\\"standard\\\":\\\"nep297\\\",\\\"version\\\":\\\"1.0.0\\\",\\\"event\\\":\\\"token_added\\\",\\\"data\\\":{\\\"token\\\":\\\"token.testnet\\\"}}\".to_string()),\n            \"Expected token_added event, got: {:?}\", logs\n        );\n    }\n\n    #[test]\n    fn test_migration_from_010_to_011() {\n        let manager: AccountId = \"manager.testnet\".parse().unwrap();\n        let context = setup_context(manager.clone());\n        testing_env!(context.build());\n\n        let token: AccountId = \"token.testnet\".parse().unwrap();\n        let state_v010 = StateV010 {\n            version: \"0.1.0\".to_string(),\n            manager: manager.clone(),\n            relayer_contract: \"relayer.testnet\".parse().unwrap(),\n            supported_tokens: vec![token.clone()],\n            storage_deposit: U128(1_250_000_000_000_000_000_000),\n            cross_contract_gas: 100_000_000_000_000,\n            storage_balances: LookupMap::new(b\"s\".to_vec()),\n            min_balance: 10_000_000_000_000_000_000_000_000,\n            max_balance: 1_000_000_000_000_000_000_000_000_000,\n        };\n        // Serialize state to Borsh\n        let state_bytes = borsh::to_vec(\u0026state_v010).expect(\"Failed to serialize state\");\n        env::state_write(\u0026state_bytes);\n\n        let new_contract = FtWrapperContract::migrate();\n\n        assert_eq!(\n            new_contract.state.version, \"0.1.1\",\n            \"Version should be 0.1.1\"\n        );\n        assert_eq!(\n            new_contract.state.manager, manager,\n            \"Manager should be preserved\"\n        );\n        assert_eq!(\n            new_contract.state.relayer_contract,\n            \"relayer.testnet\".parse::\u003cAccountId\u003e().unwrap(),\n            \"Relayer contract should be preserved\"\n        );\n        assert!(\n            new_contract.state.supported_tokens.contains(\u0026token),\n            \"Supported tokens should be preserved\"\n        );\n        assert_eq!(\n            new_contract.state.fee_percentage, 0,\n            \"Fee percentage should be initialized\"\n        );\n\n        let logs = get_logs();\n        assert!(\n            logs.contains(\u0026\"Migrating from state version 0.1.0\".to_string()),\n            \"Expected migration log, got: {:?}\",\n            logs\n        );\n        assert!(\n            logs.contains(\u0026\"EVENT_JSON:{\\\"standard\\\":\\\"nep297\\\",\\\"version\\\":\\\"1.0.0\\\",\\\"event\\\":\\\"state_migrated\\\",\\\"data\\\":{\\\"old_version\\\":\\\"0.1.0\\\",\\\"new_version\\\":\\\"0.1.1\\\"}}\".to_string()),\n            \"Expected state_migrated event, got: {:?}\", logs\n        );\n    }\n\n    #[test]\n    fn test_migration_from_011_to_011() {\n        let manager: AccountId = \"manager.testnet\".parse().unwrap();\n        let context = setup_context(manager.clone());\n        testing_env!(context.build());\n\n        let token: AccountId = \"token.testnet\".parse().unwrap();\n        let state_v011 = StateV011 {\n            version: \"0.1.1\".to_string(),\n            manager: manager.clone(),\n            relayer_contract: \"relayer.testnet\".parse().unwrap(),\n            supported_tokens: vec![token.clone()],\n            storage_deposit: U128(1_250_000_000_000_000_000_000),\n            cross_contract_gas: 100_000_000_000_000,\n            storage_balances: LookupMap::new(b\"s\".to_vec()),\n            min_balance: 10_000_000_000_000_000_000_000_000,\n            max_balance: 1_000_000_000_000_000_000_000_000_000,\n            fee_percentage: 10,\n        };\n        // Serialize state to Borsh\n        let state_bytes = borsh::to_vec(\u0026state_v011).expect(\"Failed to serialize state\");\n        env::state_write(\u0026state_bytes);\n\n        let new_contract = FtWrapperContract::migrate();\n\n        assert_eq!(\n            new_contract.state.version, \"0.1.1\",\n            \"Version should be 0.1.1\"\n        );\n        assert_eq!(\n            new_contract.state.manager, manager,\n            \"Manager should be preserved\"\n        );\n        assert_eq!(\n            new_contract.state.relayer_contract,\n            \"relayer.testnet\".parse::\u003cAccountId\u003e().unwrap(),\n            \"Relayer contract should be preserved\"\n        );\n        assert!(\n            new_contract.state.supported_tokens.contains(\u0026token),\n            \"Supported tokens should be preserved\"\n        );\n        assert_eq!(\n            new_contract.state.fee_percentage, 10,\n            \"Fee percentage should be preserved\"\n        );\n\n        let logs = get_logs();\n        assert!(\n            logs.contains(\u0026\"State is already at latest version\".to_string()),\n            \"Expected latest version log, got: {:?}\",\n            logs\n        );\n    }\n\n    #[test]\n    fn test_migration_no_prior_state() {\n        let manager: AccountId = \"manager.testnet\".parse().unwrap();\n        let context = setup_context(manager.clone());\n        testing_env!(context.build());\n\n        let new_contract = FtWrapperContract::migrate();\n\n        assert_eq!(\n            new_contract.state.version, \"0.1.1\",\n            \"Version should be 0.1.1\"\n        );\n        assert_eq!(\n            new_contract.state.manager,\n            env::current_account_id(),\n            \"Manager should be current account\"\n        );\n        assert_eq!(\n            new_contract.state.fee_percentage, 0,\n            \"Fee percentage should be initialized\"\n        );\n\n        let logs = get_logs();\n        assert!(\n            logs.contains(\u0026\"No valid prior state found, initializing new state\".to_string()),\n            \"Expected no prior state log, got: {:?}\",\n            logs\n        );\n    }\n\n    #[test]\n    fn test_migration_corrupted_state() {\n        let manager: AccountId = \"manager.testnet\".parse().unwrap();\n        let context = setup_context(manager.clone());\n        testing_env!(context.build());\n\n        // Simulate corrupted state\n        env::state_write(\u0026vec![0u8; 10]); // Invalid Borsh data\n\n        let new_contract = FtWrapperContract::migrate();\n\n        assert_eq!(\n            new_contract.state.version, \"0.1.1\",\n            \"Version should be 0.1.1\"\n        );\n        assert_eq!(\n            new_contract.state.manager,\n            env::current_account_id(),\n            \"Manager should be current account\"\n        );\n        assert_eq!(\n            new_contract.state.fee_percentage, 0,\n            \"Fee percentage should be initialized\"\n        );\n\n        let logs = get_logs();\n        assert!(\n            logs.contains(\u0026\"No valid prior state found, initializing new state\".to_string()),\n            \"Expected no prior state log, got: {:?}\",\n            logs\n        );\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","code","contracts","ft-wrapper-onsocial","src","types.rs"],"content":"use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};\nuse near_sdk::json_types::U128;\nuse near_sdk::serde::{Deserialize, Serialize};\nuse near_sdk::{AccountId, Gas, NearToken, PublicKey};\nuse near_sdk_macros::NearSchema;\n\n#[derive(NearSchema, Serialize, Deserialize, Clone, BorshSerialize, BorshDeserialize)]\n#[abi(borsh, json)]\n#[serde(crate = \"near_sdk::serde\")]\npub enum Action {\n    ChainSignatureRequest {\n        target_chain: String,\n        derivation_path: String,\n        payload: Vec\u003cu8\u003e,\n    },\n    FunctionCall {\n        method_name: String,\n        args: Vec\u003cu8\u003e,\n        gas: Gas,\n        deposit: NearToken,\n    },\n    Transfer {\n        deposit: NearToken,\n    },\n    AddKey {\n        public_key: PublicKey,\n        allowance: Option\u003cNearToken\u003e,\n        receiver_id: AccountId,\n        method_names: Vec\u003cString\u003e,\n    },\n    FtTransfer {\n        token: AccountId,\n        receiver_id: AccountId,\n        amount: U128,\n        memo: Option\u003cString\u003e,\n    },\n    BridgeTransfer {\n        token: AccountId,\n        amount: U128,\n        destination_chain: String,\n        recipient: String,\n    },\n}\n\n#[derive(NearSchema, Serialize, Deserialize, Clone, BorshSerialize, BorshDeserialize)]\n#[abi(borsh, json)]\n#[serde(crate = \"near_sdk::serde\")]\npub struct FtTransferArgs {\n    pub token: AccountId,\n    pub receiver_id: AccountId,\n    pub amount: U128,\n    pub memo: Option\u003cString\u003e,\n}\n\n#[derive(NearSchema, Serialize, Deserialize, Clone, BorshSerialize, BorshDeserialize)]\n#[abi(borsh, json)]\n#[serde(crate = \"near_sdk::serde\")]\npub struct RequestChainSignatureArgs {\n    pub token: AccountId,\n    pub target_chain: String,\n    pub derivation_path: String,\n    pub payload: Vec\u003cu8\u003e,\n}\n\n#[derive(NearSchema, Serialize, Deserialize, Clone, BorshSerialize, BorshDeserialize)]\n#[abi(borsh, json)]\n#[serde(crate = \"near_sdk::serde\")]\npub struct BridgeTransferArgs {\n    pub token: AccountId,\n    pub amount: U128,\n    pub destination_chain: String,\n    pub recipient: String,\n}\n\n#[derive(NearSchema, Serialize, Deserialize, Clone, BorshSerialize, BorshDeserialize)]\n#[abi(borsh, json)]\n#[serde(crate = \"near_sdk::serde\")]\npub struct FinalizeTransferArgs {\n    pub token: AccountId,\n    pub recipient: AccountId,\n    pub amount: U128,\n    pub source_chain: String,\n    pub is_native: bool,\n    pub signature: Vec\u003cu8\u003e,\n    pub message_payload: Vec\u003cu8\u003e,\n}\n\n#[derive(NearSchema, Serialize, Deserialize, Clone, BorshSerialize, BorshDeserialize)]\n#[abi(borsh, json)]\n#[serde(crate = \"near_sdk::serde\")]\npub struct StorageBalance {\n    pub total: U128,\n    pub available: U128,\n}\n\n#[derive(NearSchema, Serialize, Deserialize, Clone, BorshSerialize, BorshDeserialize)]\n#[abi(borsh, json)]\n#[serde(crate = \"near_sdk::serde\")]\npub struct StorageBalanceBounds {\n    pub min: U128,\n    pub max: Option\u003cU128\u003e,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","code","contracts","relayer-onsocial","src","admin.rs"],"content":"use crate::errors::RelayerError;\nuse crate::events::RelayerEvent;\nuse crate::{ext_auth, state::Relayer};\nuse near_sdk::{env, AccountId, Gas, PublicKey};\n\npub fn register_existing_account(\n    relayer: \u0026mut Relayer,\n    account_id: AccountId,\n    public_key: PublicKey,\n    expiration_days: Option\u003cu32\u003e,\n    is_multi_sig: bool,\n    multi_sig_threshold: Option\u003cu32\u003e,\n) -\u003e Result\u003c(), RelayerError\u003e {\n    let caller = env::predecessor_account_id();\n    if caller != account_id {\n        return Err(RelayerError::Unauthorized);\n    }\n    if public_key.as_bytes().len() != 33 || public_key.as_bytes()[0] != 0 {\n        return Err(RelayerError::InvalidSignature);\n    }\n    ext_auth::ext(relayer.auth_contract.clone())\n        .with_static_gas(Gas::from_tgas(relayer.cross_contract_gas))\n        .register_key(\n            account_id.clone(),\n            public_key.clone(),\n            expiration_days,\n            is_multi_sig,\n            multi_sig_threshold,\n        );\n    let key_hash = hex::encode(env::sha256(\u0026public_key.as_bytes()));\n    RelayerEvent::AuthAdded {\n        auth_account: account_id,\n        key_hash,\n    }\n    .emit();\n    Ok(())\n}\n\npub fn remove_key(\n    relayer: \u0026mut Relayer,\n    account_id: AccountId,\n    public_key: PublicKey,\n) -\u003e Result\u003c(), RelayerError\u003e {\n    let caller = env::predecessor_account_id();\n    if caller != account_id {\n        return Err(RelayerError::Unauthorized);\n    }\n    ext_auth::ext(relayer.auth_contract.clone())\n        .with_static_gas(Gas::from_tgas(relayer.cross_contract_gas))\n        .remove_key(account_id.clone(), public_key.clone());\n    let key_hash = hex::encode(env::sha256(\u0026public_key.as_bytes()));\n    RelayerEvent::AuthRemoved {\n        auth_account: account_id,\n        key_hash,\n    }\n    .emit();\n    Ok(())\n}\n\npub fn set_cross_contract_gas(relayer: \u0026mut Relayer, new_gas: u64) -\u003e Result\u003c(), RelayerError\u003e {\n    let caller = env::predecessor_account_id();\n    if !relayer.is_manager(\u0026caller) {\n        return Err(RelayerError::Unauthorized);\n    }\n    if new_gas \u003c 15_000_000_000_000 || new_gas \u003e 100_000_000_000_000 {\n        return Err(RelayerError::AmountTooLow);\n    }\n    relayer.cross_contract_gas = new_gas;\n    RelayerEvent::CrossContractGasUpdated { new_gas }.emit();\n    let remaining_gas = env::prepaid_gas()\n        .as_tgas()\n        .saturating_sub(env::used_gas().as_tgas());\n    env::log_str(\u0026format!(\n        \"set_cross_contract_gas: prepaid={} TGas, used={} TGas, remaining={} TGas\",\n        env::prepaid_gas().as_tgas(),\n        env::used_gas().as_tgas(),\n        remaining_gas\n    ));\n    Ok(())\n}\n\npub fn set_migration_gas(relayer: \u0026mut Relayer, new_gas: u64) -\u003e Result\u003c(), RelayerError\u003e {\n    let caller = env::predecessor_account_id();\n    if !relayer.is_manager(\u0026caller) {\n        return Err(RelayerError::Unauthorized);\n    }\n    if new_gas \u003c 15_000_000_000_000 || new_gas \u003e 200_000_000_000_000 {\n        return Err(RelayerError::AmountTooLow);\n    }\n    relayer.migration_gas = new_gas;\n    RelayerEvent::MigrationGasUpdated { new_gas }.emit();\n    let remaining_gas = env::prepaid_gas()\n        .as_tgas()\n        .saturating_sub(env::used_gas().as_tgas());\n    env::log_str(\u0026format!(\n        \"set_migration_gas: prepaid={} TGas, used={} TGas, remaining={} TGas\",\n        env::prepaid_gas().as_tgas(),\n        env::used_gas().as_tgas(),\n        remaining_gas\n    ));\n    Ok(())\n}\n\npub fn set_omni_locker_contract(\n    relayer: \u0026mut Relayer,\n    new_locker_contract: AccountId,\n) -\u003e Result\u003c(), RelayerError\u003e {\n    let caller = env::predecessor_account_id();\n    if !relayer.is_manager(\u0026caller) {\n        return Err(RelayerError::Unauthorized);\n    }\n    relayer\n        .omni_locker_contract\n        .set(Some(new_locker_contract.clone()));\n    RelayerEvent::OmniLockerContractUpdated {\n        new_locker_contract,\n    }\n    .emit();\n    Ok(())\n}\n\npub fn set_offload_recipient(\n    relayer: \u0026mut Relayer,\n    new_recipient: AccountId,\n) -\u003e Result\u003c(), RelayerError\u003e {\n    let caller = env::predecessor_account_id();\n    if !relayer.is_manager(\u0026caller) {\n        return Err(RelayerError::Unauthorized);\n    }\n    relayer.offload_recipient = new_recipient.clone();\n    RelayerEvent::OffloadRecipientUpdated { new_recipient }.emit();\n    Ok(())\n}\n\npub fn set_manager(relayer: \u0026mut Relayer, new_manager: AccountId) -\u003e Result\u003c(), RelayerError\u003e {\n    let caller = env::predecessor_account_id();\n    if !relayer.is_manager(\u0026caller) {\n        return Err(RelayerError::Unauthorized);\n    }\n    relayer.manager = new_manager.clone();\n    RelayerEvent::ManagerChanged {\n        old_manager: caller,\n        new_manager,\n        timestamp: env::block_timestamp_ms(),\n    }\n    .emit();\n    Ok(())\n}\n\npub fn set_sponsor_amount(relayer: \u0026mut Relayer, new_amount: u128) -\u003e Result\u003c(), RelayerError\u003e {\n    let caller = env::predecessor_account_id();\n    if !relayer.is_manager(\u0026caller) {\n        return Err(RelayerError::Unauthorized);\n    }\n    if new_amount \u003c 10_000_000_000_000_000_000_000 {\n        return Err(RelayerError::AmountTooLow);\n    }\n    relayer.sponsor_amount = new_amount;\n    RelayerEvent::SponsorAmountUpdated { new_amount }.emit();\n    Ok(())\n}\n\npub fn set_sponsor_gas(relayer: \u0026mut Relayer, new_gas: u64) -\u003e Result\u003c(), RelayerError\u003e {\n    let caller = env::predecessor_account_id();\n    if !relayer.is_manager(\u0026caller) {\n        return Err(RelayerError::Unauthorized);\n    }\n    if new_gas \u003c 50_000_000_000_000 || new_gas \u003e 300_000_000_000_000 {\n        return Err(RelayerError::AmountTooLow);\n    }\n    relayer.sponsor_gas = new_gas;\n    RelayerEvent::SponsorGasUpdated { new_gas }.emit();\n    Ok(())\n}\n\npub fn set_chunk_size(relayer: \u0026mut Relayer, new_size: usize) -\u003e Result\u003c(), RelayerError\u003e {\n    let caller = env::predecessor_account_id();\n    if !relayer.is_manager(\u0026caller) {\n        return Err(RelayerError::Unauthorized);\n    }\n    if new_size \u003c 1 || new_size \u003e 5 {\n        return Err(RelayerError::AmountTooLow);\n    }\n    relayer.chunk_size = new_size;\n    RelayerEvent::ChunkSizeUpdated { new_size }.emit();\n    let remaining_gas = env::prepaid_gas()\n        .as_tgas()\n        .saturating_sub(env::used_gas().as_tgas());\n    env::log_str(\u0026format!(\n        \"set_chunk_size: prepaid={} TGas, used={} TGas, remaining={} TGas\",\n        env::prepaid_gas().as_tgas(),\n        env::used_gas().as_tgas(),\n        remaining_gas\n    ));\n    Ok(())\n}\n\npub fn add_chain_mpc_mapping(\n    relayer: \u0026mut Relayer,\n    chain: String,\n    mpc_contract: AccountId,\n) -\u003e Result\u003c(), RelayerError\u003e {\n    let caller = env::predecessor_account_id();\n    if !relayer.is_manager(\u0026caller) {\n        return Err(RelayerError::Unauthorized);\n    }\n    relayer\n        .chain_mpc_mapping\n        .insert(chain.clone(), mpc_contract.clone());\n    RelayerEvent::ChainMpcMappingAdded {\n        chain,\n        mpc_contract,\n    }\n    .emit();\n    Ok(())\n}\n\npub fn remove_chain_mpc_mapping(relayer: \u0026mut Relayer, chain: String) -\u003e Result\u003c(), RelayerError\u003e {\n    let caller = env::predecessor_account_id();\n    if !relayer.is_manager(\u0026caller) {\n        return Err(RelayerError::Unauthorized);\n    }\n    relayer.chain_mpc_mapping.remove(\u0026chain);\n    RelayerEvent::ChainMpcMappingRemoved { chain }.emit();\n    Ok(())\n}\n\npub fn set_auth_contract(\n    relayer: \u0026mut Relayer,\n    new_auth_contract: AccountId,\n) -\u003e Result\u003c(), RelayerError\u003e {\n    let caller = env::predecessor_account_id();\n    if !relayer.is_manager(\u0026caller) {\n        return Err(RelayerError::Unauthorized);\n    }\n    relayer.auth_contract = new_auth_contract.clone();\n    RelayerEvent::AuthContractUpdated { new_auth_contract }.emit();\n    Ok(())\n}\n\npub fn set_ft_wrapper_contract(\n    relayer: \u0026mut Relayer,\n    new_ft_wrapper_contract: AccountId,\n) -\u003e Result\u003c(), RelayerError\u003e {\n    let caller = env::predecessor_account_id();\n    if !relayer.is_manager(\u0026caller) {\n        return Err(RelayerError::Unauthorized);\n    }\n    relayer.ft_wrapper_contract = new_ft_wrapper_contract.clone();\n    RelayerEvent::FtWrapperContractUpdated {\n        new_ft_wrapper_contract,\n    }\n    .emit();\n    Ok(())\n}\n\npub fn set_base_fee(\n    relayer: \u0026mut Relayer,\n    new_fee: u128,\n    signatures: Option\u003cVec\u003cVec\u003cu8\u003e\u003e\u003e,\n) -\u003e Result\u003c(), RelayerError\u003e {\n    let caller = env::predecessor_account_id();\n    if !relayer.is_manager(\u0026caller) {\n        return Err(RelayerError::Unauthorized);\n    }\n    // Allow zero fee without signatures for flexibility\n    if new_fee \u003e 0 {\n        if let Some(sigs) = signatures {\n            if sigs.len() \u003c 2 {\n                return Err(RelayerError::InsufficientSignatures);\n            }\n        } else {\n            return Err(RelayerError::InsufficientSignatures);\n        }\n        let min_fee = 100_000_000_000_000_000_000; // 0.0001 NEAR\n        if new_fee \u003c min_fee {\n            return Err(RelayerError::FeeTooLow);\n        }\n    }\n    relayer.base_fee = new_fee;\n    RelayerEvent::BaseFeeUpdated { new_fee }.emit();\n    Ok(())\n}\n\npub fn set_min_balance(relayer: \u0026mut Relayer, new_min: u128) -\u003e Result\u003c(), RelayerError\u003e {\n    let caller = env::predecessor_account_id();\n    if !relayer.is_manager(\u0026caller) {\n        return Err(RelayerError::Unauthorized);\n    }\n    if new_min \u003e relayer.max_balance {\n        return Err(RelayerError::AmountTooLow);\n    }\n    relayer.min_balance = new_min;\n    RelayerEvent::MinBalanceUpdated { new_min }.emit();\n    Ok(())\n}\n\npub fn set_max_balance(relayer: \u0026mut Relayer, new_max: u128) -\u003e Result\u003c(), RelayerError\u003e {\n    let caller = env::predecessor_account_id();\n    if !relayer.is_manager(\u0026caller) {\n        return Err(RelayerError::Unauthorized);\n    }\n    if new_max \u003c relayer.min_balance {\n        return Err(RelayerError::AmountTooLow);\n    }\n    relayer.max_balance = new_max;\n    RelayerEvent::MaxBalanceUpdated { new_max }.emit();\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","code","contracts","relayer-onsocial","src","balance.rs"],"content":"use crate::errors::RelayerError;\nuse crate::state::Relayer;\nuse near_sdk::{env, NearToken, Promise};\n\npub fn deposit(relayer: \u0026mut Relayer) -\u003e Result\u003c(), RelayerError\u003e {\n    let deposit = env::attached_deposit().as_yoctonear();\n    let balance = env::account_balance().as_yoctonear() + deposit;\n    if balance \u003e relayer.max_balance {\n        let excess = balance - relayer.max_balance;\n        Promise::new(relayer.offload_recipient.clone()).transfer(NearToken::from_yoctonear(excess));\n    }\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","code","contracts","relayer-onsocial","src","errors.rs"],"content":"use near_sdk::borsh::{BorshDeserialize, BorshSerialize};\nuse near_sdk::{env, FunctionError};\n\n#[derive(Debug, PartialEq, BorshSerialize, BorshDeserialize)]\npub enum RelayerError {\n    Unauthorized,\n    InsufficientBalance,\n    InvalidNonce,\n    InvalidAccountId,\n    AmountTooLow,\n    InvalidSignature,\n    InsufficientDeposit,\n    FeeTooLow,\n    InsufficientSignatures,\n    MissingInput,\n}\n\nimpl FunctionError for RelayerError {\n    fn panic(\u0026self) -\u003e ! {\n        env::panic_str(\u0026format!(\"RelayerError: {:?}\", self))\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","code","contracts","relayer-onsocial","src","events.rs"],"content":"use near_sdk::json_types::U128;\nuse near_sdk::{near, AccountId};\n\n#[near(event_json(standard = \"nep297\"))]\npub enum RelayerEvent {\n    #[event_version(\"1.0.0\")]\n    LowBalance { balance: u128 },\n    #[event_version(\"1.0.0\")]\n    LowGas { remaining_gas: u64 },\n    #[event_version(\"1.0.0\")]\n    AccountSponsored { account_id: AccountId },\n    #[event_version(\"1.0.0\")]\n    AuthAdded {\n        auth_account: AccountId,\n        key_hash: String,\n    },\n    #[event_version(\"1.0.0\")]\n    AuthRemoved {\n        auth_account: AccountId,\n        key_hash: String,\n    },\n    #[event_version(\"1.0.0\")]\n    CrossChainSignatureResult {\n        chain: String,\n        request_id: u64,\n        result: Vec\u003cu8\u003e,\n    },\n    #[event_version(\"1.0.0\")]\n    BridgeResult {\n        sender_id: AccountId,\n        action_type: String,\n        result: Vec\u003cu8\u003e,\n    },\n    #[event_version(\"1.0.0\")]\n    BridgeTransferInitiated {\n        token: String,\n        amount: U128,\n        destination_chain: String,\n        recipient: String,\n        sender: AccountId,\n        nonce: u64,\n    },\n    #[event_version(\"1.0.0\")]\n    BridgeTransferCompleted {\n        token: String,\n        amount: U128,\n        destination_chain: String,\n        recipient: String,\n        sender: AccountId,\n        signature: Vec\u003cu8\u003e,\n    },\n    #[event_version(\"1.0.0\")]\n    BridgeTransferFailed {\n        token: String,\n        amount: U128,\n        destination_chain: String,\n        recipient: String,\n        sender: AccountId,\n        nonce: u64,\n    },\n    #[event_version(\"1.0.0\")]\n    OffloadRecipientUpdated { new_recipient: AccountId },\n    #[event_version(\"1.0.0\")]\n    SponsorAmountUpdated { new_amount: u128 },\n    #[event_version(\"1.0.0\")]\n    SponsorGasUpdated { new_gas: u64 },\n    #[event_version(\"1.0.0\")]\n    CrossContractGasUpdated { new_gas: u64 },\n    #[event_version(\"1.0.0\")]\n    MigrationGasUpdated { new_gas: u64 },\n    #[event_version(\"1.0.0\")]\n    OmniLockerContractUpdated { new_locker_contract: AccountId },\n    #[event_version(\"1.0.0\")]\n    ChainMpcMappingAdded {\n        chain: String,\n        mpc_contract: AccountId,\n    },\n    #[event_version(\"1.0.0\")]\n    ChainMpcMappingRemoved { chain: String },\n    #[event_version(\"1.0.0\")]\n    ChunkSizeUpdated { new_size: usize },\n    #[event_version(\"1.0.0\")]\n    AuthContractUpdated { new_auth_contract: AccountId },\n    #[event_version(\"1.0.0\")]\n    FtWrapperContractUpdated { new_ft_wrapper_contract: AccountId },\n    #[event_version(\"1.0.0\")]\n    MinBalanceUpdated { new_min: u128 },\n    #[event_version(\"1.0.0\")]\n    MaxBalanceUpdated { new_max: u128 },\n    #[event_version(\"1.0.0\")]\n    BaseFeeUpdated { new_fee: u128 },\n    #[event_version(\"1.0.0\")]\n    FeeCharged {\n        action: String,\n        fee: u128,\n        sender: AccountId,\n    },\n    #[event_version(\"1.0.0\")]\n    ManagerChanged {\n        old_manager: AccountId,\n        new_manager: AccountId,\n        timestamp: u64,\n    },\n    #[event_version(\"1.0.0\")]\n    ContractUpgraded { manager: AccountId, timestamp: u64 },\n    #[event_version(\"1.0.0\")]\n    StateMigrated {\n        old_version: String,\n        new_version: String,\n    },\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","code","contracts","relayer-onsocial","src","lib.rs"],"content":"use crate::errors::RelayerError;\nuse crate::events::RelayerEvent;\nuse crate::state::Relayer;\nuse crate::types::{Action, SignedDelegateAction};\nuse near_sdk::json_types::U128;\nuse near_sdk::{borsh, PanicOnDefault};\nuse near_sdk::{\n    env, ext_contract, near, AccountId, Gas, NearToken, Promise, PromiseError, PublicKey,\n};\n\nmod admin;\nmod balance;\nmod errors;\nmod events;\nmod relay;\nmod sponsor;\nmod state;\nmod state_versions;\nmod types;\n\n#[ext_contract(ext_self)]\npub trait SelfCallback {\n    fn handle_mpc_signature(\n        \u0026mut self,\n        chain: String,\n        request_id: u64,\n        result: Vec\u003cu8\u003e,\n        #[callback_result] call_result: Result\u003c(), PromiseError\u003e,\n    );\n    fn handle_bridge_result(\n        \u0026mut self,\n        sender_id: AccountId,\n        action_type: String,\n        result: Vec\u003cu8\u003e,\n        #[callback_result] call_result: Result\u003c(), PromiseError\u003e,\n    );\n    fn handle_bridge_transfer_result(\n        \u0026mut self,\n        sender_id: AccountId,\n        token: String,\n        amount: U128,\n        destination_chain: String,\n        recipient: String,\n        signature: Vec\u003cu8\u003e,\n        #[callback_result] call_result: Result\u003c(), PromiseError\u003e,\n    );\n    #[handle_result]\n    fn handle_auth_result(\n        \u0026mut self,\n        sender_id: AccountId,\n        signed_delegate: SignedDelegateAction,\n        is_authorized: bool,\n    ) -\u003e Result\u003cPromise, RelayerError\u003e;\n    fn handle_registration(\n        \u0026mut self,\n        account_id: AccountId,\n        token: String,\n        is_sender: bool,\n        is_registered: bool,\n    ) -\u003e Promise;\n}\n\n#[ext_contract(ext_auth)]\npub trait AuthContract {\n    fn is_authorized(\n        \u0026self,\n        account_id: AccountId,\n        public_key: PublicKey,\n        signatures: Option\u003cVec\u003cVec\u003cu8\u003e\u003e\u003e,\n    ) -\u003e bool;\n    fn register_key(\n        \u0026mut self,\n        account_id: AccountId,\n        public_key: PublicKey,\n        expiration_days: Option\u003cu32\u003e,\n        is_multi_sig: bool,\n        multi_sig_threshold: Option\u003cu32\u003e,\n    );\n    fn remove_key(\u0026mut self, account_id: AccountId, public_key: PublicKey);\n}\n\n#[ext_contract(ext_ft_wrapper)]\npub trait FtWrapperContract {\n    fn storage_deposit(\u0026mut self, token: String, account_id: AccountId, deposit: U128);\n    fn ft_transfer(\n        \u0026mut self,\n        token: String,\n        receiver_id: AccountId,\n        amount: U128,\n        memo: Option\u003cString\u003e,\n    );\n    fn ft_balance_of(\u0026self, token: String, account_id: AccountId) -\u003e U128;\n    fn is_registered(\u0026self, token: String, account_id: AccountId) -\u003e bool;\n}\n\n#[ext_contract(ext_omi_locker)]\npub trait OmniLocker {\n    fn lock(\u0026mut self, token: String, amount: U128, destination_chain: String, recipient: String);\n}\n\n#[ext_contract(ext_mpc)]\npub trait MpcContract {\n    fn get_nonce(\u0026self, account_id: AccountId, tx_hash: String) -\u003e u64;\n}\n\n#[near(contract_state)]\n#[derive(PanicOnDefault)]\npub struct OnSocialRelayer {\n    relayer: Relayer,\n}\n\n#[near]\nimpl OnSocialRelayer {\n    #[init]\n    pub fn new(\n        offload_recipient: AccountId,\n        auth_contract: AccountId,\n        ft_wrapper_contract: AccountId,\n    ) -\u003e Self {\n        Self {\n            relayer: Relayer::new(\n                env::predecessor_account_id(),\n                offload_recipient,\n                auth_contract,\n                ft_wrapper_contract,\n            ),\n        }\n    }\n\n    #[payable]\n    pub fn deposit(\u0026mut self) {\n        balance::deposit(\u0026mut self.relayer).expect(\"Deposit failed\");\n    }\n\n    #[handle_result]\n    pub fn relay_meta_transaction(\n        \u0026mut self,\n        #[serializer(borsh)] signed_delegate: SignedDelegateAction,\n    ) -\u003e Result\u003cPromise, RelayerError\u003e {\n        relay::relay_meta_transaction(\u0026mut self.relayer, signed_delegate)\n    }\n\n    #[handle_result]\n    pub fn relay_meta_transactions(\n        \u0026mut self,\n        #[serializer(borsh)] signed_delegates: Vec\u003cSignedDelegateAction\u003e,\n    ) -\u003e Result\u003cVec\u003cPromise\u003e, RelayerError\u003e {\n        relay::relay_meta_transactions(\u0026mut self.relayer, signed_delegates)\n    }\n\n    #[handle_result]\n    pub fn relay_chunked_meta_transactions(\n        \u0026mut self,\n        #[serializer(borsh)] signed_delegates: Vec\u003cSignedDelegateAction\u003e,\n    ) -\u003e Result\u003cVec\u003cPromise\u003e, RelayerError\u003e {\n        relay::relay_chunked_meta_transactions(\u0026mut self.relayer, signed_delegates)\n    }\n\n    #[handle_result]\n    pub fn sponsor_account(\n        \u0026mut self,\n        #[serializer(borsh)] args: Vec\u003cu8\u003e,\n    ) -\u003e Result\u003cPromise, RelayerError\u003e {\n        env::log_str(\u0026format!(\"Raw args: {:?}\", args));\n        let (new_account_id, public_key, is_multi_sig, multi_sig_threshold): (\n            AccountId,\n            PublicKey,\n            bool,\n            Option\u003cu32\u003e,\n        ) = borsh::from_slice(\u0026args).map_err(|e| {\n            env::log_str(\u0026format!(\"Deserialization failed: {:?}\", e));\n            RelayerError::InvalidNonce\n        })?;\n        env::log_str(\u0026format!(\n            \"Deserialized: {} {:?}\",\n            new_account_id, public_key\n        ));\n        sponsor::sponsor_account_with_registrar(\n            \u0026mut self.relayer,\n            new_account_id,\n            public_key,\n            is_multi_sig,\n            multi_sig_threshold,\n        )\n    }\n\n    #[handle_result]\n    pub fn sponsor_account_signed(\n        \u0026mut self,\n        #[serializer(borsh)] signed_delegate: SignedDelegateAction,\n    ) -\u003e Result\u003cPromise, RelayerError\u003e {\n        sponsor::sponsor_account_signed(\u0026mut self.relayer, signed_delegate)\n    }\n\n    #[handle_result]\n    pub fn register_existing_account(\n        \u0026mut self,\n        account_id: AccountId,\n        public_key: PublicKey,\n        expiration_days: Option\u003cu32\u003e,\n        is_multi_sig: bool,\n        multi_sig_threshold: Option\u003cu32\u003e,\n    ) -\u003e Result\u003c(), RelayerError\u003e {\n        let initial_storage = env::storage_usage();\n        let result = admin::register_existing_account(\n            \u0026mut self.relayer,\n            account_id,\n            public_key,\n            expiration_days,\n            is_multi_sig,\n            multi_sig_threshold,\n        );\n        let storage_used = env::storage_usage() - initial_storage;\n        let storage_cost = storage_used as u128 * env::storage_byte_cost().as_yoctonear();\n        if env::account_balance().as_yoctonear() \u003c self.relayer.min_balance + storage_cost {\n            RelayerEvent::LowBalance {\n                balance: env::account_balance().as_yoctonear(),\n            }\n            .emit();\n            return Err(RelayerError::InsufficientBalance);\n        }\n        env::log_str(\u0026format!(\n            \"register_existing_account: storage_used={} bytes, storage_cost={} yoctoNEAR\",\n            storage_used, storage_cost\n        ));\n        result\n    }\n\n    #[handle_result]\n    pub fn remove_key(\n        \u0026mut self,\n        account_id: AccountId,\n        public_key: PublicKey,\n    ) -\u003e Result\u003c(), RelayerError\u003e {\n        let initial_storage = env::storage_usage();\n        let result = admin::remove_key(\u0026mut self.relayer, account_id, public_key);\n        let storage_used = env::storage_usage() - initial_storage;\n        let storage_cost = storage_used as u128 * env::storage_byte_cost().as_yoctonear();\n        if env::account_balance().as_yoctonear() \u003c self.relayer.min_balance + storage_cost {\n            RelayerEvent::LowBalance {\n                balance: env::account_balance().as_yoctonear(),\n            }\n            .emit();\n            return Err(RelayerError::InsufficientBalance);\n        }\n        env::log_str(\u0026format!(\n            \"remove_key: storage_used={} bytes, storage_cost={} yoctoNEAR\",\n            storage_used, storage_cost\n        ));\n        result\n    }\n\n    #[handle_result]\n    pub fn set_offload_recipient(\u0026mut self, new_recipient: AccountId) -\u003e Result\u003c(), RelayerError\u003e {\n        let initial_storage = env::storage_usage();\n        let result = admin::set_offload_recipient(\u0026mut self.relayer, new_recipient);\n        let storage_used = env::storage_usage() - initial_storage;\n        let storage_cost = storage_used as u128 * env::storage_byte_cost().as_yoctonear();\n        if env::account_balance().as_yoctonear() \u003c self.relayer.min_balance + storage_cost {\n            RelayerEvent::LowBalance {\n                balance: env::account_balance().as_yoctonear(),\n            }\n            .emit();\n            return Err(RelayerError::InsufficientBalance);\n        }\n        env::log_str(\u0026format!(\n            \"set_offload_recipient: storage_used={} bytes, storage_cost={} yoctoNEAR\",\n            storage_used, storage_cost\n        ));\n        result\n    }\n\n    #[handle_result]\n    pub fn set_sponsor_amount(\u0026mut self, new_amount: U128) -\u003e Result\u003c(), RelayerError\u003e {\n        let initial_storage = env::storage_usage();\n        let result = admin::set_sponsor_amount(\u0026mut self.relayer, new_amount.0);\n        let storage_used = env::storage_usage() - initial_storage;\n        let storage_cost = storage_used as u128 * env::storage_byte_cost().as_yoctonear();\n        if env::account_balance().as_yoctonear() \u003c self.relayer.min_balance + storage_cost {\n            RelayerEvent::LowBalance {\n                balance: env::account_balance().as_yoctonear(),\n            }\n            .emit();\n            return Err(RelayerError::InsufficientBalance);\n        }\n        env::log_str(\u0026format!(\n            \"set_sponsor_amount: storage_used={} bytes, storage_cost={} yoctoNEAR\",\n            storage_used, storage_cost\n        ));\n        result\n    }\n\n    #[handle_result]\n    pub fn set_sponsor_gas(\u0026mut self, new_gas: u64) -\u003e Result\u003c(), RelayerError\u003e {\n        let initial_storage = env::storage_usage();\n        let result = admin::set_sponsor_gas(\u0026mut self.relayer, new_gas);\n        let storage_used = env::storage_usage() - initial_storage;\n        let storage_cost = storage_used as u128 * env::storage_byte_cost().as_yoctonear();\n        if env::account_balance().as_yoctonear() \u003c self.relayer.min_balance + storage_cost {\n            RelayerEvent::LowBalance {\n                balance: env::account_balance().as_yoctonear(),\n            }\n            .emit();\n            return Err(RelayerError::InsufficientBalance);\n        }\n        env::log_str(\u0026format!(\n            \"set_sponsor_gas: storage_used={} bytes, storage_cost={} yoctoNEAR\",\n            storage_used, storage_cost\n        ));\n        result\n    }\n\n    #[handle_result]\n    pub fn set_cross_contract_gas(\u0026mut self, new_gas: u64) -\u003e Result\u003c(), RelayerError\u003e {\n        let initial_storage = env::storage_usage();\n        let result = admin::set_cross_contract_gas(\u0026mut self.relayer, new_gas);\n        let storage_used = env::storage_usage() - initial_storage;\n        let storage_cost = storage_used as u128 * env::storage_byte_cost().as_yoctonear();\n        if env::account_balance().as_yoctonear() \u003c self.relayer.min_balance + storage_cost {\n            RelayerEvent::LowBalance {\n                balance: env::account_balance().as_yoctonear(),\n            }\n            .emit();\n            return Err(RelayerError::InsufficientBalance);\n        }\n        env::log_str(\u0026format!(\n            \"set_cross_contract_gas: storage_used={} bytes, storage_cost={} yoctoNEAR\",\n            storage_used, storage_cost\n        ));\n        result\n    }\n\n    #[handle_result]\n    pub fn set_migration_gas(\u0026mut self, new_gas: u64) -\u003e Result\u003c(), RelayerError\u003e {\n        let initial_storage = env::storage_usage();\n        let result = admin::set_migration_gas(\u0026mut self.relayer, new_gas);\n        let storage_used = env::storage_usage() - initial_storage;\n        let storage_cost = storage_used as u128 * env::storage_byte_cost().as_yoctonear();\n        if env::account_balance().as_yoctonear() \u003c self.relayer.min_balance + storage_cost {\n            RelayerEvent::LowBalance {\n                balance: env::account_balance().as_yoctonear(),\n            }\n            .emit();\n            return Err(RelayerError::InsufficientBalance);\n        }\n        env::log_str(\u0026format!(\n            \"set_migration_gas: storage_used={} bytes, storage_cost={} yoctoNEAR\",\n            storage_used, storage_cost\n        ));\n        result\n    }\n\n    #[handle_result]\n    pub fn set_omni_locker_contract(\n        \u0026mut self,\n        new_locker_contract: AccountId,\n    ) -\u003e Result\u003c(), RelayerError\u003e {\n        let initial_storage = env::storage_usage();\n        let result = admin::set_omni_locker_contract(\u0026mut self.relayer, new_locker_contract);\n        let storage_used = env::storage_usage() - initial_storage;\n        let storage_cost = storage_used as u128 * env::storage_byte_cost().as_yoctonear();\n        if env::account_balance().as_yoctonear() \u003c self.relayer.min_balance + storage_cost {\n            RelayerEvent::LowBalance {\n                balance: env::account_balance().as_yoctonear(),\n            }\n            .emit();\n            return Err(RelayerError::InsufficientBalance);\n        }\n        env::log_str(\u0026format!(\n            \"set_omni_locker_contract: storage_used={} bytes, storage_cost={} yoctoNEAR\",\n            storage_used, storage_cost\n        ));\n        result\n    }\n\n    #[handle_result]\n    pub fn add_chain_mpc_mapping(\n        \u0026mut self,\n        chain: String,\n        mpc_contract: AccountId,\n    ) -\u003e Result\u003c(), RelayerError\u003e {\n        let initial_storage = env::storage_usage();\n        let result = admin::add_chain_mpc_mapping(\u0026mut self.relayer, chain, mpc_contract);\n        let storage_used = env::storage_usage() - initial_storage;\n        let storage_cost = storage_used as u128 * env::storage_byte_cost().as_yoctonear();\n        if env::account_balance().as_yoctonear() \u003c self.relayer.min_balance + storage_cost {\n            RelayerEvent::LowBalance {\n                balance: env::account_balance().as_yoctonear(),\n            }\n            .emit();\n            return Err(RelayerError::InsufficientBalance);\n        }\n        env::log_str(\u0026format!(\n            \"add_chain_mpc_mapping: storage_used={} bytes, storage_cost={} yoctoNEAR\",\n            storage_used, storage_cost\n        ));\n        result\n    }\n\n    #[handle_result]\n    pub fn remove_chain_mpc_mapping(\u0026mut self, chain: String) -\u003e Result\u003c(), RelayerError\u003e {\n        let initial_storage = env::storage_usage();\n        let result = admin::remove_chain_mpc_mapping(\u0026mut self.relayer, chain);\n        let storage_used = env::storage_usage() - initial_storage;\n        let storage_cost = storage_used as u128 * env::storage_byte_cost().as_yoctonear();\n        if env::account_balance().as_yoctonear() \u003c self.relayer.min_balance + storage_cost {\n            RelayerEvent::LowBalance {\n                balance: env::account_balance().as_yoctonear(),\n            }\n            .emit();\n            return Err(RelayerError::InsufficientBalance);\n        }\n        env::log_str(\u0026format!(\n            \"remove_chain_mpc_mapping: storage_used={} bytes, storage_cost={} yoctoNEAR\",\n            storage_used, storage_cost\n        ));\n        result\n    }\n\n    #[handle_result]\n    pub fn set_chunk_size(\u0026mut self, new_size: usize) -\u003e Result\u003c(), RelayerError\u003e {\n        let initial_storage = env::storage_usage();\n        let result = admin::set_chunk_size(\u0026mut self.relayer, new_size);\n        let storage_used = env::storage_usage() - initial_storage;\n        let storage_cost = storage_used as u128 * env::storage_byte_cost().as_yoctonear();\n        if env::account_balance().as_yoctonear() \u003c self.relayer.min_balance + storage_cost {\n            RelayerEvent::LowBalance {\n                balance: env::account_balance().as_yoctonear(),\n            }\n            .emit();\n            return Err(RelayerError::InsufficientBalance);\n        }\n        env::log_str(\u0026format!(\n            \"set_chunk_size: storage_used={} bytes, storage_cost={} yoctoNEAR\",\n            storage_used, storage_cost\n        ));\n        result\n    }\n\n    #[handle_result]\n    pub fn set_auth_contract(\u0026mut self, new_auth_contract: AccountId) -\u003e Result\u003c(), RelayerError\u003e {\n        let initial_storage = env::storage_usage();\n        let result = admin::set_auth_contract(\u0026mut self.relayer, new_auth_contract);\n        let storage_used = env::storage_usage() - initial_storage;\n        let storage_cost = storage_used as u128 * env::storage_byte_cost().as_yoctonear();\n        if env::account_balance().as_yoctonear() \u003c self.relayer.min_balance + storage_cost {\n            RelayerEvent::LowBalance {\n                balance: env::account_balance().as_yoctonear(),\n            }\n            .emit();\n            return Err(RelayerError::InsufficientBalance);\n        }\n        env::log_str(\u0026format!(\n            \"set_auth_contract: storage_used={} bytes, storage_cost={} yoctoNEAR\",\n            storage_used, storage_cost\n        ));\n        result\n    }\n\n    #[handle_result]\n    pub fn set_ft_wrapper_contract(\n        \u0026mut self,\n        new_ft_wrapper_contract: AccountId,\n    ) -\u003e Result\u003c(), RelayerError\u003e {\n        let initial_storage = env::storage_usage();\n        let result = admin::set_ft_wrapper_contract(\u0026mut self.relayer, new_ft_wrapper_contract);\n        let storage_used = env::storage_usage() - initial_storage;\n        let storage_cost = storage_used as u128 * env::storage_byte_cost().as_yoctonear();\n        if env::account_balance().as_yoctonear() \u003c self.relayer.min_balance + storage_cost {\n            RelayerEvent::LowBalance {\n                balance: env::account_balance().as_yoctonear(),\n            }\n            .emit();\n            return Err(RelayerError::InsufficientBalance);\n        }\n        env::log_str(\u0026format!(\n            \"set_ft_wrapper_contract: storage_used={} bytes, storage_cost={} yoctoNEAR\",\n            storage_used, storage_cost\n        ));\n        result\n    }\n\n    #[handle_result]\n    pub fn set_base_fee(\n        \u0026mut self,\n        new_fee: U128,\n        signatures: Option\u003cVec\u003cVec\u003cu8\u003e\u003e\u003e,\n    ) -\u003e Result\u003c(), RelayerError\u003e {\n        let initial_storage = env::storage_usage();\n        let result = admin::set_base_fee(\u0026mut self.relayer, new_fee.0, signatures);\n        let storage_used = env::storage_usage() - initial_storage;\n        let storage_cost = storage_used as u128 * env::storage_byte_cost().as_yoctonear();\n        if env::account_balance().as_yoctonear() \u003c self.relayer.min_balance + storage_cost {\n            RelayerEvent::LowBalance {\n                balance: env::account_balance().as_yoctonear(),\n            }\n            .emit();\n            return Err(RelayerError::InsufficientBalance);\n        }\n        env::log_str(\u0026format!(\n            \"set_base_fee: storage_used={} bytes, storage_cost={} yoctoNEAR\",\n            storage_used, storage_cost\n        ));\n        result\n    }\n\n    #[handle_result]\n    pub fn set_manager(\u0026mut self, new_manager: AccountId) -\u003e Result\u003c(), RelayerError\u003e {\n        let initial_storage = env::storage_usage();\n        let result = admin::set_manager(\u0026mut self.relayer, new_manager);\n        let storage_used = env::storage_usage() - initial_storage;\n        let storage_cost = storage_used as u128 * env::storage_byte_cost().as_yoctonear();\n        if env::account_balance().as_yoctonear() \u003c self.relayer.min_balance + storage_cost {\n            RelayerEvent::LowBalance {\n                balance: env::account_balance().as_yoctonear(),\n            }\n            .emit();\n            return Err(RelayerError::InsufficientBalance);\n        }\n        env::log_str(\u0026format!(\n            \"set_manager: storage_used={} bytes, storage_cost={} yoctoNEAR\",\n            storage_used, storage_cost\n        ));\n        result\n    }\n\n    #[handle_result]\n    pub fn update_contract(\u0026mut self) -\u003e Result\u003cPromise, RelayerError\u003e {\n        let caller = env::predecessor_account_id();\n        if !self.relayer.is_manager(\u0026caller) {\n            return Err(RelayerError::Unauthorized);\n        }\n        let code = env::input().ok_or(RelayerError::MissingInput)?.to_vec();\n        RelayerEvent::ContractUpgraded {\n            manager: caller,\n            timestamp: env::block_timestamp_ms(),\n        }\n        .emit();\n        let promise = Promise::new(env::current_account_id())\n            .deploy_contract(code)\n            .function_call(\n                \"migrate\".to_string(),\n                vec![],\n                NearToken::from_yoctonear(0),\n                Gas::from_tgas(self.relayer.migration_gas),\n            );\n        env::log_str(\u0026format!(\n            \"Gas used in update_contract: {} TGas\",\n            env::used_gas().as_tgas()\n        ));\n        Ok(promise)\n    }\n\n    #[handle_result]\n    pub fn set_min_balance(\u0026mut self, new_min: U128) -\u003e Result\u003c(), RelayerError\u003e {\n        let initial_storage = env::storage_usage();\n        let result = admin::set_min_balance(\u0026mut self.relayer, new_min.0);\n        let storage_used = env::storage_usage() - initial_storage;\n        let storage_cost = storage_used as u128 * env::storage_byte_cost().as_yoctonear();\n        if env::account_balance().as_yoctonear() \u003c self.relayer.min_balance + storage_cost {\n            RelayerEvent::LowBalance {\n                balance: env::account_balance().as_yoctonear(),\n            }\n            .emit();\n            return Err(RelayerError::InsufficientBalance);\n        }\n        env::log_str(\u0026format!(\n            \"set_min_balance: storage_used={} bytes, storage_cost={} yoctoNEAR\",\n            storage_used, storage_cost\n        ));\n        result\n    }\n\n    #[handle_result]\n    pub fn set_max_balance(\u0026mut self, new_max: U128) -\u003e Result\u003c(), RelayerError\u003e {\n        let initial_storage = env::storage_usage();\n        let result = admin::set_max_balance(\u0026mut self.relayer, new_max.0);\n        let storage_used = env::storage_usage() - initial_storage;\n        let storage_cost = storage_used as u128 * env::storage_byte_cost().as_yoctonear();\n        if env::account_balance().as_yoctonear() \u003c self.relayer.min_balance + storage_cost {\n            RelayerEvent::LowBalance {\n                balance: env::account_balance().as_yoctonear(),\n            }\n            .emit();\n            return Err(RelayerError::InsufficientBalance);\n        }\n        env::log_str(\u0026format!(\n            \"set_max_balance: storage_used={} bytes, storage_cost={} yoctoNEAR\",\n            storage_used, storage_cost\n        ));\n        result\n    }\n\n    pub fn get_balance(\u0026self) -\u003e U128 {\n        U128(env::account_balance().as_yoctonear())\n    }\n\n    pub fn get_min_balance(\u0026self) -\u003e U128 {\n        U128(self.relayer.min_balance)\n    }\n\n    pub fn get_max_balance(\u0026self) -\u003e U128 {\n        U128(self.relayer.max_balance)\n    }\n\n    pub fn get_sponsor_amount(\u0026self) -\u003e U128 {\n        U128(self.relayer.sponsor_amount)\n    }\n\n    pub fn get_sponsor_gas(\u0026self) -\u003e u64 {\n        self.relayer.sponsor_gas\n    }\n\n    pub fn get_cross_contract_gas(\u0026self) -\u003e u64 {\n        self.relayer.cross_contract_gas\n    }\n\n    pub fn get_migration_gas(\u0026self) -\u003e u64 {\n        self.relayer.migration_gas\n    }\n\n    pub fn get_omni_locker_contract(\u0026self) -\u003e AccountId {\n        self.relayer\n            .omni_locker_contract\n            .get()\n            .clone()\n            .map(|x| x.clone())\n            .unwrap_or_else(|| env::current_account_id())\n    }\n\n    pub fn get_chunk_size(\u0026self) -\u003e usize {\n        self.relayer.chunk_size\n    }\n\n    pub fn get_auth_contract(\u0026self) -\u003e AccountId {\n        self.relayer.auth_contract.clone()\n    }\n\n    pub fn get_ft_wrapper_contract(\u0026self) -\u003e AccountId {\n        self.relayer.ft_wrapper_contract.clone()\n    }\n\n    pub fn get_base_fee(\u0026self) -\u003e U128 {\n        U128(self.relayer.base_fee)\n    }\n}\n\n#[near]\nimpl OnSocialRelayer {\n    #[private]\n    pub fn handle_mpc_signature(\n        \u0026mut self,\n        chain: String,\n        request_id: u64,\n        result: Vec\u003cu8\u003e,\n        #[callback_result] call_result: Result\u003c(), PromiseError\u003e,\n    ) {\n        if call_result.is_err() {\n            env::log_str(\u0026format!(\n                \"MPC signature failed for chain {} request_id {}\",\n                chain, request_id\n            ));\n            // No state changes to revert, just emit event\n            RelayerEvent::CrossChainSignatureResult {\n                chain,\n                request_id,\n                result: vec![],\n            }\n            .emit();\n            return;\n        }\n        RelayerEvent::CrossChainSignatureResult {\n            chain,\n            request_id,\n            result,\n        }\n        .emit();\n    }\n\n    #[private]\n    pub fn handle_bridge_result(\n        \u0026mut self,\n        sender_id: AccountId,\n        action_type: String,\n        result: Vec\u003cu8\u003e,\n        #[callback_result] call_result: Result\u003c(), PromiseError\u003e,\n    ) {\n        if call_result.is_err() {\n            env::log_str(\u0026format!(\n                \"Bridge action {} failed for sender {}\",\n                action_type, sender_id\n            ));\n            // No state changes to revert, just emit event\n            RelayerEvent::BridgeResult {\n                sender_id,\n                action_type,\n                result: vec![],\n            }\n            .emit();\n            return;\n        }\n        RelayerEvent::BridgeResult {\n            sender_id,\n            action_type,\n            result,\n        }\n        .emit();\n    }\n\n    #[private]\n    pub fn handle_bridge_transfer_result(\n        \u0026mut self,\n        sender_id: AccountId,\n        token: String,\n        amount: U128,\n        destination_chain: String,\n        recipient: String,\n        signature: Vec\u003cu8\u003e,\n        #[callback_result] call_result: Result\u003c(), PromiseError\u003e,\n    ) {\n        let nonce = self.relayer.get_pending_nonce(\u0026destination_chain);\n        if call_result.is_err() {\n            env::log_str(\u0026format!(\n                \"Bridge transfer failed for sender {} to chain {}\",\n                sender_id, destination_chain\n            ));\n            // Revert pending transfer and refund fee\n            if let Some(pending) = self\n                .relayer\n                .revert_pending_transfer(\u0026destination_chain, nonce)\n            {\n                if pending.fee \u003e 0 {\n                    Promise::new(sender_id.clone())\n                        .transfer(NearToken::from_yoctonear(pending.fee));\n                    env::log_str(\u0026format!(\n                        \"Refunded {} yoctoNEAR to {}\",\n                        pending.fee, sender_id\n                    ));\n                }\n            }\n            RelayerEvent::BridgeTransferFailed {\n                token,\n                amount,\n                destination_chain,\n                recipient,\n                sender: sender_id,\n                nonce,\n            }\n            .emit();\n            return;\n        }\n        // Confirm transfer and update nonce\n        self.relayer\n            .confirm_pending_transfer(\u0026destination_chain, nonce);\n        RelayerEvent::BridgeTransferCompleted {\n            token,\n            amount,\n            destination_chain,\n            recipient,\n            sender: sender_id,\n            signature,\n        }\n        .emit();\n    }\n\n    #[private]\n    #[handle_result]\n    pub fn handle_auth_result(\n        \u0026mut self,\n        sender_id: AccountId,\n        signed_delegate: SignedDelegateAction,\n        #[callback_unwrap] is_authorized: bool,\n    ) -\u003e Result\u003cPromise, RelayerError\u003e {\n        if !is_authorized {\n            return Err(RelayerError::Unauthorized);\n        }\n        let tx_hash = env::sha256(\n            \u0026borsh::to_vec(\u0026signed_delegate.delegate_action)\n                .map_err(|_| RelayerError::InvalidNonce)?,\n        );\n        relay::verify_signature(\u0026signed_delegate, \u0026tx_hash)?;\n        let delegate = signed_delegate.delegate_action;\n        let action = delegate.actions.first().unwrap();\n        let request_id = env::block_timestamp();\n        let promise = relay::execute_action(\n            \u0026mut self.relayer,\n            action,\n            \u0026sender_id,\n            action.type_name(),\n            Some(request_id),\n        )?;\n        let promise = match action {\n            Action::ChainSignatureRequest { target_chain, .. } =\u003e promise.then(\n                ext_self::ext(env::current_account_id())\n                    .with_static_gas(Gas::from_tgas(self.relayer.cross_contract_gas))\n                    .handle_mpc_signature(target_chain.clone(), request_id, Vec::new()),\n            ),\n            Action::BridgeTransfer {\n                token,\n                amount,\n                destination_chain,\n                recipient,\n                ..\n            } =\u003e promise.then(\n                ext_self::ext(env::current_account_id())\n                    .with_static_gas(Gas::from_tgas(self.relayer.cross_contract_gas))\n                    .handle_bridge_transfer_result(\n                        sender_id.clone(),\n                        token.clone(),\n                        *amount,\n                        destination_chain.clone(),\n                        recipient.clone(),\n                        Vec::new(),\n                    ),\n            ),\n            _ =\u003e promise.then(\n                ext_self::ext(env::current_account_id())\n                    .with_static_gas(Gas::from_tgas(self.relayer.cross_contract_gas))\n                    .handle_bridge_result(\n                        sender_id.clone(),\n                        action.type_name().to_string(),\n                        Vec::new(),\n                    ),\n            ),\n        };\n        Ok(promise)\n    }\n\n    #[private]\n    pub fn handle_registration(\n        \u0026mut self,\n        account_id: AccountId,\n        token: String,\n        _is_sender: bool,\n        #[callback_unwrap] is_registered: bool,\n    ) -\u003e Promise {\n        if !is_registered {\n            ext_ft_wrapper::ext(self.relayer.ft_wrapper_contract.clone())\n                .with_static_gas(Gas::from_tgas(self.relayer.cross_contract_gas))\n                .with_attached_deposit(NearToken::from_yoctonear(1_250_000_000_000_000_000_000))\n                .storage_deposit(token, account_id, U128(1_250_000_000_000_000_000_000))\n        } else {\n            Promise::new(env::current_account_id())\n        }\n    }\n\n    #[private]\n    #[init(ignore_state)]\n    pub fn migrate() -\u003e Self {\n        Self {\n            relayer: Relayer::migrate(),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests;\n","traces":[],"covered":0,"coverable":0},{"path":["/","code","contracts","relayer-onsocial","src","relay.rs"],"content":"use crate::{\n    errors::RelayerError,\n    events::RelayerEvent,\n    ext_auth, ext_ft_wrapper, ext_mpc, ext_omi_locker, ext_self,\n    state::Relayer,\n    types::{Action, SignatureScheme, SignedDelegateAction},\n};\nuse base64::engine::general_purpose::STANDARD as Base64;\nuse base64::Engine;\nuse core::num::NonZeroU128;\nuse ed25519_dalek::{Signature as Ed25519Signature, Verifier, VerifyingKey};\nuse near_crypto::KeyType;\nuse near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};\nuse near_sdk::{env, AccountId, Allowance, Gas, NearToken, Promise};\n\n#[derive(BorshSerialize, BorshDeserialize)]\nstruct SignRequest {\n    payload: Vec\u003cu8\u003e,\n    path: String,\n    key_version: u32,\n    request_id: u64,\n}\n\n#[derive(BorshSerialize, BorshDeserialize)]\nstruct BridgeTransferPayload {\n    token: String,\n    amount: u128,\n    destination_chain: String,\n    recipient: String,\n    sender: AccountId,\n    nonce: u64,\n}\n\npub fn verify_signature(\n    signed_delegate: \u0026SignedDelegateAction,\n    tx_hash: \u0026[u8],\n) -\u003e Result\u003c(), RelayerError\u003e {\n    let payload =\n        borsh::to_vec(\u0026signed_delegate.delegate_action).map_err(|_| RelayerError::InvalidNonce)?;\n    if env::sha256(\u0026payload) != tx_hash {\n        return Err(RelayerError::InvalidSignature);\n    }\n    match signed_delegate.scheme {\n        SignatureScheme::Ed25519 =\u003e {\n            let signature_bytes: [u8; 64] = signed_delegate\n                .signature\n                .clone()\n                .try_into()\n                .map_err(|_| RelayerError::Unauthorized)?;\n            let signature = Ed25519Signature::from_bytes(\u0026signature_bytes);\n            let public_key_bytes = signed_delegate.public_key.as_bytes();\n            if public_key_bytes.len() != 33 || public_key_bytes[0] != KeyType::ED25519 as u8 {\n                return Err(RelayerError::Unauthorized);\n            }\n            let ed25519_key =\n                VerifyingKey::from_bytes(\u0026public_key_bytes[1..33].try_into().unwrap())\n                    .map_err(|_| RelayerError::Unauthorized)?;\n            ed25519_key\n                .verify(\u0026payload, \u0026signature)\n                .map_err(|_| RelayerError::Unauthorized)?;\n        }\n    }\n    Ok(())\n}\n\npub fn relay_meta_transaction(\n    relayer: \u0026mut Relayer,\n    signed_delegate: SignedDelegateAction,\n) -\u003e Result\u003cPromise, RelayerError\u003e {\n    assert!(\n        env::prepaid_gas() \u003e= Gas::from_tgas(250),\n        \"Attach at least 250 TGas\"\n    );\n    if signed_delegate.delegate_action.actions.len() \u003e 1 {\n        return Err(RelayerError::InvalidNonce);\n    }\n    let sender_id = \u0026signed_delegate.delegate_action.sender_id;\n    // Verify signer matches sender_id to prevent intermediary manipulation\n    if env::signer_account_id() != *sender_id {\n        return Err(RelayerError::Unauthorized);\n    }\n    let balance = env::account_balance().as_yoctonear();\n    if balance \u003c relayer.min_balance {\n        RelayerEvent::LowBalance { balance }.emit();\n        return Err(RelayerError::InsufficientBalance);\n    }\n    let tx_hash = env::sha256(\n        \u0026borsh::to_vec(\u0026signed_delegate.delegate_action).map_err(|_| RelayerError::InvalidNonce)?,\n    );\n    let mpc_contract = relayer\n        .chain_mpc_mapping\n        .get(\"testnet\")\n        .cloned()\n        .unwrap_or(\"v1.signer-prod.testnet\".parse().unwrap());\n    let promise = ext_mpc::ext(mpc_contract)\n        .with_static_gas(Gas::from_tgas(relayer.cross_contract_gas))\n        .get_nonce(sender_id.clone(), Base64.encode(tx_hash.clone()))\n        .then(\n            ext_auth::ext(relayer.auth_contract.clone())\n                .with_static_gas(Gas::from_tgas(relayer.cross_contract_gas))\n                .is_authorized(\n                    sender_id.clone(),\n                    signed_delegate.public_key.clone(),\n                    signed_delegate.multi_signatures.clone(),\n                ),\n        )\n        .then(\n            ext_self::ext(env::current_account_id())\n                .with_static_gas(Gas::from_tgas(relayer.cross_contract_gas))\n                .handle_auth_result(sender_id.clone(), signed_delegate.clone(), true),\n        );\n    let remaining_gas = env::prepaid_gas()\n        .as_tgas()\n        .saturating_sub(env::used_gas().as_tgas());\n    // Alert if remaining gas is low\n    if remaining_gas \u003c 50 {\n        RelayerEvent::LowGas { remaining_gas }.emit();\n    }\n    env::log_str(\u0026format!(\n        \"relay_meta_transaction: prepaid={} TGas, used={} TGas, remaining={} TGas\",\n        env::prepaid_gas().as_tgas(),\n        env::used_gas().as_tgas(),\n        remaining_gas\n    ));\n    Ok(promise)\n}\n\npub fn relay_meta_transactions(\n    relayer: \u0026mut Relayer,\n    signed_delegates: Vec\u003cSignedDelegateAction\u003e,\n) -\u003e Result\u003cVec\u003cPromise\u003e, RelayerError\u003e {\n    assert!(\n        env::prepaid_gas() \u003e= Gas::from_tgas(250),\n        \"Attach at least 250 TGas\"\n    );\n    if signed_delegates.is_empty() || signed_delegates.len() \u003e relayer.chunk_size {\n        return Err(RelayerError::InvalidNonce);\n    }\n    let balance = env::account_balance().as_yoctonear();\n    if balance \u003c relayer.min_balance {\n        RelayerEvent::LowBalance { balance }.emit();\n        return Err(RelayerError::InsufficientBalance);\n    }\n    let mut promises: Vec\u003cPromise\u003e = Vec::new();\n    let mpc_contract = relayer\n        .chain_mpc_mapping\n        .get(\"testnet\")\n        .cloned()\n        .unwrap_or(\"v1.signer-prod.testnet\".parse().unwrap());\n    for signed_delegate in signed_delegates {\n        let sender_id = \u0026signed_delegate.delegate_action.sender_id;\n        // Verify signer matches sender_id\n        if env::signer_account_id() != *sender_id {\n            return Err(RelayerError::Unauthorized);\n        }\n        let tx_hash = env::sha256(\n            \u0026borsh::to_vec(\u0026signed_delegate.delegate_action)\n                .map_err(|_| RelayerError::InvalidNonce)?,\n        );\n        let promise = ext_mpc::ext(mpc_contract.clone())\n            .with_static_gas(Gas::from_tgas(relayer.cross_contract_gas))\n            .get_nonce(sender_id.clone(), Base64.encode(tx_hash))\n            .then(\n                ext_auth::ext(relayer.auth_contract.clone())\n                    .with_static_gas(Gas::from_tgas(relayer.cross_contract_gas))\n                    .is_authorized(\n                        sender_id.clone(),\n                        signed_delegate.public_key.clone(),\n                        signed_delegate.multi_signatures.clone(),\n                    ),\n            )\n            .then(\n                ext_self::ext(env::current_account_id())\n                    .with_static_gas(Gas::from_tgas(relayer.cross_contract_gas))\n                    .handle_auth_result(sender_id.clone(), signed_delegate.clone(), true),\n            );\n        promises.push(promise);\n    }\n    let remaining_gas = env::prepaid_gas()\n        .as_tgas()\n        .saturating_sub(env::used_gas().as_tgas());\n    if remaining_gas \u003c 50 {\n        RelayerEvent::LowGas { remaining_gas }.emit();\n    }\n    env::log_str(\u0026format!(\n        \"relay_meta_transactions: prepaid={} TGas, used={} TGas, remaining={} TGas\",\n        env::prepaid_gas().as_tgas(),\n        env::used_gas().as_tgas(),\n        remaining_gas\n    ));\n    Ok(promises)\n}\n\npub fn relay_chunked_meta_transactions(\n    relayer: \u0026mut Relayer,\n    signed_delegates: Vec\u003cSignedDelegateAction\u003e,\n) -\u003e Result\u003cVec\u003cPromise\u003e, RelayerError\u003e {\n    assert!(\n        env::prepaid_gas() \u003e= Gas::from_tgas(250),\n        \"Attach at least 250 TGas\"\n    );\n    if signed_delegates.is_empty() {\n        return Err(RelayerError::InvalidNonce);\n    }\n    let balance = env::account_balance().as_yoctonear();\n    if balance \u003c relayer.min_balance {\n        RelayerEvent::LowBalance { balance }.emit();\n        return Err(RelayerError::InsufficientBalance);\n    }\n    let mpc_contract = relayer\n        .chain_mpc_mapping\n        .get(\"testnet\")\n        .cloned()\n        .unwrap_or(\"v1.signer-prod.testnet\".parse().unwrap());\n    let mut all_promises = Vec::new();\n    for chunk in signed_delegates.chunks(relayer.chunk_size) {\n        let chunk_promises: Vec\u003cPromise\u003e = chunk\n            .iter()\n            .map(|signed_delegate| {\n                let sender_id = \u0026signed_delegate.delegate_action.sender_id;\n                // Verify signer matches sender_id\n                if env::signer_account_id() != *sender_id {\n                    return Promise::new(env::current_account_id()).function_call(\n                        \"panic\".to_string(),\n                        borsh::to_vec(\u0026RelayerError::Unauthorized).unwrap_or_default(),\n                        NearToken::from_yoctonear(0),\n                        Gas::from_tgas(relayer.cross_contract_gas),\n                    );\n                }\n                match borsh::to_vec(\u0026signed_delegate.delegate_action) {\n                    Ok(payload) =\u003e {\n                        let tx_hash = env::sha256(\u0026payload);\n                        ext_mpc::ext(mpc_contract.clone())\n                            .with_static_gas(Gas::from_tgas(relayer.cross_contract_gas))\n                            .get_nonce(sender_id.clone(), Base64.encode(tx_hash))\n                            .then(\n                                ext_auth::ext(relayer.auth_contract.clone())\n                                    .with_static_gas(Gas::from_tgas(relayer.cross_contract_gas))\n                                    .is_authorized(\n                                        sender_id.clone(),\n                                        signed_delegate.public_key.clone(),\n                                        signed_delegate.multi_signatures.clone(),\n                                    ),\n                            )\n                            .then(\n                                ext_self::ext(env::current_account_id())\n                                    .with_static_gas(Gas::from_tgas(relayer.cross_contract_gas))\n                                    .handle_auth_result(\n                                        sender_id.clone(),\n                                        signed_delegate.clone(),\n                                        true,\n                                    ),\n                            )\n                    }\n                    Err(_) =\u003e Promise::new(env::current_account_id()).function_call(\n                        \"panic\".to_string(),\n                        borsh::to_vec(\u0026RelayerError::InvalidNonce).unwrap_or_default(),\n                        NearToken::from_yoctonear(0),\n                        Gas::from_tgas(relayer.cross_contract_gas),\n                    ),\n                }\n            })\n            .collect();\n        all_promises.extend(chunk_promises);\n    }\n    let remaining_gas = env::prepaid_gas()\n        .as_tgas()\n        .saturating_sub(env::used_gas().as_tgas());\n    if remaining_gas \u003c 50 {\n        RelayerEvent::LowGas { remaining_gas }.emit();\n    }\n    env::log_str(\u0026format!(\n        \"relay_chunked_meta_transactions: prepaid={} TGas, used={} TGas, remaining={} TGas\",\n        env::prepaid_gas().as_tgas(),\n        env::used_gas().as_tgas(),\n        remaining_gas\n    ));\n    Ok(all_promises)\n}\n\npub fn execute_action(\n    relayer: \u0026mut Relayer,\n    action: \u0026Action,\n    sender_id: \u0026AccountId,\n    _action_type: \u0026str,\n    request_id: Option\u003cu64\u003e,\n) -\u003e Result\u003cPromise, RelayerError\u003e {\n    assert!(\n        env::prepaid_gas() \u003e= Gas::from_tgas(250),\n        \"Attach at least 250 TGas\"\n    );\n    let initial_storage = env::storage_usage();\n    let mut promise = Promise::new(sender_id.clone());\n    match action {\n        Action::FunctionCall {\n            method_name,\n            args,\n            gas: _,\n            deposit,\n        } =\u003e {\n            promise = promise.function_call(\n                method_name.clone(),\n                args.clone(),\n                NearToken::from_yoctonear(deposit.as_yoctonear()),\n                Gas::from_tgas(relayer.cross_contract_gas),\n            );\n        }\n        Action::Transfer { deposit } =\u003e {\n            promise = promise.transfer(NearToken::from_yoctonear(deposit.as_yoctonear()));\n        }\n        Action::AddKey {\n            public_key,\n            allowance,\n            receiver_id,\n            method_names,\n        } =\u003e {\n            promise = promise.add_access_key_allowance(\n                public_key.clone(),\n                allowance.map_or(Allowance::Unlimited, |t| {\n                    Allowance::Limited(NonZeroU128::new(t.as_yoctonear()).unwrap())\n                }),\n                receiver_id.clone(),\n                method_names.join(\",\"),\n            );\n        }\n        Action::ChainSignatureRequest {\n            target_chain,\n            derivation_path,\n            payload,\n        } =\u003e {\n            let mpc_contract = relayer\n                .chain_mpc_mapping\n                .get(target_chain)\n                .ok_or(RelayerError::InvalidAccountId)?;\n            let request = SignRequest {\n                payload: payload.clone(),\n                path: derivation_path.clone(),\n                key_version: 0,\n                request_id: request_id.ok_or(RelayerError::InvalidNonce)?,\n            };\n            let args = borsh::to_vec(\u0026request).map_err(|_| RelayerError::InvalidAccountId)?;\n            promise = Promise::new(mpc_contract.clone()).function_call(\n                \"sign\".to_string(),\n                args,\n                NearToken::from_yoctonear(1),\n                Gas::from_tgas(relayer.cross_contract_gas),\n            );\n        }\n        Action::FtTransfer {\n            token,\n            receiver_id,\n            amount,\n            memo,\n        } =\u003e {\n            let sender_promise = ext_ft_wrapper::ext(relayer.ft_wrapper_contract.clone())\n                .with_static_gas(Gas::from_tgas(100))\n                .is_registered(token.clone(), sender_id.clone())\n                .then(\n                    ext_self::ext(env::current_account_id())\n                        .with_static_gas(Gas::from_tgas(100))\n                        .handle_registration(sender_id.clone(), token.clone(), true, true),\n                );\n            let receiver_promise = ext_ft_wrapper::ext(relayer.ft_wrapper_contract.clone())\n                .with_static_gas(Gas::from_tgas(100))\n                .is_registered(token.clone(), receiver_id.clone())\n                .then(\n                    ext_self::ext(env::current_account_id())\n                        .with_static_gas(Gas::from_tgas(100))\n                        .handle_registration(receiver_id.clone(), token.clone(), false, true),\n                );\n            promise = sender_promise.then(receiver_promise).then(\n                ext_ft_wrapper::ext(relayer.ft_wrapper_contract.clone())\n                    .with_static_gas(Gas::from_tgas(100))\n                    .ft_transfer(token.clone(), receiver_id.clone(), *amount, memo.clone()),\n            );\n        }\n        Action::BridgeTransfer {\n            token,\n            amount,\n            destination_chain,\n            recipient,\n        } =\u003e {\n            let fee = relayer.base_fee;\n            let balance = env::account_balance().as_yoctonear();\n            // Check if relayer can cover the fee\n            if balance \u003c relayer.min_balance + fee {\n                RelayerEvent::LowBalance { balance }.emit();\n                return Err(RelayerError::InsufficientBalance);\n            }\n            let total_cost = 15_000_000_000_000; // 15 TGas for lock + sign\n            if fee \u003e 0 \u0026\u0026 fee \u003c total_cost / 1_000_000_000_000 * 1_000_000_000_000_000_000_000 {\n                return Err(RelayerError::FeeTooLow);\n            }\n            // Store pending transfer instead of incrementing nonce immediately\n            let nonce = relayer.get_pending_nonce(destination_chain);\n            let lock_promise = ext_omi_locker::ext(\n                relayer\n                    .omni_locker_contract\n                    .get()\n                    .clone()\n                    .map(|x| x.clone())\n                    .unwrap_or_else(|| env::current_account_id()),\n            )\n            .with_static_gas(Gas::from_tgas(relayer.cross_contract_gas))\n            .lock(\n                token.clone(),\n                *amount,\n                destination_chain.clone(),\n                recipient.clone(),\n            );\n            let mpc_contract = relayer\n                .chain_mpc_mapping\n                .get(destination_chain)\n                .ok_or(RelayerError::InvalidNonce)?;\n            let payload = BridgeTransferPayload {\n                token: token.clone(),\n                amount: amount.0,\n                destination_chain: destination_chain.clone(),\n                recipient: recipient.clone(),\n                sender: sender_id.clone(),\n                nonce,\n            };\n            let payload_bytes =\n                borsh::to_vec(\u0026payload).map_err(|_| RelayerError::InvalidAccountId)?;\n            let sign_promise = Promise::new(mpc_contract.clone()).function_call(\n                \"sign\".to_string(),\n                borsh::to_vec(\u0026SignRequest {\n                    payload: payload_bytes,\n                    path: \"\".to_string(),\n                    key_version: 0,\n                    request_id: request_id.unwrap_or(env::block_timestamp()),\n                })\n                .map_err(|_| RelayerError::InvalidAccountId)?,\n                NearToken::from_yoctonear(0),\n                Gas::from_tgas(relayer.cross_contract_gas),\n            );\n            // Store pending transfer\n            relayer.add_pending_transfer(\n                destination_chain.clone(),\n                nonce,\n                sender_id.clone(),\n                token.clone(),\n                *amount,\n                recipient.clone(),\n                fee,\n            );\n            RelayerEvent::BridgeTransferInitiated {\n                token: token.clone(),\n                amount: *amount,\n                destination_chain: destination_chain.clone(),\n                recipient: recipient.clone(),\n                sender: sender_id.clone(),\n                nonce,\n            }\n            .emit();\n            RelayerEvent::FeeCharged {\n                action: \"BridgeTransfer\".to_string(),\n                fee,\n                sender: sender_id.clone(),\n            }\n            .emit();\n            promise = lock_promise.then(sign_promise);\n        }\n    }\n    // Check storage cost\n    let storage_used = env::storage_usage() - initial_storage;\n    let storage_cost = storage_used as u128 * env::storage_byte_cost().as_yoctonear();\n    if env::account_balance().as_yoctonear() \u003c relayer.min_balance + storage_cost {\n        RelayerEvent::LowBalance {\n            balance: env::account_balance().as_yoctonear(),\n        }\n        .emit();\n        return Err(RelayerError::InsufficientBalance);\n    }\n    let remaining_gas = env::prepaid_gas()\n        .as_tgas()\n        .saturating_sub(env::used_gas().as_tgas());\n    if remaining_gas \u003c 50 {\n        RelayerEvent::LowGas { remaining_gas }.emit();\n    }\n    env::log_str(\u0026format!(\n        \"execute_action: prepaid={} TGas, used={} TGas, remaining={} TGas, storage_used={} bytes, storage_cost={} yoctoNEAR\",\n        env::prepaid_gas().as_tgas(),\n        env::used_gas().as_tgas(),\n        remaining_gas,\n        storage_used,\n        storage_cost\n    ));\n    Ok(promise)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","code","contracts","relayer-onsocial","src","sponsor.rs"],"content":"use crate::errors::RelayerError;\nuse crate::events::RelayerEvent;\nuse crate::relay;\nuse crate::types::SignedDelegateAction;\nuse crate::{ext_auth, state::Relayer};\nuse near_sdk::borsh::to_vec;\nuse near_sdk::{env, AccountId, Gas, NearToken, Promise, PublicKey};\n\npub fn sponsor_account_with_registrar(\n    relayer: \u0026mut Relayer,\n    new_account_id: AccountId,\n    public_key: PublicKey,\n    is_multi_sig: bool,\n    multi_sig_threshold: Option\u003cu32\u003e,\n) -\u003e Result\u003cPromise, RelayerError\u003e {\n    let balance = env::account_balance();\n    if balance.as_yoctonear() \u003c relayer.min_balance {\n        RelayerEvent::LowBalance {\n            balance: balance.as_yoctonear(),\n        }\n        .emit();\n        return Err(RelayerError::InsufficientBalance);\n    }\n    let is_mainnet = env::current_account_id().to_string().ends_with(\".near\");\n    let registrar = if is_mainnet {\n        \"registrar.near\".parse().unwrap()\n    } else {\n        \"testnet\".parse().unwrap()\n    };\n    let account_id_str = new_account_id.to_string();\n    let account_name = account_id_str\n        .split('.')\n        .next()\n        .ok_or(RelayerError::InvalidAccountId)?;\n    if is_mainnet {\n        let len = account_name.len();\n        if len \u003c 3 || len \u003e 16 {\n            return Err(RelayerError::InvalidAccountId);\n        }\n    } else if !account_id_str.ends_with(\".testnet\") {\n        return Err(RelayerError::InvalidAccountId);\n    }\n    let min_funding = 50_000_000_000_000_000_000_000; // 0.05 NEAR\n    let funding_amount = relayer.sponsor_amount.max(min_funding);\n    let creation_deposit = if is_mainnet {\n        funding_amount / 10\n    } else {\n        1_820_000_000_000_000_000_000 // 0.00182 NEAR\n    };\n    let args = to_vec(\u0026(new_account_id.to_string(), public_key.clone()))\n        .map_err(|_| RelayerError::InvalidAccountId)?;\n    let promise = Promise::new(registrar)\n        .function_call(\n            \"create_account\".to_string(),\n            args,\n            NearToken::from_yoctonear(creation_deposit),\n            Gas::from_tgas(relayer.cross_contract_gas),\n        )\n        .then(\n            Promise::new(new_account_id.clone())\n                .add_full_access_key(public_key.clone())\n                .transfer(NearToken::from_yoctonear(funding_amount)),\n        )\n        .then(\n            ext_auth::ext(relayer.auth_contract.clone())\n                .with_static_gas(Gas::from_tgas(relayer.cross_contract_gas))\n                .register_key(\n                    new_account_id.clone(),\n                    public_key,\n                    Some(30),\n                    is_multi_sig,\n                    multi_sig_threshold,\n                ),\n        );\n    RelayerEvent::AccountSponsored {\n        account_id: new_account_id.clone(),\n    }\n    .emit();\n    Ok(promise)\n}\n\npub fn sponsor_account_signed(\n    relayer: \u0026mut Relayer,\n    signed_delegate: SignedDelegateAction,\n) -\u003e Result\u003cPromise, RelayerError\u003e {\n    relay::relay_meta_transaction(relayer, signed_delegate)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","code","contracts","relayer-onsocial","src","state.rs"],"content":"use crate::events::RelayerEvent;\nuse crate::state_versions::{StateV010, StateV011};\nuse near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};\nuse near_sdk::json_types::U128;\nuse near_sdk::store::{LazyOption, LookupMap};\nuse near_sdk::{env, AccountId};\nuse near_sdk_macros::NearSchema;\n\n#[derive(BorshDeserialize, BorshSerialize, NearSchema)]\n#[abi(borsh)]\npub struct PendingTransfer {\n    pub nonce: u64,\n    pub sender_id: AccountId,\n    pub token: String,\n    pub amount: U128,\n    pub recipient: String,\n    pub fee: u128,\n}\n\n#[derive(BorshDeserialize, BorshSerialize, NearSchema)]\n#[abi(borsh)]\npub struct Relayer {\n    pub version: String,\n    pub manager: AccountId,\n    pub offload_recipient: AccountId,\n    pub auth_contract: AccountId,\n    pub ft_wrapper_contract: AccountId,\n    pub omni_locker_contract: LazyOption\u003cAccountId\u003e,\n    pub chain_mpc_mapping: LookupMap\u003cString, AccountId\u003e,\n    pub sponsor_amount: u128,\n    pub sponsor_gas: u64,\n    pub cross_contract_gas: u64,\n    pub migration_gas: u64,\n    pub chunk_size: usize,\n    pub min_balance: u128,\n    pub max_balance: u128,\n    pub base_fee: u128,\n    pub transfer_nonces: LookupMap\u003cString, u64\u003e,\n    pub pending_transfers: LookupMap\u003cString, PendingTransfer\u003e,\n}\n\nimpl Relayer {\n    pub fn new(\n        manager: AccountId,\n        offload_recipient: AccountId,\n        auth_contract: AccountId,\n        ft_wrapper_contract: AccountId,\n    ) -\u003e Self {\n        Self {\n            version: \"0.1.1\".to_string(),\n            manager,\n            offload_recipient,\n            auth_contract,\n            ft_wrapper_contract,\n            omni_locker_contract: LazyOption::new(\n                b\"omni_locker\".to_vec(),\n                Some(env::current_account_id()),\n            ),\n            chain_mpc_mapping: LookupMap::new(b\"chain_mpc\".to_vec()),\n            sponsor_amount: 10_000_000_000_000_000_000_000,\n            sponsor_gas: 100_000_000_000_000,\n            cross_contract_gas: 100_000_000_000_000, // Default: 100 TGas for cross-contract calls\n            migration_gas: 200_000_000_000_000,      // Default: 200 TGas for migrations\n            chunk_size: 5,                           // Default: 5 for chunked transactions\n            min_balance: 10_000_000_000_000_000_000_000_000,\n            max_balance: 1_000_000_000_000_000_000_000_000_000,\n            base_fee: 100_000_000_000_000_000_000,\n            transfer_nonces: LookupMap::new(b\"nonces\".to_vec()),\n            pending_transfers: LookupMap::new(b\"pending_transfers\".to_vec()),\n        }\n    }\n\n    pub fn is_manager(\u0026self, account_id: \u0026AccountId) -\u003e bool {\n        \u0026self.manager == account_id\n    }\n\n    pub fn get_pending_nonce(\u0026self, chain: \u0026str) -\u003e u64 {\n        self.transfer_nonces.get(chain).copied().unwrap_or(0)\n    }\n\n    pub fn add_pending_transfer(\n        \u0026mut self,\n        chain: String,\n        nonce: u64,\n        sender_id: AccountId,\n        token: String,\n        amount: U128,\n        recipient: String,\n        fee: u128,\n    ) {\n        let key = format!(\"{}-{}\", chain, nonce);\n        self.pending_transfers.insert(\n            key,\n            PendingTransfer {\n                nonce,\n                sender_id,\n                token,\n                amount,\n                recipient,\n                fee,\n            },\n        );\n    }\n\n    pub fn confirm_pending_transfer(\u0026mut self, chain: \u0026str, nonce: u64) {\n        let key = format!(\"{}-{}\", chain, nonce);\n        self.pending_transfers.remove(\u0026key);\n        let current_nonce = self.transfer_nonces.get(chain).copied().unwrap_or(0);\n        if nonce \u003e= current_nonce {\n            self.transfer_nonces.insert(chain.to_string(), nonce + 1);\n        }\n    }\n\n    pub fn revert_pending_transfer(\u0026mut self, chain: \u0026str, nonce: u64) -\u003e Option\u003cPendingTransfer\u003e {\n        let key = format!(\"{}-{}\", chain, nonce);\n        self.pending_transfers.remove(\u0026key)\n    }\n\n    pub fn migrate() -\u003e Self {\n        const CURRENT_VERSION: \u0026str = \"0.1.1\";\n\n        // Read raw state bytes, default to empty if none\n        let state_bytes: Vec\u003cu8\u003e = env::state_read().unwrap_or_default();\n\n        // Try current version (0.1.1)\n        if let Ok(state) = borsh::from_slice::\u003cRelayer\u003e(\u0026state_bytes) {\n            if state.version == CURRENT_VERSION {\n                env::log_str(\"State is already at latest version\");\n                return state;\n            }\n        }\n\n        // Try version 0.1.1\n        if let Ok(old_state) = borsh::from_slice::\u003cStateV011\u003e(\u0026state_bytes) {\n            if old_state.version == \"0.1.1\" {\n                env::log_str(\"Migrating from state version 0.1.1\");\n                let new_state = Relayer {\n                    version: CURRENT_VERSION.to_string(),\n                    manager: old_state.manager,\n                    offload_recipient: old_state.offload_recipient,\n                    auth_contract: old_state.auth_contract,\n                    ft_wrapper_contract: old_state.ft_wrapper_contract,\n                    omni_locker_contract: old_state.omni_locker_contract,\n                    chain_mpc_mapping: old_state.chain_mpc_mapping,\n                    sponsor_amount: old_state.sponsor_amount,\n                    sponsor_gas: old_state.sponsor_gas,\n                    cross_contract_gas: old_state.cross_contract_gas,\n                    migration_gas: old_state.migration_gas,\n                    chunk_size: old_state.chunk_size,\n                    min_balance: old_state.min_balance,\n                    max_balance: old_state.max_balance,\n                    base_fee: old_state.base_fee,\n                    transfer_nonces: LookupMap::new(b\"nonces\".to_vec()),\n                    pending_transfers: LookupMap::new(b\"pending_transfers\".to_vec()),\n                };\n                RelayerEvent::StateMigrated {\n                    old_version: \"0.1.1\".to_string(),\n                    new_version: CURRENT_VERSION.to_string(),\n                }\n                .emit();\n                return new_state;\n            }\n        }\n\n        // Try version 0.1.0\n        if let Ok(old_state) = borsh::from_slice::\u003cStateV010\u003e(\u0026state_bytes) {\n            if old_state.version == \"0.1.0\" {\n                env::log_str(\"Migrating from state version 0.1.0\");\n                let new_state = Relayer {\n                    version: CURRENT_VERSION.to_string(),\n                    manager: old_state.manager,\n                    offload_recipient: old_state.offload_recipient,\n                    auth_contract: old_state.auth_contract,\n                    ft_wrapper_contract: old_state.ft_wrapper_contract,\n                    omni_locker_contract: old_state.omni_locker_contract,\n                    chain_mpc_mapping: old_state.chain_mpc_mapping,\n                    sponsor_amount: old_state.sponsor_amount,\n                    sponsor_gas: old_state.sponsor_gas,\n                    cross_contract_gas: old_state.cross_contract_gas,\n                    migration_gas: old_state.migration_gas,\n                    chunk_size: old_state.chunk_size,\n                    min_balance: 10_000_000_000_000_000_000_000_000,\n                    max_balance: 1_000_000_000_000_000_000_000_000_000,\n                    base_fee: 100_000_000_000_000_000_000,\n                    transfer_nonces: LookupMap::new(b\"nonces\".to_vec()),\n                    pending_transfers: LookupMap::new(b\"pending_transfers\".to_vec()),\n                };\n                RelayerEvent::StateMigrated {\n                    old_version: \"0.1.0\".to_string(),\n                    new_version: CURRENT_VERSION.to_string(),\n                }\n                .emit();\n                return new_state;\n            }\n        }\n\n        env::log_str(\"No valid prior state found, initializing new state\");\n        Self::new(\n            env::current_account_id(),\n            \"recipient.testnet\".parse::\u003cAccountId\u003e().unwrap(),\n            \"auth.testnet\".parse::\u003cAccountId\u003e().unwrap(),\n            \"ft.testnet\".parse::\u003cAccountId\u003e().unwrap(),\n        )\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","code","contracts","relayer-onsocial","src","state_versions.rs"],"content":"use near_sdk::borsh::{BorshDeserialize, BorshSerialize};\nuse near_sdk::store::{LazyOption, LookupMap};\nuse near_sdk::AccountId;\nuse near_sdk_macros::NearSchema;\n\n// State for version 0.1.0\n#[derive(BorshSerialize, BorshDeserialize, NearSchema)]\n#[abi(borsh)]\npub struct StateV010 {\n    pub version: String,\n    pub manager: AccountId,\n    pub offload_recipient: AccountId,\n    pub auth_contract: AccountId,\n    pub ft_wrapper_contract: AccountId,\n    pub omni_locker_contract: LazyOption\u003cAccountId\u003e,\n    pub chain_mpc_mapping: LookupMap\u003cString, AccountId\u003e,\n    pub sponsor_amount: u128,\n    pub sponsor_gas: u64,\n    pub cross_contract_gas: u64,\n    pub migration_gas: u64,\n    pub chunk_size: usize,\n}\n\n// State for version 0.1.1\n#[derive(BorshSerialize, BorshDeserialize, NearSchema)]\n#[abi(borsh)]\npub struct StateV011 {\n    pub version: String,\n    pub manager: AccountId,\n    pub offload_recipient: AccountId,\n    pub auth_contract: AccountId,\n    pub ft_wrapper_contract: AccountId,\n    pub omni_locker_contract: LazyOption\u003cAccountId\u003e,\n    pub chain_mpc_mapping: LookupMap\u003cString, AccountId\u003e,\n    pub sponsor_amount: u128,\n    pub sponsor_gas: u64,\n    pub cross_contract_gas: u64,\n    pub migration_gas: u64,\n    pub chunk_size: usize,\n    pub min_balance: u128,\n    pub max_balance: u128,\n    pub base_fee: u128,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","code","contracts","relayer-onsocial","src","tests.rs"],"content":"#[cfg(test)]\nmod tests {\n    use crate::types::{Action, DelegateAction, SignatureScheme, SignedDelegateAction};\n    use crate::{\n        state_versions::{StateV010, StateV011},\n        OnSocialRelayer,\n    };\n    use near_sdk::borsh;\n    use near_sdk::store::{LazyOption, LookupMap};\n    use near_sdk::{\n        env,\n        test_utils::{get_logs, VMContextBuilder},\n        testing_env, AccountId, CurveType, NearToken, PublicKey,\n    };\n\n    fn setup_context(predecessor: AccountId) -\u003e VMContextBuilder {\n        let mut context = VMContextBuilder::new();\n        context\n            .predecessor_account_id(predecessor)\n            .current_account_id(\"relayer.testnet\".parse::\u003cAccountId\u003e().unwrap())\n            .block_timestamp(1_000_000_000_000)\n            .attached_deposit(NearToken::from_yoctonear(0));\n        context\n    }\n\n    #[test]\n    fn test_migration_from_010_to_011() {\n        let manager: AccountId = \"manager.testnet\".parse().unwrap();\n        let context = setup_context(manager.clone());\n        testing_env!(context.build());\n\n        let state_v010 = StateV010 {\n            version: \"0.1.0\".to_string(),\n            manager: manager.clone(),\n            offload_recipient: \"recipient.testnet\".parse().unwrap(),\n            auth_contract: \"auth.testnet\".parse().unwrap(),\n            ft_wrapper_contract: \"ft.testnet\".parse().unwrap(),\n            omni_locker_contract: LazyOption::new(\n                b\"omni_locker\".to_vec(),\n                Some(\"locker.testnet\".parse::\u003cAccountId\u003e().unwrap()),\n            ),\n            chain_mpc_mapping: LookupMap::new(b\"chain_mpc\".to_vec()),\n            sponsor_amount: 10_000_000_000_000_000_000_000,\n            sponsor_gas: 100_000_000_000_000,\n            cross_contract_gas: 100_000_000_000_000,\n            migration_gas: 250_000_000_000_000, // Added: 250 TGas\n            chunk_size: 10,\n        };\n        // Serialize state to Borsh\n        let state_bytes = borsh::to_vec(\u0026state_v010).expect(\"Failed to serialize state\");\n        env::state_write(\u0026state_bytes);\n\n        let new_contract = OnSocialRelayer::migrate();\n\n        assert_eq!(\n            new_contract.relayer.version, \"0.1.1\",\n            \"Version should be 0.1.1\"\n        );\n        assert_eq!(\n            new_contract.relayer.manager, manager,\n            \"Manager should be preserved\"\n        );\n        assert_eq!(\n            new_contract.relayer.offload_recipient,\n            \"recipient.testnet\".parse::\u003cAccountId\u003e().unwrap(),\n            \"Offload recipient should be preserved\"\n        );\n        assert_eq!(\n            new_contract.relayer.auth_contract,\n            \"auth.testnet\".parse::\u003cAccountId\u003e().unwrap(),\n            \"Auth contract should be preserved\"\n        );\n        assert_eq!(\n            new_contract.relayer.ft_wrapper_contract,\n            \"ft.testnet\".parse::\u003cAccountId\u003e().unwrap(),\n            \"FT wrapper contract should be preserved\"\n        );\n        assert_eq!(\n            new_contract.relayer.min_balance, 10_000_000_000_000_000_000_000_000,\n            \"Min balance should be initialized\"\n        );\n        assert_eq!(\n            new_contract.relayer.max_balance, 1_000_000_000_000_000_000_000_000_000,\n            \"Max balance should be initialized\"\n        );\n        assert_eq!(\n            new_contract.relayer.base_fee, 100_000_000_000_000_000_000,\n            \"Base fee should be initialized\"\n        );\n\n        let logs = get_logs();\n        assert!(\n            logs.contains(\u0026\"Migrating from state version 0.1.0\".to_string()),\n            \"Expected migration log, got: {:?}\",\n            logs\n        );\n        assert!(\n            logs.contains(\u0026\"EVENT_JSON:{\\\"standard\\\":\\\"nep297\\\",\\\"version\\\":\\\"1.0.0\\\",\\\"event\\\":\\\"state_migrated\\\",\\\"data\\\":{\\\"old_version\\\":\\\"0.1.0\\\",\\\"new_version\\\":\\\"0.1.1\\\"}}\".to_string()),\n            \"Expected state_migrated event, got: {:?}\", logs\n        );\n    }\n\n    #[test]\n    fn test_migration_from_011_to_011() {\n        let manager: AccountId = \"manager.testnet\".parse().unwrap();\n        let context = setup_context(manager.clone());\n        testing_env!(context.build());\n\n        let state_v011 = StateV011 {\n            version: \"0.1.1\".to_string(),\n            manager: manager.clone(),\n            offload_recipient: \"recipient.testnet\".parse().unwrap(),\n            auth_contract: \"auth.testnet\".parse().unwrap(),\n            ft_wrapper_contract: \"ft.testnet\".parse().unwrap(),\n            omni_locker_contract: LazyOption::new(\n                b\"omni_locker\".to_vec(),\n                Some(\"locker.testnet\".parse::\u003cAccountId\u003e().unwrap()),\n            ),\n            chain_mpc_mapping: LookupMap::new(b\"chain_mpc\".to_vec()),\n            sponsor_amount: 10_000_000_000_000_000_000_000,\n            sponsor_gas: 100_000_000_000_000,\n            cross_contract_gas: 100_000_000_000_000,\n            migration_gas: 250_000_000_000_000, // Added: 250 TGas\n            chunk_size: 10,\n            min_balance: 10_000_000_000_000_000_000_000_000,\n            max_balance: 1_000_000_000_000_000_000_000_000_000,\n            base_fee: 100_000_000_000_000_000_000,\n        };\n        // Serialize state to Borsh\n        let state_bytes = borsh::to_vec(\u0026state_v011).expect(\"Failed to serialize state\");\n        env::state_write(\u0026state_bytes);\n\n        let new_contract = OnSocialRelayer::migrate();\n\n        assert_eq!(\n            new_contract.relayer.version, \"0.1.1\",\n            \"Version should be 0.1.1\"\n        );\n        assert_eq!(\n            new_contract.relayer.manager, manager,\n            \"Manager should be preserved\"\n        );\n        assert_eq!(\n            new_contract.relayer.offload_recipient,\n            \"recipient.testnet\".parse::\u003cAccountId\u003e().unwrap(),\n            \"Offload recipient should be preserved\"\n        );\n        assert_eq!(\n            new_contract.relayer.auth_contract,\n            \"auth.testnet\".parse::\u003cAccountId\u003e().unwrap(),\n            \"Auth contract should be preserved\"\n        );\n        assert_eq!(\n            new_contract.relayer.ft_wrapper_contract,\n            \"ft.testnet\".parse::\u003cAccountId\u003e().unwrap(),\n            \"FT wrapper contract should be preserved\"\n        );\n        assert_eq!(\n            new_contract.relayer.min_balance, 10_000_000_000_000_000_000_000_000,\n            \"Min balance should be preserved\"\n        );\n        assert_eq!(\n            new_contract.relayer.max_balance, 1_000_000_000_000_000_000_000_000_000,\n            \"Max balance should be preserved\"\n        );\n        assert_eq!(\n            new_contract.relayer.base_fee, 100_000_000_000_000_000_000,\n            \"Base fee should be preserved\"\n        );\n\n        let logs = get_logs();\n        assert!(\n            logs.contains(\u0026\"Migrating from state version 0.1.1\".to_string()),\n            \"Expected migration log, got: {:?}\",\n            logs\n        );\n        assert!(\n            logs.contains(\u0026\"EVENT_JSON:{\\\"standard\\\":\\\"nep297\\\",\\\"version\\\":\\\"1.0.0\\\",\\\"event\\\":\\\"state_migrated\\\",\\\"data\\\":{\\\"old_version\\\":\\\"0.1.1\\\",\\\"new_version\\\":\\\"0.1.1\\\"}}\".to_string()),\n            \"Expected state_migrated event, got: {:?}\", logs\n        );\n    }\n\n    #[test]\n    fn test_migration_no_prior_state() {\n        let manager: AccountId = \"manager.testnet\".parse().unwrap();\n        let context = setup_context(manager.clone());\n        testing_env!(context.build());\n\n        let new_contract = OnSocialRelayer::migrate();\n\n        assert_eq!(\n            new_contract.relayer.version, \"0.1.1\",\n            \"Version should be 0.1.1\"\n        );\n        assert_eq!(\n            new_contract.relayer.manager,\n            env::current_account_id(),\n            \"Manager should be current account\"\n        );\n        assert_eq!(\n            new_contract.relayer.offload_recipient,\n            \"recipient.testnet\".parse::\u003cAccountId\u003e().unwrap(),\n            \"Offload recipient should be initialized\"\n        );\n        assert_eq!(\n            new_contract.relayer.auth_contract,\n            \"auth.testnet\".parse::\u003cAccountId\u003e().unwrap(),\n            \"Auth contract should be initialized\"\n        );\n        assert_eq!(\n            new_contract.relayer.ft_wrapper_contract,\n            \"ft.testnet\".parse::\u003cAccountId\u003e().unwrap(),\n            \"FT wrapper contract should be initialized\"\n        );\n\n        let logs = get_logs();\n        assert!(\n            logs.contains(\u0026\"No valid prior state found, initializing new state\".to_string()),\n            \"Expected no prior state log, got: {:?}\",\n            logs\n        );\n    }\n\n    #[test]\n    fn test_migration_corrupted_state() {\n        let manager: AccountId = \"manager.testnet\".parse().unwrap();\n        let context = setup_context(manager.clone());\n        testing_env!(context.build());\n\n        // Simulate corrupted state\n        env::state_write(\u0026vec![0u8; 10]); // Invalid Borsh data\n\n        let new_contract = OnSocialRelayer::migrate();\n\n        assert_eq!(\n            new_contract.relayer.version, \"0.1.1\",\n            \"Version should be 0.1.1\"\n        );\n        assert_eq!(\n            new_contract.relayer.manager,\n            env::current_account_id(),\n            \"Manager should be current account\"\n        );\n        assert_eq!(\n            new_contract.relayer.offload_recipient,\n            \"recipient.testnet\".parse::\u003cAccountId\u003e().unwrap(),\n            \"Offload recipient should be initialized\"\n        );\n        assert_eq!(\n            new_contract.relayer.auth_contract,\n            \"auth.testnet\".parse::\u003cAccountId\u003e().unwrap(),\n            \"Auth contract should be initialized\"\n        );\n        assert_eq!(\n            new_contract.relayer.ft_wrapper_contract,\n            \"ft.testnet\".parse::\u003cAccountId\u003e().unwrap(),\n            \"FT wrapper contract should be initialized\"\n        );\n\n        let logs = get_logs();\n        assert!(\n            logs.contains(\u0026\"No valid prior state found, initializing new state\".to_string()),\n            \"Expected no prior state log, got: {:?}\",\n            logs\n        );\n    }\n\n    #[test]\n    fn test_gas_logging_relay_meta_transaction() {\n        let manager: AccountId = \"manager.testnet\".parse().unwrap();\n        let context = setup_context(manager.clone());\n        testing_env!(context.build());\n\n        let mut contract = OnSocialRelayer::new(\n            \"recipient.testnet\".parse().unwrap(),\n            \"auth.testnet\".parse().unwrap(),\n            \"ft.testnet\".parse().unwrap(),\n        );\n\n        // Create a mock SignedDelegateAction with multiple actions to trigger InvalidNonce\n        let delegate_action = DelegateAction {\n            sender_id: \"sender.testnet\".parse().unwrap(),\n            receiver_id: \"receiver.testnet\".parse().unwrap(),\n            actions: vec![\n                Action::Transfer {\n                    deposit: NearToken::from_yoctonear(1_000_000_000_000_000_000_000),\n                },\n                Action::Transfer {\n                    deposit: NearToken::from_yoctonear(1_000_000_000_000_000_000_000),\n                },\n            ],\n            nonce: 1,\n            max_block_height: 1_000_000,\n        };\n        let dummy_key = vec![0u8; 32]; // Use 32 bytes for Ed25519 public key\n        let signed_delegate = SignedDelegateAction {\n            delegate_action,\n            signature: vec![0u8; 64], // Dummy signature\n            public_key: PublicKey::from_parts(CurveType::ED25519, dummy_key)\n                .expect(\"Failed to create dummy public key\"),\n            session_nonce: 0,\n            scheme: SignatureScheme::Ed25519,\n            fee_action: None,\n            multi_signatures: None,\n        };\n\n        let result = contract.relay_meta_transaction(signed_delegate);\n        assert!(result.is_err(), \"Expected InvalidNonce error\");\n        let logs = get_logs();\n        assert!(\n            logs.iter()\n                .any(|log| log.contains(\"Gas used in relay_meta_transaction\")),\n            \"Expected gas usage log, got: {:?}\",\n            logs\n        );\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","code","contracts","relayer-onsocial","src","types.rs"],"content":"use near_sdk::borsh::{BorshDeserialize, BorshSerialize};\nuse near_sdk::json_types::U128;\nuse near_sdk::{AccountId, Gas, NearToken, PublicKey};\nuse near_sdk_macros::NearSchema;\nuse serde::{Deserialize, Serialize};\n\n#[derive(\n    Clone, Eq, PartialEq, BorshSerialize, BorshDeserialize, Serialize, Deserialize, NearSchema,\n)]\n#[abi(borsh, json)]\npub enum Action {\n    ChainSignatureRequest {\n        target_chain: String,\n        derivation_path: String,\n        payload: Vec\u003cu8\u003e,\n    },\n    FunctionCall {\n        method_name: String,\n        args: Vec\u003cu8\u003e,\n        gas: Gas,\n        deposit: NearToken,\n    },\n    Transfer {\n        deposit: NearToken,\n    },\n    AddKey {\n        public_key: PublicKey,\n        allowance: Option\u003cNearToken\u003e,\n        receiver_id: AccountId,\n        method_names: Vec\u003cString\u003e,\n    },\n    FtTransfer {\n        token: String,\n        receiver_id: AccountId,\n        amount: U128,\n        memo: Option\u003cString\u003e,\n    },\n    BridgeTransfer {\n        token: String,\n        amount: U128,\n        destination_chain: String,\n        recipient: String,\n    },\n}\n\nimpl Action {\n    pub fn type_name(\u0026self) -\u003e \u0026str {\n        match self {\n            Action::ChainSignatureRequest { .. } =\u003e \"ChainSignatureRequest\",\n            Action::FunctionCall { .. } =\u003e \"FunctionCall\",\n            Action::Transfer { .. } =\u003e \"Transfer\",\n            Action::AddKey { .. } =\u003e \"AddKey\",\n            Action::FtTransfer { .. } =\u003e \"FtTransfer\",\n            Action::BridgeTransfer { .. } =\u003e \"BridgeTransfer\",\n        }\n    }\n}\n\n#[derive(\n    Clone, Eq, PartialEq, BorshSerialize, BorshDeserialize, Serialize, Deserialize, NearSchema,\n)]\n#[abi(borsh, json)]\npub struct DelegateAction {\n    pub sender_id: AccountId,\n    pub receiver_id: AccountId,\n    pub actions: Vec\u003cAction\u003e,\n    pub nonce: u64,\n    pub max_block_height: u64,\n}\n\n#[derive(\n    Clone, Eq, PartialEq, BorshSerialize, BorshDeserialize, Serialize, Deserialize, NearSchema,\n)]\n#[abi(borsh, json)]\npub enum SignatureScheme {\n    Ed25519,\n}\n\n#[derive(\n    Clone, Eq, PartialEq, BorshSerialize, BorshDeserialize, Serialize, Deserialize, NearSchema,\n)]\n#[abi(borsh, json)]\npub struct SignedDelegateAction {\n    pub delegate_action: DelegateAction,\n    pub signature: Vec\u003cu8\u003e,\n    pub public_key: PublicKey,\n    pub session_nonce: u64,\n    pub scheme: SignatureScheme,\n    pub fee_action: Option\u003cAction\u003e,\n    pub multi_signatures: Option\u003cVec\u003cVec\u003cu8\u003e\u003e\u003e, // Added for multi-sig support\n}\n","traces":[],"covered":0,"coverable":0}]};
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      }
    };
  });

  return [
    ...folders,
    ...files.filter(file => file.path.length === 1),
  ];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener("hashchange", () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.substr(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(({current}) => {
      return {current: [...current, file.path[0]]};
    }, () => this.updateHash());
  }

  back(file) {
    this.setState(({current}) => {
      return {current: current.slice(0, current.length - 1)};
    }, () => this.updateHash());
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e('div', {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e('table', {className: 'files-list'},
      e('thead', {className: 'files-list__head'},
        e('tr', null,
          e('th', null, "Path"),
          e('th', null, "Coverage")
        )
      ),
      e('tbody', {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile}))
      )
    )
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? file.covered / file.coverable * 100 : -1;
  const coverageDelta = file.prevRun &&
    (file.covered / file.coverable * 100 - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('tr', {
      className: 'files-list__file'
        + (coverage >= 0 && coverage < 50 ? ' files-list__file_low': '')
        + (coverage >= 50 && coverage < 80 ? ' files-list__file_medium': '')
        + (coverage >= 80 ? ' files-list__file_high': '')
        + (file.is_folder ? ' files-list__file_folder': ''),
      onClick: () => onClick(file),
    },
    e('td', null, e('a', null, pathToString(file.path))),
    e('td', null,
      file.covered + ' / ' + file.coverable +
      (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'},
    e(FileHeader, {file, onBack}),
    e(FileContent, {file})
  );
}

function FileHeader({file, onBack}) {
  const coverage = file.covered / file.coverable * 100;
  const coverageDelta = file.prevRun && (coverage - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('div', {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e('div', {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable +
      (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function FileContent({file}) {
  return e('pre', {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e('code', {
          className: 'code-line'
            + (covered ? ' code-line_covered' : '')
            + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        }, line);
    })
  );
}

(function(){
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData && previousData.files.forEach((file) => {
    const path = file.path.slice(commonPath.length).join('/');
    prevFilesMap.set(path, file);
  });

  const files = data.files.map((file) => {
    const path = file.path.slice(commonPath.length);
    const { covered = 0, coverable = 0 } = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: { covered, coverable },
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    }
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));
}());
</script>
</body>
</html>